"use strict";(self.webpackChunkgleam_playground=self.webpackChunkgleam_playground||[]).push([[509],{1448:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>s});var i={comments:{lineComment:"//",blockComment:["(*","*)"]},brackets:[["{","}"],["[","]"],["(",")"],["<",">"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:"<",close:">"},{open:"'",close:"'"},{open:'"',close:'"'},{open:"(*",close:"*)"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:"<",close:">"},{open:"'",close:"'"},{open:'"',close:'"'},{open:"(*",close:"*)"}]},s={defaultToken:"",tokenPostfix:".cameligo",ignoreCase:!0,brackets:[{open:"{",close:"}",token:"delimiter.curly"},{open:"[",close:"]",token:"delimiter.square"},{open:"(",close:")",token:"delimiter.parenthesis"},{open:"<",close:">",token:"delimiter.angle"}],keywords:["abs","assert","block","Bytes","case","Crypto","Current","else","failwith","false","for","fun","if","in","let","let%entry","let%init","List","list","Map","map","match","match%nat","mod","not","operation","Operation","of","record","Set","set","sender","skip","source","String","then","to","true","type","with"],typeKeywords:["int","unit","string","tz","nat","bool"],operators:["=",">","<","<=",">=","<>",":",":=","and","mod","or","+","-","*","/","@","&","^","%","->","<-","&&","||"],symbols:/[=><:@\^&|+\-*\/\^%]+/,tokenizer:{root:[[/[a-zA-Z_][\w]*/,{cases:{"@keywords":{token:"keyword.$0"},"@default":"identifier"}}],{include:"@whitespace"},[/[{}()\[\]]/,"@brackets"],[/[<>](?!@symbols)/,"@brackets"],[/@symbols/,{cases:{"@operators":"delimiter","@default":""}}],[/\d*\.\d+([eE][\-+]?\d+)?/,"number.float"],[/\$[0-9a-fA-F]{1,16}/,"number.hex"],[/\d+/,"number"],[/[;,.]/,"delimiter"],[/'([^'\\]|\\.)*$/,"string.invalid"],[/'/,"string","@string"],[/'[^\\']'/,"string"],[/'/,"string.invalid"],[/\#\d+/,"string"]],comment:[[/[^\(\*]+/,"comment"],[/\*\)/,"comment","@pop"],[/\(\*/,"comment"]],string:[[/[^\\']+/,"string"],[/\\./,"string.escape.invalid"],[/'/,{token:"string.quote",bracket:"@close",next:"@pop"}]],whitespace:[[/[ \t\r\n]+/,"white"],[/\(\*/,"comment","@comment"],[/\/\/.*$/,"comment"]]}}},8946:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>s});var i={brackets:[],autoClosingPairs:[],surroundingPairs:[]},s={keywords:[],typeKeywords:[],tokenPostfix:".csp",operators:[],symbols:/[=><!~?:&|+\-*\/\^%]+/,escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,tokenizer:{root:[[/child-src/,"string.quote"],[/connect-src/,"string.quote"],[/default-src/,"string.quote"],[/font-src/,"string.quote"],[/frame-src/,"string.quote"],[/img-src/,"string.quote"],[/manifest-src/,"string.quote"],[/media-src/,"string.quote"],[/object-src/,"string.quote"],[/script-src/,"string.quote"],[/style-src/,"string.quote"],[/worker-src/,"string.quote"],[/base-uri/,"string.quote"],[/plugin-types/,"string.quote"],[/sandbox/,"string.quote"],[/disown-opener/,"string.quote"],[/form-action/,"string.quote"],[/frame-ancestors/,"string.quote"],[/report-uri/,"string.quote"],[/report-to/,"string.quote"],[/upgrade-insecure-requests/,"string.quote"],[/block-all-mixed-content/,"string.quote"],[/require-sri-for/,"string.quote"],[/reflected-xss/,"string.quote"],[/referrer/,"string.quote"],[/policy-uri/,"string.quote"],[/'self'/,"string.quote"],[/'unsafe-inline'/,"string.quote"],[/'unsafe-eval'/,"string.quote"],[/'strict-dynamic'/,"string.quote"],[/'unsafe-hashed-attributes'/,"string.quote"]]}}},6489:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>s});var i={comments:{lineComment:"#"},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"""',close:'"""',notIn:["string","comment"]},{open:'"',close:'"',notIn:["string","comment"]}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"""',close:'"""'},{open:'"',close:'"'}],folding:{offSide:!0}},s={defaultToken:"invalid",tokenPostfix:".gql",keywords:["null","true","false","query","mutation","subscription","extend","schema","directive","scalar","type","interface","union","enum","input","implements","fragment","on"],typeKeywords:["Int","Float","String","Boolean","ID"],directiveLocations:["SCHEMA","SCALAR","OBJECT","FIELD_DEFINITION","ARGUMENT_DEFINITION","INTERFACE","UNION","ENUM","ENUM_VALUE","INPUT_OBJECT","INPUT_FIELD_DEFINITION","QUERY","MUTATION","SUBSCRIPTION","FIELD","FRAGMENT_DEFINITION","FRAGMENT_SPREAD","INLINE_FRAGMENT","VARIABLE_DEFINITION"],operators:["=","!","?",":","&","|"],symbols:/[=!?:&|]+/,escapes:/\\(?:["\\\/bfnrt]|u[0-9A-Fa-f]{4})/,tokenizer:{root:[[/[a-z_][\w$]*/,{cases:{"@keywords":"keyword","@default":"key.identifier"}}],[/[$][\w$]*/,{cases:{"@keywords":"keyword","@default":"argument.identifier"}}],[/[A-Z][\w\$]*/,{cases:{"@typeKeywords":"keyword","@default":"type.identifier"}}],{include:"@whitespace"},[/[{}()\[\]]/,"@brackets"],[/@symbols/,{cases:{"@operators":"operator","@default":""}}],[/@\s*[a-zA-Z_\$][\w\$]*/,{token:"annotation",log:"annotation token: $0"}],[/\d*\.\d+([eE][\-+]?\d+)?/,"number.float"],[/0[xX][0-9a-fA-F]+/,"number.hex"],[/\d+/,"number"],[/[;,.]/,"delimiter"],[/"""/,{token:"string",next:"@mlstring",nextEmbedded:"markdown"}],[/"([^"\\]|\\.)*$/,"string.invalid"],[/"/,{token:"string.quote",bracket:"@open",next:"@string"}]],mlstring:[[/[^"]+/,"string"],['"""',{token:"string",next:"@pop",nextEmbedded:"@pop"}]],string:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,{token:"string.quote",bracket:"@close",next:"@pop"}]],whitespace:[[/[ \t\r\n]+/,""],[/#.*$/,"comment"]]}}},2571:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>r,language:()=>o});var i=t(9587),s=["area","base","br","col","embed","hr","img","input","keygen","link","menuitem","meta","param","source","track","wbr"],r={wordPattern:/(-?\d*\.\d\w*)|([^\`\~\!\@\$\^\&\*\(\)\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\s]+)/g,comments:{blockComment:["\x3c!--","--\x3e"]},brackets:[["\x3c!--","--\x3e"],["<",">"],["{","}"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:'"',close:'"'},{open:"'",close:"'"},{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:"<",close:">"}],onEnterRules:[{beforeText:new RegExp("<(?!(?:"+s.join("|")+"))([_:\\w][_:\\w-.\\d]*)([^/>]*(?!/)>)[^<]*$","i"),afterText:/^<\/([_:\w][_:\w-.\d]*)\s*>$/i,action:{indentAction:i.Mj.IndentAction.IndentOutdent}},{beforeText:new RegExp("<(?!(?:"+s.join("|")+"))(\\w[\\w\\d]*)([^/>]*(?!/)>)[^<]*$","i"),action:{indentAction:i.Mj.IndentAction.Indent}}],folding:{markers:{start:new RegExp("^\\s*\x3c!--\\s*#region\\b.*--\x3e"),end:new RegExp("^\\s*\x3c!--\\s*#endregion\\b.*--\x3e")}}},o={defaultToken:"",tokenPostfix:".html",ignoreCase:!0,tokenizer:{root:[[/<!DOCTYPE/,"metatag","@doctype"],[/<!--/,"comment","@comment"],[/(<)((?:[\w\-]+:)?[\w\-]+)(\s*)(\/>)/,["delimiter","tag","","delimiter"]],[/(<)(script)/,["delimiter",{token:"tag",next:"@script"}]],[/(<)(style)/,["delimiter",{token:"tag",next:"@style"}]],[/(<)((?:[\w\-]+:)?[\w\-]+)/,["delimiter",{token:"tag",next:"@otherTag"}]],[/(<\/)((?:[\w\-]+:)?[\w\-]+)/,["delimiter",{token:"tag",next:"@otherTag"}]],[/</,"delimiter"],[/[^<]+/]],doctype:[[/[^>]+/,"metatag.content"],[/>/,"metatag","@pop"]],comment:[[/-->/,"comment","@pop"],[/[^-]+/,"comment.content"],[/./,"comment.content"]],otherTag:[[/\/?>/,"delimiter","@pop"],[/"([^"]*)"/,"attribute.value"],[/'([^']*)'/,"attribute.value"],[/[\w\-]+/,"attribute.name"],[/=/,"delimiter"],[/[ \t\r\n]+/]],script:[[/type/,"attribute.name","@scriptAfterType"],[/"([^"]*)"/,"attribute.value"],[/'([^']*)'/,"attribute.value"],[/[\w\-]+/,"attribute.name"],[/=/,"delimiter"],[/>/,{token:"delimiter",next:"@scriptEmbedded",nextEmbedded:"text/javascript"}],[/[ \t\r\n]+/],[/(<\/)(script\s*)(>)/,["delimiter","tag",{token:"delimiter",next:"@pop"}]]],scriptAfterType:[[/=/,"delimiter","@scriptAfterTypeEquals"],[/>/,{token:"delimiter",next:"@scriptEmbedded",nextEmbedded:"text/javascript"}],[/[ \t\r\n]+/],[/<\/script\s*>/,{token:"@rematch",next:"@pop"}]],scriptAfterTypeEquals:[[/"([^"]*)"/,{token:"attribute.value",switchTo:"@scriptWithCustomType.$1"}],[/'([^']*)'/,{token:"attribute.value",switchTo:"@scriptWithCustomType.$1"}],[/>/,{token:"delimiter",next:"@scriptEmbedded",nextEmbedded:"text/javascript"}],[/[ \t\r\n]+/],[/<\/script\s*>/,{token:"@rematch",next:"@pop"}]],scriptWithCustomType:[[/>/,{token:"delimiter",next:"@scriptEmbedded.$S2",nextEmbedded:"$S2"}],[/"([^"]*)"/,"attribute.value"],[/'([^']*)'/,"attribute.value"],[/[\w\-]+/,"attribute.name"],[/=/,"delimiter"],[/[ \t\r\n]+/],[/<\/script\s*>/,{token:"@rematch",next:"@pop"}]],scriptEmbedded:[[/<\/script/,{token:"@rematch",next:"@pop",nextEmbedded:"@pop"}],[/[^<]+/,""]],style:[[/type/,"attribute.name","@styleAfterType"],[/"([^"]*)"/,"attribute.value"],[/'([^']*)'/,"attribute.value"],[/[\w\-]+/,"attribute.name"],[/=/,"delimiter"],[/>/,{token:"delimiter",next:"@styleEmbedded",nextEmbedded:"text/css"}],[/[ \t\r\n]+/],[/(<\/)(style\s*)(>)/,["delimiter","tag",{token:"delimiter",next:"@pop"}]]],styleAfterType:[[/=/,"delimiter","@styleAfterTypeEquals"],[/>/,{token:"delimiter",next:"@styleEmbedded",nextEmbedded:"text/css"}],[/[ \t\r\n]+/],[/<\/style\s*>/,{token:"@rematch",next:"@pop"}]],styleAfterTypeEquals:[[/"([^"]*)"/,{token:"attribute.value",switchTo:"@styleWithCustomType.$1"}],[/'([^']*)'/,{token:"attribute.value",switchTo:"@styleWithCustomType.$1"}],[/>/,{token:"delimiter",next:"@styleEmbedded",nextEmbedded:"text/css"}],[/[ \t\r\n]+/],[/<\/style\s*>/,{token:"@rematch",next:"@pop"}]],styleWithCustomType:[[/>/,{token:"delimiter",next:"@styleEmbedded.$S2",nextEmbedded:"$S2"}],[/"([^"]*)"/,"attribute.value"],[/'([^']*)'/,"attribute.value"],[/[\w\-]+/,"attribute.name"],[/=/,"delimiter"],[/[ \t\r\n]+/],[/<\/style\s*>/,{token:"@rematch",next:"@pop"}]],styleEmbedded:[[/<\/style/,{token:"@rematch",next:"@pop",nextEmbedded:"@pop"}],[/[^<]+/,""]]}}},2798:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>s});var i={comments:{lineComment:"#"},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}]},s={defaultToken:"",tokenPostfix:".ini",escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,tokenizer:{root:[[/^\[[^\]]*\]/,"metatag"],[/(^\w+)(\s*)(\=)/,["key","","delimiter"]],{include:"@whitespace"},[/\d+/,"number"],[/"([^"\\]|\\.)*$/,"string.invalid"],[/'([^'\\]|\\.)*$/,"string.invalid"],[/"/,"string",'@string."'],[/'/,"string","@string.'"]],whitespace:[[/[ \t\r\n]+/,""],[/^\s*[#;].*$/,"comment"]],string:[[/[^\\"']+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/["']/,{cases:{"$#==$S2":{token:"string",next:"@pop"},"@default":"string"}}]]}}},911:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>s});var i={comments:{lineComment:"--",blockComment:["--[[","]]"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}]},s={defaultToken:"",tokenPostfix:".lua",keywords:["and","break","do","else","elseif","end","false","for","function","goto","if","in","local","nil","not","or","repeat","return","then","true","until","while"],brackets:[{token:"delimiter.bracket",open:"{",close:"}"},{token:"delimiter.array",open:"[",close:"]"},{token:"delimiter.parenthesis",open:"(",close:")"}],operators:["+","-","*","/","%","^","#","==","~=","<=",">=","<",">","=",";",":",",",".","..","..."],symbols:/[=><!~?:&|+\-*\/\^%]+/,escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,tokenizer:{root:[[/[a-zA-Z_]\w*/,{cases:{"@keywords":{token:"keyword.$0"},"@default":"identifier"}}],{include:"@whitespace"},[/(,)(\s*)([a-zA-Z_]\w*)(\s*)(:)(?!:)/,["delimiter","","key","","delimiter"]],[/({)(\s*)([a-zA-Z_]\w*)(\s*)(:)(?!:)/,["@brackets","","key","","delimiter"]],[/[{}()\[\]]/,"@brackets"],[/@symbols/,{cases:{"@operators":"delimiter","@default":""}}],[/\d*\.\d+([eE][\-+]?\d+)?/,"number.float"],[/0[xX][0-9a-fA-F_]*[0-9a-fA-F]/,"number.hex"],[/\d+?/,"number"],[/[;,.]/,"delimiter"],[/"([^"\\]|\\.)*$/,"string.invalid"],[/'([^'\\]|\\.)*$/,"string.invalid"],[/"/,"string",'@string."'],[/'/,"string","@string.'"]],whitespace:[[/[ \t\r\n]+/,""],[/--\[([=]*)\[/,"comment","@comment.$1"],[/--.*$/,"comment"]],comment:[[/[^\]]+/,"comment"],[/\]([=]*)\]/,{cases:{"$1==$S2":{token:"comment",next:"@pop"},"@default":"comment"}}],[/./,"comment"]],string:[[/[^\\"']+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/["']/,{cases:{"$#==$S2":{token:"string",next:"@pop"},"@default":"string"}}]]}}},1961:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>s});var i={comments:{lineComment:"--",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}]},s={defaultToken:"",tokenPostfix:".sql",ignoreCase:!0,brackets:[{open:"[",close:"]",token:"delimiter.square"},{open:"(",close:")",token:"delimiter.parenthesis"}],keywords:["ACCESSIBLE","ADD","ALL","ALTER","ANALYZE","AND","AS","ASC","ASENSITIVE","BEFORE","BETWEEN","BIGINT","BINARY","BLOB","BOTH","BY","CALL","CASCADE","CASE","CHANGE","CHAR","CHARACTER","CHECK","COLLATE","COLUMN","CONDITION","CONSTRAINT","CONTINUE","CONVERT","CREATE","CROSS","CUBE","CUME_DIST","CURRENT_DATE","CURRENT_TIME","CURRENT_TIMESTAMP","CURRENT_USER","CURSOR","DATABASE","DATABASES","DAY_HOUR","DAY_MICROSECOND","DAY_MINUTE","DAY_SECOND","DEC","DECIMAL","DECLARE","DEFAULT","DELAYED","DELETE","DENSE_RANK","DESC","DESCRIBE","DETERMINISTIC","DISTINCT","DISTINCTROW","DIV","DOUBLE","DROP","DUAL","EACH","ELSE","ELSEIF","EMPTY","ENCLOSED","ESCAPED","EXCEPT","EXISTS","EXIT","EXPLAIN","FALSE","FETCH","FIRST_VALUE","FLOAT","FLOAT4","FLOAT8","FOR","FORCE","FOREIGN","FROM","FULLTEXT","FUNCTION","GENERATED","GET","GRANT","GROUP","GROUPING","GROUPS","HAVING","HIGH_PRIORITY","HOUR_MICROSECOND","HOUR_MINUTE","HOUR_SECOND","IF","IGNORE","IN","INDEX","INFILE","INNER","INOUT","INSENSITIVE","INSERT","INT","INT1","INT2","INT3","INT4","INT8","INTEGER","INTERVAL","INTO","IO_AFTER_GTIDS","IO_BEFORE_GTIDS","IS","ITERATE","JOIN","JSON_TABLE","KEY","KEYS","KILL","LAG","LAST_VALUE","LATERAL","LEAD","LEADING","LEAVE","LEFT","LIKE","LIMIT","LINEAR","LINES","LOAD","LOCALTIME","LOCALTIMESTAMP","LOCK","LONG","LONGBLOB","LONGTEXT","LOOP","LOW_PRIORITY","MASTER_BIND","MASTER_SSL_VERIFY_SERVER_CERT","MATCH","MAXVALUE","MEDIUMBLOB","MEDIUMINT","MEDIUMTEXT","MIDDLEINT","MINUTE_MICROSECOND","MINUTE_SECOND","MOD","MODIFIES","NATURAL","NOT","NO_WRITE_TO_BINLOG","NTH_VALUE","NTILE","NULL","NUMERIC","OF","ON","OPTIMIZE","OPTIMIZER_COSTS","OPTION","OPTIONALLY","OR","ORDER","OUT","OUTER","OUTFILE","OVER","PARTITION","PERCENT_RANK","PRECISION","PRIMARY","PROCEDURE","PURGE","RANGE","RANK","READ","READS","READ_WRITE","REAL","RECURSIVE","REFERENCES","REGEXP","RELEASE","RENAME","REPEAT","REPLACE","REQUIRE","RESIGNAL","RESTRICT","RETURN","REVOKE","RIGHT","RLIKE","ROW","ROWS","ROW_NUMBER","SCHEMA","SCHEMAS","SECOND_MICROSECOND","SELECT","SENSITIVE","SEPARATOR","SET","SHOW","SIGNAL","SMALLINT","SPATIAL","SPECIFIC","SQL","SQLEXCEPTION","SQLSTATE","SQLWARNING","SQL_BIG_RESULT","SQL_CALC_FOUND_ROWS","SQL_SMALL_RESULT","SSL","STARTING","STORED","STRAIGHT_JOIN","SYSTEM","TABLE","TERMINATED","THEN","TINYBLOB","TINYINT","TINYTEXT","TO","TRAILING","TRIGGER","TRUE","UNDO","UNION","UNIQUE","UNLOCK","UNSIGNED","UPDATE","USAGE","USE","USING","UTC_DATE","UTC_TIME","UTC_TIMESTAMP","VALUES","VARBINARY","VARCHAR","VARCHARACTER","VARYING","VIRTUAL","WHEN","WHERE","WHILE","WINDOW","WITH","WRITE","XOR","YEAR_MONTH","ZEROFILL"],operators:["AND","BETWEEN","IN","LIKE","NOT","OR","IS","NULL","INTERSECT","UNION","INNER","JOIN","LEFT","OUTER","RIGHT"],builtinFunctions:["ABS","ACOS","ADDDATE","ADDTIME","AES_DECRYPT","AES_ENCRYPT","ANY_VALUE","Area","AsBinary","AsWKB","ASCII","ASIN","AsText","AsWKT","ASYMMETRIC_DECRYPT","ASYMMETRIC_DERIVE","ASYMMETRIC_ENCRYPT","ASYMMETRIC_SIGN","ASYMMETRIC_VERIFY","ATAN","ATAN2","ATAN","AVG","BENCHMARK","BIN","BIT_AND","BIT_COUNT","BIT_LENGTH","BIT_OR","BIT_XOR","Buffer","CAST","CEIL","CEILING","Centroid","CHAR","CHAR_LENGTH","CHARACTER_LENGTH","CHARSET","COALESCE","COERCIBILITY","COLLATION","COMPRESS","CONCAT","CONCAT_WS","CONNECTION_ID","Contains","CONV","CONVERT","CONVERT_TZ","ConvexHull","COS","COT","COUNT","CRC32","CREATE_ASYMMETRIC_PRIV_KEY","CREATE_ASYMMETRIC_PUB_KEY","CREATE_DH_PARAMETERS","CREATE_DIGEST","Crosses","CURDATE","CURRENT_DATE","CURRENT_TIME","CURRENT_TIMESTAMP","CURRENT_USER","CURTIME","DATABASE","DATE","DATE_ADD","DATE_FORMAT","DATE_SUB","DATEDIFF","DAY","DAYNAME","DAYOFMONTH","DAYOFWEEK","DAYOFYEAR","DECODE","DEFAULT","DEGREES","DES_DECRYPT","DES_ENCRYPT","Dimension","Disjoint","Distance","ELT","ENCODE","ENCRYPT","EndPoint","Envelope","Equals","EXP","EXPORT_SET","ExteriorRing","EXTRACT","ExtractValue","FIELD","FIND_IN_SET","FLOOR","FORMAT","FOUND_ROWS","FROM_BASE64","FROM_DAYS","FROM_UNIXTIME","GeomCollFromText","GeometryCollectionFromText","GeomCollFromWKB","GeometryCollectionFromWKB","GeometryCollection","GeometryN","GeometryType","GeomFromText","GeometryFromText","GeomFromWKB","GeometryFromWKB","GET_FORMAT","GET_LOCK","GLength","GREATEST","GROUP_CONCAT","GTID_SUBSET","GTID_SUBTRACT","HEX","HOUR","IF","IFNULL","INET_ATON","INET_NTOA","INET6_ATON","INET6_NTOA","INSERT","INSTR","InteriorRingN","Intersects","INTERVAL","IS_FREE_LOCK","IS_IPV4","IS_IPV4_COMPAT","IS_IPV4_MAPPED","IS_IPV6","IS_USED_LOCK","IsClosed","IsEmpty","ISNULL","IsSimple","JSON_APPEND","JSON_ARRAY","JSON_ARRAY_APPEND","JSON_ARRAY_INSERT","JSON_CONTAINS","JSON_CONTAINS_PATH","JSON_DEPTH","JSON_EXTRACT","JSON_INSERT","JSON_KEYS","JSON_LENGTH","JSON_MERGE","JSON_MERGE_PRESERVE","JSON_OBJECT","JSON_QUOTE","JSON_REMOVE","JSON_REPLACE","JSON_SEARCH","JSON_SET","JSON_TYPE","JSON_UNQUOTE","JSON_VALID","LAST_INSERT_ID","LCASE","LEAST","LEFT","LENGTH","LineFromText","LineStringFromText","LineFromWKB","LineStringFromWKB","LineString","LN","LOAD_FILE","LOCALTIME","LOCALTIMESTAMP","LOCATE","LOG","LOG10","LOG2","LOWER","LPAD","LTRIM","MAKE_SET","MAKEDATE","MAKETIME","MASTER_POS_WAIT","MAX","MBRContains","MBRCoveredBy","MBRCovers","MBRDisjoint","MBREqual","MBREquals","MBRIntersects","MBROverlaps","MBRTouches","MBRWithin","MD5","MICROSECOND","MID","MIN","MINUTE","MLineFromText","MultiLineStringFromText","MLineFromWKB","MultiLineStringFromWKB","MOD","MONTH","MONTHNAME","MPointFromText","MultiPointFromText","MPointFromWKB","MultiPointFromWKB","MPolyFromText","MultiPolygonFromText","MPolyFromWKB","MultiPolygonFromWKB","MultiLineString","MultiPoint","MultiPolygon","NAME_CONST","NOT IN","NOW","NULLIF","NumGeometries","NumInteriorRings","NumPoints","OCT","OCTET_LENGTH","OLD_PASSWORD","ORD","Overlaps","PASSWORD","PERIOD_ADD","PERIOD_DIFF","PI","Point","PointFromText","PointFromWKB","PointN","PolyFromText","PolygonFromText","PolyFromWKB","PolygonFromWKB","Polygon","POSITION","POW","POWER","PROCEDURE ANALYSE","QUARTER","QUOTE","RADIANS","RAND","RANDOM_BYTES","RELEASE_ALL_LOCKS","RELEASE_LOCK","REPEAT","REPLACE","REVERSE","RIGHT","ROUND","ROW_COUNT","RPAD","RTRIM","SCHEMA","SEC_TO_TIME","SECOND","SESSION_USER","SHA1","SHA","SHA2","SIGN","SIN","SLEEP","SOUNDEX","SPACE","SQRT","SRID","ST_Area","ST_AsBinary","ST_AsWKB","ST_AsGeoJSON","ST_AsText","ST_AsWKT","ST_Buffer","ST_Buffer_Strategy","ST_Centroid","ST_Contains","ST_ConvexHull","ST_Crosses","ST_Difference","ST_Dimension","ST_Disjoint","ST_Distance","ST_Distance_Sphere","ST_EndPoint","ST_Envelope","ST_Equals","ST_ExteriorRing","ST_GeoHash","ST_GeomCollFromText","ST_GeometryCollectionFromText","ST_GeomCollFromTxt","ST_GeomCollFromWKB","ST_GeometryCollectionFromWKB","ST_GeometryN","ST_GeometryType","ST_GeomFromGeoJSON","ST_GeomFromText","ST_GeometryFromText","ST_GeomFromWKB","ST_GeometryFromWKB","ST_InteriorRingN","ST_Intersection","ST_Intersects","ST_IsClosed","ST_IsEmpty","ST_IsSimple","ST_IsValid","ST_LatFromGeoHash","ST_Length","ST_LineFromText","ST_LineStringFromText","ST_LineFromWKB","ST_LineStringFromWKB","ST_LongFromGeoHash","ST_MakeEnvelope","ST_MLineFromText","ST_MultiLineStringFromText","ST_MLineFromWKB","ST_MultiLineStringFromWKB","ST_MPointFromText","ST_MultiPointFromText","ST_MPointFromWKB","ST_MultiPointFromWKB","ST_MPolyFromText","ST_MultiPolygonFromText","ST_MPolyFromWKB","ST_MultiPolygonFromWKB","ST_NumGeometries","ST_NumInteriorRing","ST_NumInteriorRings","ST_NumPoints","ST_Overlaps","ST_PointFromGeoHash","ST_PointFromText","ST_PointFromWKB","ST_PointN","ST_PolyFromText","ST_PolygonFromText","ST_PolyFromWKB","ST_PolygonFromWKB","ST_Simplify","ST_SRID","ST_StartPoint","ST_SymDifference","ST_Touches","ST_Union","ST_Validate","ST_Within","ST_X","ST_Y","StartPoint","STD","STDDEV","STDDEV_POP","STDDEV_SAMP","STR_TO_DATE","STRCMP","SUBDATE","SUBSTR","SUBSTRING","SUBSTRING_INDEX","SUBTIME","SUM","SYSDATE","SYSTEM_USER","TAN","TIME","TIME_FORMAT","TIME_TO_SEC","TIMEDIFF","TIMESTAMP","TIMESTAMPADD","TIMESTAMPDIFF","TO_BASE64","TO_DAYS","TO_SECONDS","Touches","TRIM","TRUNCATE","UCASE","UNCOMPRESS","UNCOMPRESSED_LENGTH","UNHEX","UNIX_TIMESTAMP","UpdateXML","UPPER","USER","UTC_DATE","UTC_TIME","UTC_TIMESTAMP","UUID","UUID_SHORT","VALIDATE_PASSWORD_STRENGTH","VALUES","VAR_POP","VAR_SAMP","VARIANCE","VERSION","WAIT_FOR_EXECUTED_GTID_SET","WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS","WEEK","WEEKDAY","WEEKOFYEAR","WEIGHT_STRING","Within","X","Y","YEAR","YEARWEEK"],builtinVariables:[],tokenizer:{root:[{include:"@comments"},{include:"@whitespace"},{include:"@numbers"},{include:"@strings"},{include:"@complexIdentifiers"},{include:"@scopes"},[/[;,.]/,"delimiter"],[/[()]/,"@brackets"],[/[\w@]+/,{cases:{"@operators":"operator","@builtinVariables":"predefined","@builtinFunctions":"predefined","@keywords":"keyword","@default":"identifier"}}],[/[<>=!%&+\-*/|~^]/,"operator"]],whitespace:[[/\s+/,"white"]],comments:[[/--+.*/,"comment"],[/#+.*/,"comment"],[/\/\*/,{token:"comment.quote",next:"@comment"}]],comment:[[/[^*/]+/,"comment"],[/\*\//,{token:"comment.quote",next:"@pop"}],[/./,"comment"]],numbers:[[/0[xX][0-9a-fA-F]*/,"number"],[/[$][+-]*\d*(\.\d*)?/,"number"],[/((\d+(\.\d*)?)|(\.\d+))([eE][\-+]?\d+)?/,"number"]],strings:[[/'/,{token:"string",next:"@string"}],[/"/,{token:"string.double",next:"@stringDouble"}]],string:[[/[^']+/,"string"],[/''/,"string"],[/'/,{token:"string",next:"@pop"}]],stringDouble:[[/[^"]+/,"string.double"],[/""/,"string.double"],[/"/,{token:"string.double",next:"@pop"}]],complexIdentifiers:[[/`/,{token:"identifier.quote",next:"@quotedIdentifier"}]],quotedIdentifier:[[/[^`]+/,"identifier"],[/``/,"identifier"],[/`/,{token:"identifier.quote",next:"@pop"}]],scopes:[]}}},9537:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>s});var i={comments:{lineComment:"//",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}]},s={defaultToken:"",tokenPostfix:".objective-c",keywords:["#import","#include","#define","#else","#endif","#if","#ifdef","#ifndef","#ident","#undef","@class","@defs","@dynamic","@encode","@end","@implementation","@interface","@package","@private","@protected","@property","@protocol","@public","@selector","@synthesize","__declspec","assign","auto","BOOL","break","bycopy","byref","case","char","Class","const","copy","continue","default","do","double","else","enum","extern","FALSE","false","float","for","goto","if","in","int","id","inout","IMP","long","nil","nonatomic","NULL","oneway","out","private","public","protected","readwrite","readonly","register","return","SEL","self","short","signed","sizeof","static","struct","super","switch","typedef","TRUE","true","union","unsigned","volatile","void","while"],decpart:/\d(_?\d)*/,decimal:/0|@decpart/,tokenizer:{root:[{include:"@comments"},{include:"@whitespace"},{include:"@numbers"},{include:"@strings"},[/[,:;]/,"delimiter"],[/[{}\[\]()<>]/,"@brackets"],[/[a-zA-Z@#]\w*/,{cases:{"@keywords":"keyword","@default":"identifier"}}],[/[<>=\\+\\-\\*\\/\\^\\|\\~,]|and\\b|or\\b|not\\b]/,"operator"]],whitespace:[[/\s+/,"white"]],comments:[["\\/\\*","comment","@comment"],["\\/\\/+.*","comment"]],comment:[["\\*\\/","comment","@pop"],[".","comment"]],numbers:[[/0[xX][0-9a-fA-F]*(_?[0-9a-fA-F])*/,"number.hex"],[/@decimal((\.@decpart)?([eE][\-+]?@decpart)?)[fF]*/,{cases:{"(\\d)*":"number",$0:"number.float"}}]],strings:[[/'$/,"string.escape","@popall"],[/'/,"string.escape","@stringBody"],[/"$/,"string.escape","@popall"],[/"/,"string.escape","@dblStringBody"]],stringBody:[[/[^\\']+$/,"string","@popall"],[/[^\\']+/,"string"],[/\\./,"string"],[/'/,"string.escape","@popall"],[/\\$/,"string"]],dblStringBody:[[/[^\\"]+$/,"string","@popall"],[/[^\\"]+/,"string"],[/\\./,"string"],[/"/,"string.escape","@popall"],[/\\$/,"string"]]}}},8180:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>s});var i={comments:{lineComment:"//",blockComment:["(*","*)"]},brackets:[["{","}"],["[","]"],["(",")"],["<",">"]],autoClosingPairs:[{open:'"',close:'"',notIn:["string","comment"]},{open:"{",close:"}",notIn:["string","comment"]},{open:"[",close:"]",notIn:["string","comment"]},{open:"(",close:")",notIn:["string","comment"]}]},s={tokenPostfix:".pats",defaultToken:"invalid",keywords:["abstype","abst0ype","absprop","absview","absvtype","absviewtype","absvt0ype","absviewt0ype","as","and","assume","begin","classdec","datasort","datatype","dataprop","dataview","datavtype","dataviewtype","do","end","extern","extype","extvar","exception","fn","fnx","fun","prfn","prfun","praxi","castfn","if","then","else","ifcase","in","infix","infixl","infixr","prefix","postfix","implmnt","implement","primplmnt","primplement","import","let","local","macdef","macrodef","nonfix","symelim","symintr","overload","of","op","rec","sif","scase","sortdef","sta","stacst","stadef","static","staload","dynload","try","tkindef","typedef","propdef","viewdef","vtypedef","viewtypedef","prval","var","prvar","when","where","with","withtype","withprop","withview","withvtype","withviewtype"],keywords_dlr:["$delay","$ldelay","$arrpsz","$arrptrsize","$d2ctype","$effmask","$effmask_ntm","$effmask_exn","$effmask_ref","$effmask_wrt","$effmask_all","$extern","$extkind","$extype","$extype_struct","$extval","$extfcall","$extmcall","$literal","$myfilename","$mylocation","$myfunction","$lst","$lst_t","$lst_vt","$list","$list_t","$list_vt","$rec","$rec_t","$rec_vt","$record","$record_t","$record_vt","$tup","$tup_t","$tup_vt","$tuple","$tuple_t","$tuple_vt","$break","$continue","$raise","$showtype","$vcopyenv_v","$vcopyenv_vt","$tempenver","$solver_assert","$solver_verify"],keywords_srp:["#if","#ifdef","#ifndef","#then","#elif","#elifdef","#elifndef","#else","#endif","#error","#prerr","#print","#assert","#undef","#define","#include","#require","#pragma","#codegen2","#codegen3"],irregular_keyword_list:["val+","val-","val","case+","case-","case","addr@","addr","fold@","free@","fix@","fix","lam@","lam","llam@","llam","viewt@ype+","viewt@ype-","viewt@ype","viewtype+","viewtype-","viewtype","view+","view-","view@","view","type+","type-","type","vtype+","vtype-","vtype","vt@ype+","vt@ype-","vt@ype","viewt@ype+","viewt@ype-","viewt@ype","viewtype+","viewtype-","viewtype","prop+","prop-","prop","type+","type-","type","t@ype","t@ype+","t@ype-","abst@ype","abstype","absviewt@ype","absvt@ype","for*","for","while*","while"],keywords_types:["bool","double","byte","int","short","char","void","unit","long","float","string","strptr"],keywords_effects:["0","fun","clo","prf","funclo","cloptr","cloref","ref","ntm","1"],operators:["@","!","|","`",":","$",".","=","#","~","..","...","=>","=<>","=/=>","=>>","=/=>>","<",">","><",".<",">.",".<>.","->","-<>"],brackets:[{open:",(",close:")",token:"delimiter.parenthesis"},{open:"`(",close:")",token:"delimiter.parenthesis"},{open:"%(",close:")",token:"delimiter.parenthesis"},{open:"'(",close:")",token:"delimiter.parenthesis"},{open:"'{",close:"}",token:"delimiter.parenthesis"},{open:"@(",close:")",token:"delimiter.parenthesis"},{open:"@{",close:"}",token:"delimiter.brace"},{open:"@[",close:"]",token:"delimiter.square"},{open:"#[",close:"]",token:"delimiter.square"},{open:"{",close:"}",token:"delimiter.curly"},{open:"[",close:"]",token:"delimiter.square"},{open:"(",close:")",token:"delimiter.parenthesis"},{open:"<",close:">",token:"delimiter.angle"}],symbols:/[=><!~?:&|+\-*\/\^%]+/,IDENTFST:/[a-zA-Z_]/,IDENTRST:/[a-zA-Z0-9_'$]/,symbolic:/[%&+-./:=@~`^|*!$#?<>]/,digit:/[0-9]/,digitseq0:/@digit*/,xdigit:/[0-9A-Za-z]/,xdigitseq0:/@xdigit*/,INTSP:/[lLuU]/,FLOATSP:/[fFlL]/,fexponent:/[eE][+-]?[0-9]+/,fexponent_bin:/[pP][+-]?[0-9]+/,deciexp:/\.[0-9]*@fexponent?/,hexiexp:/\.[0-9a-zA-Z]*@fexponent_bin?/,irregular_keywords:/val[+-]?|case[+-]?|addr\@?|fold\@|free\@|fix\@?|lam\@?|llam\@?|prop[+-]?|type[+-]?|view[+-@]?|viewt@?ype[+-]?|t@?ype[+-]?|v(iew)?t@?ype[+-]?|abst@?ype|absv(iew)?t@?ype|for\*?|while\*?/,ESCHAR:/[ntvbrfa\\\?'"\(\[\{]/,start:"root",tokenizer:{root:[{regex:/[ \t\r\n]+/,action:{token:""}},{regex:/\(\*\)/,action:{token:"invalid"}},{regex:/\(\*/,action:{token:"comment",next:"lexing_COMMENT_block_ml"}},{regex:/\(/,action:"@brackets"},{regex:/\)/,action:"@brackets"},{regex:/\[/,action:"@brackets"},{regex:/\]/,action:"@brackets"},{regex:/\{/,action:"@brackets"},{regex:/\}/,action:"@brackets"},{regex:/,\(/,action:"@brackets"},{regex:/,/,action:{token:"delimiter.comma"}},{regex:/;/,action:{token:"delimiter.semicolon"}},{regex:/@\(/,action:"@brackets"},{regex:/@\[/,action:"@brackets"},{regex:/@\{/,action:"@brackets"},{regex:/:</,action:{token:"keyword",next:"@lexing_EFFECT_commaseq0"}},{regex:/\.@symbolic+/,action:{token:"identifier.sym"}},{regex:/\.@digit*@fexponent@FLOATSP*/,action:{token:"number.float"}},{regex:/\.@digit+/,action:{token:"number.float"}},{regex:/\$@IDENTFST@IDENTRST*/,action:{cases:{"@keywords_dlr":{token:"keyword.dlr"},"@default":{token:"namespace"}}}},{regex:/\#@IDENTFST@IDENTRST*/,action:{cases:{"@keywords_srp":{token:"keyword.srp"},"@default":{token:"identifier"}}}},{regex:/%\(/,action:{token:"delimiter.parenthesis"}},{regex:/^%{(#|\^|\$)?/,action:{token:"keyword",next:"@lexing_EXTCODE",nextEmbedded:"text/javascript"}},{regex:/^%}/,action:{token:"keyword"}},{regex:/'\(/,action:{token:"delimiter.parenthesis"}},{regex:/'\[/,action:{token:"delimiter.bracket"}},{regex:/'\{/,action:{token:"delimiter.brace"}},[/(')(\\@ESCHAR|\\[xX]@xdigit+|\\@digit+)(')/,["string","string.escape","string"]],[/'[^\\']'/,"string"],[/"/,"string.quote","@lexing_DQUOTE"],{regex:/`\(/,action:"@brackets"},{regex:/\\/,action:{token:"punctuation"}},{regex:/@irregular_keywords(?!@IDENTRST)/,action:{token:"keyword"}},{regex:/@IDENTFST@IDENTRST*[<!\[]?/,action:{cases:{"@keywords":{token:"keyword"},"@keywords_types":{token:"type"},"@default":{token:"identifier"}}}},{regex:/\/\/\/\//,action:{token:"comment",next:"@lexing_COMMENT_rest"}},{regex:/\/\/.*$/,action:{token:"comment"}},{regex:/\/\*/,action:{token:"comment",next:"@lexing_COMMENT_block_c"}},{regex:/-<|=</,action:{token:"keyword",next:"@lexing_EFFECT_commaseq0"}},{regex:/@symbolic+/,action:{cases:{"@operators":"keyword","@default":"operator"}}},{regex:/0[xX]@xdigit+(@hexiexp|@fexponent_bin)@FLOATSP*/,action:{token:"number.float"}},{regex:/0[xX]@xdigit+@INTSP*/,action:{token:"number.hex"}},{regex:/0[0-7]+(?![0-9])@INTSP*/,action:{token:"number.octal"}},{regex:/@digit+(@fexponent|@deciexp)@FLOATSP*/,action:{token:"number.float"}},{regex:/@digit@digitseq0@INTSP*/,action:{token:"number.decimal"}},{regex:/@digit+@INTSP*/,action:{token:"number"}}],lexing_COMMENT_block_ml:[[/[^\(\*]+/,"comment"],[/\(\*/,"comment","@push"],[/\(\*/,"comment.invalid"],[/\*\)/,"comment","@pop"],[/\*/,"comment"]],lexing_COMMENT_block_c:[[/[^\/*]+/,"comment"],[/\*\//,"comment","@pop"],[/[\/*]/,"comment"]],lexing_COMMENT_rest:[[/$/,"comment","@pop"],[/.*/,"comment"]],lexing_EFFECT_commaseq0:[{regex:/@IDENTFST@IDENTRST+|@digit+/,action:{cases:{"@keywords_effects":{token:"type.effect"},"@default":{token:"identifier"}}}},{regex:/,/,action:{token:"punctuation"}},{regex:/>/,action:{token:"@rematch",next:"@pop"}}],lexing_EXTCODE:[{regex:/^%}/,action:{token:"@rematch",next:"@pop",nextEmbedded:"@pop"}},{regex:/[^%]+/,action:""}],lexing_DQUOTE:[{regex:/"/,action:{token:"string.quote",next:"@pop"}},{regex:/(\{\$)(@IDENTFST@IDENTRST*)(\})/,action:[{token:"string.escape"},{token:"identifier"},{token:"string.escape"}]},{regex:/\\$/,action:{token:"string.escape"}},{regex:/\\(@ESCHAR|[xX]@xdigit+|@digit+)/,action:{token:"string.escape"}},{regex:/[^\\"]+/,action:{token:"string"}}]}}},9684:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>s});var i={comments:{lineComment:"#",blockComment:["=begin","=end"]},brackets:[["(",")"],["{","}"],["[","]"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],indentationRules:{increaseIndentPattern:new RegExp("^\\s*((begin|class|(private|protected)\\s+def|def|else|elsif|ensure|for|if|module|rescue|unless|until|when|while|case)|([^#]*\\sdo\\b)|([^#]*=\\s*(case|if|unless)))\\b([^#\\{;]|(\"|'|/).*\\4)*(#.*)?$"),decreaseIndentPattern:new RegExp("^\\s*([}\\]]([,)]?\\s*(#|$)|\\.[a-zA-Z_]\\w*\\b)|(end|rescue|ensure|else|elsif|when)\\b)")}},s={tokenPostfix:".ruby",keywords:["__LINE__","__ENCODING__","__FILE__","BEGIN","END","alias","and","begin","break","case","class","def","defined?","do","else","elsif","end","ensure","for","false","if","in","module","next","nil","not","or","redo","rescue","retry","return","self","super","then","true","undef","unless","until","when","while","yield"],keywordops:["::","..","...","?",":","=>"],builtins:["require","public","private","include","extend","attr_reader","protected","private_class_method","protected_class_method","new"],declarations:["module","class","def","case","do","begin","for","if","while","until","unless"],linedecls:["def","case","do","begin","for","if","while","until","unless"],operators:["^","&","|","<=>","==","===","!~","=~",">",">=","<","<=","<<",">>","+","-","*","/","%","**","~","+@","-@","[]","[]=","`","+=","-=","*=","**=","/=","^=","%=","<<=",">>=","&=","&&=","||=","|="],brackets:[{open:"(",close:")",token:"delimiter.parenthesis"},{open:"{",close:"}",token:"delimiter.curly"},{open:"[",close:"]",token:"delimiter.square"}],symbols:/[=><!~?:&|+\-*\/\^%\.]+/,escape:/(?:[abefnrstv\\"'\n\r]|[0-7]{1,3}|x[0-9A-Fa-f]{1,2}|u[0-9A-Fa-f]{4})/,escapes:/\\(?:C\-(@escape|.)|c(@escape|.)|@escape)/,decpart:/\d(_?\d)*/,decimal:/0|@decpart/,delim:/[^a-zA-Z0-9\s\n\r]/,heredelim:/(?:\w+|'[^']*'|"[^"]*"|`[^`]*`)/,regexpctl:/[(){}\[\]\$\^|\-*+?\.]/,regexpesc:/\\(?:[AzZbBdDfnrstvwWn0\\\/]|@regexpctl|c[A-Z]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4})?/,tokenizer:{root:[[/^(\s*)([a-z_]\w*[!?=]?)/,["white",{cases:{"for|until|while":{token:"keyword.$2",next:"@dodecl.$2"},"@declarations":{token:"keyword.$2",next:"@root.$2"},end:{token:"keyword.$S2",next:"@pop"},"@keywords":"keyword","@builtins":"predefined","@default":"identifier"}}]],[/[a-z_]\w*[!?=]?/,{cases:{"if|unless|while|until":{token:"keyword.$0x",next:"@modifier.$0x"},for:{token:"keyword.$2",next:"@dodecl.$2"},"@linedecls":{token:"keyword.$0",next:"@root.$0"},end:{token:"keyword.$S2",next:"@pop"},"@keywords":"keyword","@builtins":"predefined","@default":"identifier"}}],[/[A-Z][\w]*[!?=]?/,"constructor.identifier"],[/\$[\w]*/,"global.constant"],[/@[\w]*/,"namespace.instance.identifier"],[/@@@[\w]*/,"namespace.class.identifier"],[/<<[-~](@heredelim).*/,{token:"string.heredoc.delimiter",next:"@heredoc.$1"}],[/[ \t\r\n]+<<(@heredelim).*/,{token:"string.heredoc.delimiter",next:"@heredoc.$1"}],[/^<<(@heredelim).*/,{token:"string.heredoc.delimiter",next:"@heredoc.$1"}],{include:"@whitespace"},[/"/,{token:"string.d.delim",next:'@dstring.d."'}],[/'/,{token:"string.sq.delim",next:"@sstring.sq"}],[/%([rsqxwW]|Q?)/,{token:"@rematch",next:"pstring"}],[/`/,{token:"string.x.delim",next:"@dstring.x.`"}],[/:(\w|[$@])\w*[!?=]?/,"string.s"],[/:"/,{token:"string.s.delim",next:'@dstring.s."'}],[/:'/,{token:"string.s.delim",next:"@sstring.s"}],[/\/(?=(\\\/|[^\/\n])+\/)/,{token:"regexp.delim",next:"@regexp"}],[/[{}()\[\]]/,"@brackets"],[/@symbols/,{cases:{"@keywordops":"keyword","@operators":"operator","@default":""}}],[/[;,]/,"delimiter"],[/0[xX][0-9a-fA-F](_?[0-9a-fA-F])*/,"number.hex"],[/0[_oO][0-7](_?[0-7])*/,"number.octal"],[/0[bB][01](_?[01])*/,"number.binary"],[/0[dD]@decpart/,"number"],[/@decimal((\.@decpart)?([eE][\-+]?@decpart)?)/,{cases:{$1:"number.float","@default":"number"}}]],dodecl:[[/^/,{token:"",switchTo:"@root.$S2"}],[/[a-z_]\w*[!?=]?/,{cases:{end:{token:"keyword.$S2",next:"@pop"},do:{token:"keyword",switchTo:"@root.$S2"},"@linedecls":{token:"@rematch",switchTo:"@root.$S2"},"@keywords":"keyword","@builtins":"predefined","@default":"identifier"}}],{include:"@root"}],modifier:[[/^/,"","@pop"],[/[a-z_]\w*[!?=]?/,{cases:{end:{token:"keyword.$S2",next:"@pop"},"then|else|elsif|do":{token:"keyword",switchTo:"@root.$S2"},"@linedecls":{token:"@rematch",switchTo:"@root.$S2"},"@keywords":"keyword","@builtins":"predefined","@default":"identifier"}}],{include:"@root"}],sstring:[[/[^\\']+/,"string.$S2"],[/\\\\|\\'|\\$/,"string.$S2.escape"],[/\\./,"string.$S2.invalid"],[/'/,{token:"string.$S2.delim",next:"@pop"}]],dstring:[[/[^\\`"#]+/,"string.$S2"],[/#/,"string.$S2.escape","@interpolated"],[/\\$/,"string.$S2.escape"],[/@escapes/,"string.$S2.escape"],[/\\./,"string.$S2.escape.invalid"],[/[`"]/,{cases:{"$#==$S3":{token:"string.$S2.delim",next:"@pop"},"@default":"string.$S2"}}]],heredoc:[[/^(\s*)(@heredelim)$/,{cases:{"$2==$S2":["string.heredoc",{token:"string.heredoc.delimiter",next:"@pop"}],"@default":["string.heredoc","string.heredoc"]}}],[/.*/,"string.heredoc"]],interpolated:[[/\$\w*/,"global.constant","@pop"],[/@\w*/,"namespace.class.identifier","@pop"],[/@@@\w*/,"namespace.instance.identifier","@pop"],[/[{]/,{token:"string.escape.curly",switchTo:"@interpolated_compound"}],["","","@pop"]],interpolated_compound:[[/[}]/,{token:"string.escape.curly",next:"@pop"}],{include:"@root"}],pregexp:[{include:"@whitespace"},[/[^\(\{\[\\]/,{cases:{"$#==$S3":{token:"regexp.delim",next:"@pop"},"$#==$S2":{token:"regexp.delim",next:"@push"},"~[)}\\]]":"@brackets.regexp.escape.control","~@regexpctl":"regexp.escape.control","@default":"regexp"}}],{include:"@regexcontrol"}],regexp:[{include:"@regexcontrol"},[/[^\\\/]/,"regexp"],["/[ixmp]*",{token:"regexp.delim"},"@pop"]],regexcontrol:[[/(\{)(\d+(?:,\d*)?)(\})/,["@brackets.regexp.escape.control","regexp.escape.control","@brackets.regexp.escape.control"]],[/(\[)(\^?)/,["@brackets.regexp.escape.control",{token:"regexp.escape.control",next:"@regexrange"}]],[/(\()(\?[:=!])/,["@brackets.regexp.escape.control","regexp.escape.control"]],[/\(\?#/,{token:"regexp.escape.control",next:"@regexpcomment"}],[/[()]/,"@brackets.regexp.escape.control"],[/@regexpctl/,"regexp.escape.control"],[/\\$/,"regexp.escape"],[/@regexpesc/,"regexp.escape"],[/\\\./,"regexp.invalid"],[/#/,"regexp.escape","@interpolated"]],regexrange:[[/-/,"regexp.escape.control"],[/\^/,"regexp.invalid"],[/\\$/,"regexp.escape"],[/@regexpesc/,"regexp.escape"],[/[^\]]/,"regexp"],[/\]/,"@brackets.regexp.escape.control","@pop"]],regexpcomment:[[/[^)]+/,"comment"],[/\)/,{token:"regexp.escape.control",next:"@pop"}]],pstring:[[/%([qws])\(/,{token:"string.$1.delim",switchTo:"@qstring.$1.(.)"}],[/%([qws])\[/,{token:"string.$1.delim",switchTo:"@qstring.$1.[.]"}],[/%([qws])\{/,{token:"string.$1.delim",switchTo:"@qstring.$1.{.}"}],[/%([qws])</,{token:"string.$1.delim",switchTo:"@qstring.$1.<.>"}],[/%([qws])(@delim)/,{token:"string.$1.delim",switchTo:"@qstring.$1.$2.$2"}],[/%r\(/,{token:"regexp.delim",switchTo:"@pregexp.(.)"}],[/%r\[/,{token:"regexp.delim",switchTo:"@pregexp.[.]"}],[/%r\{/,{token:"regexp.delim",switchTo:"@pregexp.{.}"}],[/%r</,{token:"regexp.delim",switchTo:"@pregexp.<.>"}],[/%r(@delim)/,{token:"regexp.delim",switchTo:"@pregexp.$1.$1"}],[/%(x|W|Q?)\(/,{token:"string.$1.delim",switchTo:"@qqstring.$1.(.)"}],[/%(x|W|Q?)\[/,{token:"string.$1.delim",switchTo:"@qqstring.$1.[.]"}],[/%(x|W|Q?)\{/,{token:"string.$1.delim",switchTo:"@qqstring.$1.{.}"}],[/%(x|W|Q?)</,{token:"string.$1.delim",switchTo:"@qqstring.$1.<.>"}],[/%(x|W|Q?)(@delim)/,{token:"string.$1.delim",switchTo:"@qqstring.$1.$2.$2"}],[/%([rqwsxW]|Q?)./,{token:"invalid",next:"@pop"}],[/./,{token:"invalid",next:"@pop"}]],qstring:[[/\\$/,"string.$S2.escape"],[/\\./,"string.$S2.escape"],[/./,{cases:{"$#==$S4":{token:"string.$S2.delim",next:"@pop"},"$#==$S3":{token:"string.$S2.delim",next:"@push"},"@default":"string.$S2"}}]],qqstring:[[/#/,"string.$S2.escape","@interpolated"],{include:"@qstring"}],whitespace:[[/[ \t\r\n]+/,""],[/^\s*=begin\b/,"comment","@comment"],[/#.*$/,"comment"]],comment:[[/[^=]+/,"comment"],[/^\s*=begin\b/,"comment.invalid"],[/^\s*=end\b.*/,"comment","@pop"],[/[=]/,"comment"]]}}},7778:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>s});var i={comments:{lineComment:"--",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}]},s={defaultToken:"",tokenPostfix:".sql",ignoreCase:!0,brackets:[{open:"[",close:"]",token:"delimiter.square"},{open:"(",close:")",token:"delimiter.parenthesis"}],keywords:["ABORT","ABSOLUTE","ACTION","ADA","ADD","AFTER","ALL","ALLOCATE","ALTER","ALWAYS","ANALYZE","AND","ANY","ARE","AS","ASC","ASSERTION","AT","ATTACH","AUTHORIZATION","AUTOINCREMENT","AVG","BACKUP","BEFORE","BEGIN","BETWEEN","BIT","BIT_LENGTH","BOTH","BREAK","BROWSE","BULK","BY","CASCADE","CASCADED","CASE","CAST","CATALOG","CHAR","CHARACTER","CHARACTER_LENGTH","CHAR_LENGTH","CHECK","CHECKPOINT","CLOSE","CLUSTERED","COALESCE","COLLATE","COLLATION","COLUMN","COMMIT","COMPUTE","CONFLICT","CONNECT","CONNECTION","CONSTRAINT","CONSTRAINTS","CONTAINS","CONTAINSTABLE","CONTINUE","CONVERT","CORRESPONDING","COUNT","CREATE","CROSS","CURRENT","CURRENT_DATE","CURRENT_TIME","CURRENT_TIMESTAMP","CURRENT_USER","CURSOR","DATABASE","DATE","DAY","DBCC","DEALLOCATE","DEC","DECIMAL","DECLARE","DEFAULT","DEFERRABLE","DEFERRED","DELETE","DENY","DESC","DESCRIBE","DESCRIPTOR","DETACH","DIAGNOSTICS","DISCONNECT","DISK","DISTINCT","DISTRIBUTED","DO","DOMAIN","DOUBLE","DROP","DUMP","EACH","ELSE","END","END-EXEC","ERRLVL","ESCAPE","EXCEPT","EXCEPTION","EXCLUDE","EXCLUSIVE","EXEC","EXECUTE","EXISTS","EXIT","EXPLAIN","EXTERNAL","EXTRACT","FAIL","FALSE","FETCH","FILE","FILLFACTOR","FILTER","FIRST","FLOAT","FOLLOWING","FOR","FOREIGN","FORTRAN","FOUND","FREETEXT","FREETEXTTABLE","FROM","FULL","FUNCTION","GENERATED","GET","GLOB","GLOBAL","GO","GOTO","GRANT","GROUP","GROUPS","HAVING","HOLDLOCK","HOUR","IDENTITY","IDENTITYCOL","IDENTITY_INSERT","IF","IGNORE","IMMEDIATE","IN","INCLUDE","INDEX","INDEXED","INDICATOR","INITIALLY","INNER","INPUT","INSENSITIVE","INSERT","INSTEAD","INT","INTEGER","INTERSECT","INTERVAL","INTO","IS","ISNULL","ISOLATION","JOIN","KEY","KILL","LANGUAGE","LAST","LEADING","LEFT","LEVEL","LIKE","LIMIT","LINENO","LOAD","LOCAL","LOWER","MATCH","MATERIALIZED","MAX","MERGE","MIN","MINUTE","MODULE","MONTH","NAMES","NATIONAL","NATURAL","NCHAR","NEXT","NO","NOCHECK","NONCLUSTERED","NONE","NOT","NOTHING","NOTNULL","NULL","NULLIF","NULLS","NUMERIC","OCTET_LENGTH","OF","OFF","OFFSET","OFFSETS","ON","ONLY","OPEN","OPENDATASOURCE","OPENQUERY","OPENROWSET","OPENXML","OPTION","OR","ORDER","OTHERS","OUTER","OUTPUT","OVER","OVERLAPS","PAD","PARTIAL","PARTITION","PASCAL","PERCENT","PIVOT","PLAN","POSITION","PRAGMA","PRECEDING","PRECISION","PREPARE","PRESERVE","PRIMARY","PRINT","PRIOR","PRIVILEGES","PROC","PROCEDURE","PUBLIC","QUERY","RAISE","RAISERROR","RANGE","READ","READTEXT","REAL","RECONFIGURE","RECURSIVE","REFERENCES","REGEXP","REINDEX","RELATIVE","RELEASE","RENAME","REPLACE","REPLICATION","RESTORE","RESTRICT","RETURN","RETURNING","REVERT","REVOKE","RIGHT","ROLLBACK","ROW","ROWCOUNT","ROWGUIDCOL","ROWS","RULE","SAVE","SAVEPOINT","SCHEMA","SCROLL","SECOND","SECTION","SECURITYAUDIT","SELECT","SEMANTICKEYPHRASETABLE","SEMANTICSIMILARITYDETAILSTABLE","SEMANTICSIMILARITYTABLE","SESSION","SESSION_USER","SET","SETUSER","SHUTDOWN","SIZE","SMALLINT","SOME","SPACE","SQL","SQLCA","SQLCODE","SQLERROR","SQLSTATE","SQLWARNING","STATISTICS","SUBSTRING","SUM","SYSTEM_USER","TABLE","TABLESAMPLE","TEMP","TEMPORARY","TEXTSIZE","THEN","TIES","TIME","TIMESTAMP","TIMEZONE_HOUR","TIMEZONE_MINUTE","TO","TOP","TRAILING","TRAN","TRANSACTION","TRANSLATE","TRANSLATION","TRIGGER","TRIM","TRUE","TRUNCATE","TRY_CONVERT","TSEQUAL","UNBOUNDED","UNION","UNIQUE","UNKNOWN","UNPIVOT","UPDATE","UPDATETEXT","UPPER","USAGE","USE","USER","USING","VACUUM","VALUE","VALUES","VARCHAR","VARYING","VIEW","VIRTUAL","WAITFOR","WHEN","WHENEVER","WHERE","WHILE","WINDOW","WITH","WITHIN GROUP","WITHOUT","WORK","WRITE","WRITETEXT","YEAR","ZONE"],operators:["ALL","AND","ANY","BETWEEN","EXISTS","IN","LIKE","NOT","OR","SOME","EXCEPT","INTERSECT","UNION","APPLY","CROSS","FULL","INNER","JOIN","LEFT","OUTER","RIGHT","CONTAINS","FREETEXT","IS","NULL","PIVOT","UNPIVOT","MATCHED"],builtinFunctions:["AVG","CHECKSUM_AGG","COUNT","COUNT_BIG","GROUPING","GROUPING_ID","MAX","MIN","SUM","STDEV","STDEVP","VAR","VARP","CUME_DIST","FIRST_VALUE","LAG","LAST_VALUE","LEAD","PERCENTILE_CONT","PERCENTILE_DISC","PERCENT_RANK","COLLATE","COLLATIONPROPERTY","TERTIARY_WEIGHTS","FEDERATION_FILTERING_VALUE","CAST","CONVERT","PARSE","TRY_CAST","TRY_CONVERT","TRY_PARSE","ASYMKEY_ID","ASYMKEYPROPERTY","CERTPROPERTY","CERT_ID","CRYPT_GEN_RANDOM","DECRYPTBYASYMKEY","DECRYPTBYCERT","DECRYPTBYKEY","DECRYPTBYKEYAUTOASYMKEY","DECRYPTBYKEYAUTOCERT","DECRYPTBYPASSPHRASE","ENCRYPTBYASYMKEY","ENCRYPTBYCERT","ENCRYPTBYKEY","ENCRYPTBYPASSPHRASE","HASHBYTES","IS_OBJECTSIGNED","KEY_GUID","KEY_ID","KEY_NAME","SIGNBYASYMKEY","SIGNBYCERT","SYMKEYPROPERTY","VERIFYSIGNEDBYCERT","VERIFYSIGNEDBYASYMKEY","CURSOR_STATUS","DATALENGTH","IDENT_CURRENT","IDENT_INCR","IDENT_SEED","IDENTITY","SQL_VARIANT_PROPERTY","CURRENT_TIMESTAMP","DATEADD","DATEDIFF","DATEFROMPARTS","DATENAME","DATEPART","DATETIME2FROMPARTS","DATETIMEFROMPARTS","DATETIMEOFFSETFROMPARTS","DAY","EOMONTH","GETDATE","GETUTCDATE","ISDATE","MONTH","SMALLDATETIMEFROMPARTS","SWITCHOFFSET","SYSDATETIME","SYSDATETIMEOFFSET","SYSUTCDATETIME","TIMEFROMPARTS","TODATETIMEOFFSET","YEAR","CHOOSE","COALESCE","IIF","NULLIF","ABS","ACOS","ASIN","ATAN","ATN2","CEILING","COS","COT","DEGREES","EXP","FLOOR","LOG","LOG10","PI","POWER","RADIANS","RAND","ROUND","SIGN","SIN","SQRT","SQUARE","TAN","APP_NAME","APPLOCK_MODE","APPLOCK_TEST","ASSEMBLYPROPERTY","COL_LENGTH","COL_NAME","COLUMNPROPERTY","DATABASE_PRINCIPAL_ID","DATABASEPROPERTYEX","DB_ID","DB_NAME","FILE_ID","FILE_IDEX","FILE_NAME","FILEGROUP_ID","FILEGROUP_NAME","FILEGROUPPROPERTY","FILEPROPERTY","FULLTEXTCATALOGPROPERTY","FULLTEXTSERVICEPROPERTY","INDEX_COL","INDEXKEY_PROPERTY","INDEXPROPERTY","OBJECT_DEFINITION","OBJECT_ID","OBJECT_NAME","OBJECT_SCHEMA_NAME","OBJECTPROPERTY","OBJECTPROPERTYEX","ORIGINAL_DB_NAME","PARSENAME","SCHEMA_ID","SCHEMA_NAME","SCOPE_IDENTITY","SERVERPROPERTY","STATS_DATE","TYPE_ID","TYPE_NAME","TYPEPROPERTY","DENSE_RANK","NTILE","RANK","ROW_NUMBER","PUBLISHINGSERVERNAME","OPENDATASOURCE","OPENQUERY","OPENROWSET","OPENXML","CERTENCODED","CERTPRIVATEKEY","CURRENT_USER","HAS_DBACCESS","HAS_PERMS_BY_NAME","IS_MEMBER","IS_ROLEMEMBER","IS_SRVROLEMEMBER","LOGINPROPERTY","ORIGINAL_LOGIN","PERMISSIONS","PWDENCRYPT","PWDCOMPARE","SESSION_USER","SESSIONPROPERTY","SUSER_ID","SUSER_NAME","SUSER_SID","SUSER_SNAME","SYSTEM_USER","USER","USER_ID","USER_NAME","ASCII","CHAR","CHARINDEX","CONCAT","DIFFERENCE","FORMAT","LEFT","LEN","LOWER","LTRIM","NCHAR","PATINDEX","QUOTENAME","REPLACE","REPLICATE","REVERSE","RIGHT","RTRIM","SOUNDEX","SPACE","STR","STUFF","SUBSTRING","UNICODE","UPPER","BINARY_CHECKSUM","CHECKSUM","CONNECTIONPROPERTY","CONTEXT_INFO","CURRENT_REQUEST_ID","ERROR_LINE","ERROR_NUMBER","ERROR_MESSAGE","ERROR_PROCEDURE","ERROR_SEVERITY","ERROR_STATE","FORMATMESSAGE","GETANSINULL","GET_FILESTREAM_TRANSACTION_CONTEXT","HOST_ID","HOST_NAME","ISNULL","ISNUMERIC","MIN_ACTIVE_ROWVERSION","NEWID","NEWSEQUENTIALID","ROWCOUNT_BIG","XACT_STATE","TEXTPTR","TEXTVALID","COLUMNS_UPDATED","EVENTDATA","TRIGGER_NESTLEVEL","UPDATE","CHANGETABLE","CHANGE_TRACKING_CONTEXT","CHANGE_TRACKING_CURRENT_VERSION","CHANGE_TRACKING_IS_COLUMN_IN_MASK","CHANGE_TRACKING_MIN_VALID_VERSION","CONTAINSTABLE","FREETEXTTABLE","SEMANTICKEYPHRASETABLE","SEMANTICSIMILARITYDETAILSTABLE","SEMANTICSIMILARITYTABLE","FILETABLEROOTPATH","GETFILENAMESPACEPATH","GETPATHLOCATOR","PATHNAME","GET_TRANSMISSION_STATUS"],builtinVariables:["@@DATEFIRST","@@DBTS","@@LANGID","@@LANGUAGE","@@LOCK_TIMEOUT","@@MAX_CONNECTIONS","@@MAX_PRECISION","@@NESTLEVEL","@@OPTIONS","@@REMSERVER","@@SERVERNAME","@@SERVICENAME","@@SPID","@@TEXTSIZE","@@VERSION","@@CURSOR_ROWS","@@FETCH_STATUS","@@DATEFIRST","@@PROCID","@@ERROR","@@IDENTITY","@@ROWCOUNT","@@TRANCOUNT","@@CONNECTIONS","@@CPU_BUSY","@@IDLE","@@IO_BUSY","@@PACKET_ERRORS","@@PACK_RECEIVED","@@PACK_SENT","@@TIMETICKS","@@TOTAL_ERRORS","@@TOTAL_READ","@@TOTAL_WRITE"],pseudoColumns:["$ACTION","$IDENTITY","$ROWGUID","$PARTITION"],tokenizer:{root:[{include:"@comments"},{include:"@whitespace"},{include:"@pseudoColumns"},{include:"@numbers"},{include:"@strings"},{include:"@complexIdentifiers"},{include:"@scopes"},[/[;,.]/,"delimiter"],[/[()]/,"@brackets"],[/[\w@#$]+/,{cases:{"@operators":"operator","@builtinVariables":"predefined","@builtinFunctions":"predefined","@keywords":"keyword","@default":"identifier"}}],[/[<>=!%&+\-*/|~^]/,"operator"]],whitespace:[[/\s+/,"white"]],comments:[[/--+.*/,"comment"],[/\/\*/,{token:"comment.quote",next:"@comment"}]],comment:[[/[^*/]+/,"comment"],[/\*\//,{token:"comment.quote",next:"@pop"}],[/./,"comment"]],pseudoColumns:[[/[$][A-Za-z_][\w@#$]*/,{cases:{"@pseudoColumns":"predefined","@default":"identifier"}}]],numbers:[[/0[xX][0-9a-fA-F]*/,"number"],[/[$][+-]*\d*(\.\d*)?/,"number"],[/((\d+(\.\d*)?)|(\.\d+))([eE][\-+]?\d+)?/,"number"]],strings:[[/N'/,{token:"string",next:"@string"}],[/'/,{token:"string",next:"@string"}]],string:[[/[^']+/,"string"],[/''/,"string"],[/'/,{token:"string",next:"@pop"}]],complexIdentifiers:[[/\[/,{token:"identifier.quote",next:"@bracketedIdentifier"}],[/"/,{token:"identifier.quote",next:"@quotedIdentifier"}]],bracketedIdentifier:[[/[^\]]+/,"identifier"],[/]]/,"identifier"],[/]/,{token:"identifier.quote",next:"@pop"}]],quotedIdentifier:[[/[^"]+/,"identifier"],[/""/,"identifier"],[/"/,{token:"identifier.quote",next:"@pop"}]],scopes:[[/BEGIN\s+(DISTRIBUTED\s+)?TRAN(SACTION)?\b/i,"keyword"],[/BEGIN\s+TRY\b/i,{token:"keyword.try"}],[/END\s+TRY\b/i,{token:"keyword.try"}],[/BEGIN\s+CATCH\b/i,{token:"keyword.catch"}],[/END\s+CATCH\b/i,{token:"keyword.catch"}],[/(BEGIN|CASE)\b/i,{token:"keyword.block"}],[/END\b/i,{token:"keyword.block"}],[/WHEN\b/i,{token:"keyword.choice"}],[/THEN\b/i,{token:"keyword.choice"}]]}}},1975:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});const i='//// Lists are an ordered sequence of elements and are one of the most common\n//// data types in Gleam.\n////\n//// New elements can be added and removed from the front of a list in\n//// constant time, while adding and removing from the end requires traversing\n//// the copying the whole list, so keep this in mind when designing your\n//// programs.\n////\n//// There is a dedicated syntax for prefixing to a list:\n////\n////    let new_list = [1, 2, ..existing_list]\n////\n//// And a matching syntax for getting the first elements of a list:\n////\n////    case list {\n////      [first_element, ..rest] -> first_element\n////      _ -> "this pattern matches when the list is empty"\n////    }\n////\n\nimport gleam/int\nimport gleam/pair\nimport gleam/order.{Order}\n\n/// An error value returned by the `strict_zip` function.\n///\npub type LengthMismatch {\n  LengthMismatch\n}\n\n/// Counts the number of elements in a given list.\n///\n/// This function has to traverse the list to determine the number of elements,\n/// so it runs in linear time.\n///\n/// This function is natively implemented by the virtual machine and is highly\n/// optimised.\n///\n/// ## Examples\n///\n///    > length([])\n///    0\n///\n///    > length([1])\n///    1\n///\n///    > length([1, 2])\n///    2\n///\npub fn length(of list: List(a)) -> Int {\n  do_length(list)\n}\n\nif erlang {\n  external fn do_length(List(a)) -> Int =\n    "erlang" "length"\n}\n\nif javascript {\n  fn do_length(list: List(a)) -> Int {\n    do_length_acc(list, 0)\n  }\n\n  fn do_length_acc(list: List(a), count: Int) -> Int {\n    case list {\n      [_, ..list] -> do_length_acc(list, count + 1)\n      _ -> count\n    }\n  }\n}\n\n/// Creates a new list from a given list containing the same elements but in the\n/// opposite order.\n///\n/// This function has to traverse the list to create the new reversed list, so\n/// it runs in linear time.\n///\n/// This function is natively implemented by the virtual machine and is highly\n/// optimised.\n///\n/// ## Examples\n///\n///    > reverse([])\n///    []\n///\n///    > reverse([1])\n///    [1]\n///\n///    > reverse([1, 2])\n///    [2, 1]\n///\npub fn reverse(xs: List(a)) -> List(a) {\n  do_reverse(xs)\n}\n\nif erlang {\n  external fn do_reverse(List(a)) -> List(a) =\n    "lists" "reverse"\n}\n\nif javascript {\n  fn do_reverse(list) {\n    do_reverse_acc(list, [])\n  }\n\n  fn do_reverse_acc(remaining, accumulator) {\n    case remaining {\n      [] -> accumulator\n      [item, ..rest] -> do_reverse_acc(rest, [item, ..accumulator])\n    }\n  }\n}\n\n/// Determines whether or not the list is empty.\n///\n/// This function runs in constant time.\n///\n/// ## Examples\n///\n///    > is_empty([])\n///    True\n///\n///    > is_empty([1])\n///    False\n///\n///    > is_empty([1, 1])\n///    False\n///\npub fn is_empty(list: List(a)) -> Bool {\n  list == []\n}\n\n/// Determines whether or not a given element exists within a given list.\n///\n/// This function traverses the list to find the element, so it runs in linear\n/// time.\n///\n/// ## Examples\n///\n///    > [] |> contains(any: 0)\n///    False\n///\n///    > [0] |> contains(any: 0)\n///    True\n///\n///    > [1] |> contains(any: 0)\n///    False\n///\n///    > [1, 1] |> contains(any: 0)\n///    False\n///\n///    > [1, 0] |> contains(any: 0)\n///    True\n///\npub fn contains(list: List(a), any elem: a) -> Bool {\n  case list {\n    [] -> False\n    [head, ..rest] -> head == elem || contains(rest, elem)\n  }\n}\n\n/// Gets the first element from the start of the list, if there is one.\n///\n/// ## Examples\n///\n///    > first([])\n///    Error(Nil)\n///\n///    > first([0])\n///    Ok(0)\n///\n///    > first([1, 2])\n///    Ok(1)\n///\npub fn first(list: List(a)) -> Result(a, Nil) {\n  case list {\n    [] -> Error(Nil)\n    [x, ..] -> Ok(x)\n  }\n}\n\n/// Returns the list minus the first element. If the list is empty, `Error(Nil)` is\n/// returned.\n///\n/// This function runs in constant time and does not make a copy of the list.\n///\n/// ## Examples\n///\n///    > rest([])\n///    Error(Nil)\n///\n///    > rest([0])\n///    Ok([])\n///\n///    > rest([1, 2])\n///    Ok([2])\n///\npub fn rest(list: List(a)) -> Result(List(a), Nil) {\n  case list {\n    [] -> Error(Nil)\n    [_, ..xs] -> Ok(xs)\n  }\n}\n\nfn do_filter(list: List(a), fun: fn(a) -> Bool, acc: List(a)) -> List(a) {\n  case list {\n    [] -> reverse(acc)\n    [x, ..xs] -> {\n      let new_acc = case fun(x) {\n        True -> [x, ..acc]\n        False -> acc\n      }\n      do_filter(xs, fun, new_acc)\n    }\n  }\n}\n\n/// Returns a new list containing only the elements from the first list for\n/// which the given functions returns `True`.\n///\n/// ## Examples\n///\n///    > filter([2, 4, 6, 1], fn(x) { x > 2 })\n///    [4, 6]\n///\n///    > filter([2, 4, 6, 1], fn(x) { x > 6 })\n///    []\n///\npub fn filter(list: List(a), for predicate: fn(a) -> Bool) -> List(a) {\n  do_filter(list, predicate, [])\n}\n\nfn do_filter_map(\n  list: List(a),\n  fun: fn(a) -> Result(b, e),\n  acc: List(b),\n) -> List(b) {\n  case list {\n    [] -> reverse(acc)\n    [x, ..xs] -> {\n      let new_acc = case fun(x) {\n        Ok(x) -> [x, ..acc]\n        Error(_) -> acc\n      }\n      do_filter_map(xs, fun, new_acc)\n    }\n  }\n}\n\n/// Returns a new list containing only the elements from the first list for\n/// which the given functions returns `Ok(_)`.\n///\n/// ## Examples\n///\n///    > filter_map([2, 4, 6, 1], Error)\n///    []\n///\n///    > filter_map([2, 4, 6, 1], fn(x) { Ok(x + 1) })\n///    [3, 5, 7, 2]\n///\npub fn filter_map(list: List(a), with fun: fn(a) -> Result(b, e)) -> List(b) {\n  do_filter_map(list, fun, [])\n}\n\nfn do_map(list: List(a), fun: fn(a) -> b, acc: List(b)) -> List(b) {\n  case list {\n    [] -> reverse(acc)\n    [x, ..xs] -> do_map(xs, fun, [fun(x), ..acc])\n  }\n}\n\n/// Returns a new list containing only the elements of the first list after the\n/// function has been applied to each one.\n///\n/// ## Examples\n///\n///    > map([2, 4, 6], fn(x) { x * 2 })\n///    [4, 8, 12]\n///\npub fn map(list: List(a), with fun: fn(a) -> b) -> List(b) {\n  do_map(list, fun, [])\n}\n\n/// Similar to `map` but also lets you pass around an accumulated value.\n///\n/// ## Examples\n///\n/// ```\n/// > map_fold(\n///     over: [1, 2, 3],\n///     from: 100,\n///     with: fn(memo, i) { #(i * 2, memo + i) }\n///  )\n///  #([2, 4, 6], 106)\n/// ```\n///\npub fn map_fold(\n  over list: List(a),\n  from acc: acc,\n  with fun: fn(acc, a) -> #(acc, b),\n) -> #(acc, List(b)) {\n  fold(\n    over: list,\n    from: #(acc, []),\n    with: fn(acc, item) {\n      let #(current_acc, items) = acc\n      let #(next_acc, next_item) = fun(current_acc, item)\n      #(next_acc, [next_item, ..items])\n    },\n  )\n  |> pair.map_second(reverse)\n}\n\nfn do_index_map(\n  list: List(a),\n  fun: fn(Int, a) -> b,\n  index: Int,\n  acc: List(b),\n) -> List(b) {\n  case list {\n    [] -> reverse(acc)\n    [x, ..xs] -> {\n      let acc = [fun(index, x), ..acc]\n      do_index_map(xs, fun, index + 1, acc)\n    }\n  }\n}\n\n/// Returns a new list containing only the elements of the first list after the\n/// function has been applied to each one and their index.\n///\n/// The index starts at 0, so the first element is 0, the second is 1, and so\n/// on.\n///\n/// ## Examples\n///\n///    > index_map(["a", "b"], fn(i, x) { #(i, x) })\n///    [#(0, "a"), #(1, "b")]\n///\npub fn index_map(list: List(a), with fun: fn(Int, a) -> b) -> List(b) {\n  do_index_map(list, fun, 0, [])\n}\n\nfn do_try_map(\n  list: List(a),\n  fun: fn(a) -> Result(b, e),\n  acc: List(b),\n) -> Result(List(b), e) {\n  case list {\n    [] -> Ok(reverse(acc))\n    [x, ..xs] ->\n      case fun(x) {\n        Ok(y) -> do_try_map(xs, fun, [y, ..acc])\n        Error(error) -> Error(error)\n      }\n  }\n}\n\n/// Takes a function that returns a `Result` and applies it to each element in a\n/// given list in turn.\n///\n/// If the function returns `Ok(new_value)` for all elements in the list then a\n/// list of the new values is returned.\n///\n/// If the function returns `Error(reason)` for any of the elements then it is\n/// returned immediately. None of the elements in the list are processed after\n/// one returns an `Error`.\n///\n/// ## Examples\n///\n///    > try_map([1, 2, 3], fn(x) { Ok(x + 2) })\n///    Ok([3, 4, 5])\n///\n///    > try_map([1, 2, 3], fn(_) { Error(0) })\n///    Error(0)\n///\n///    > try_map([[1], [2, 3]], head)\n///    Ok([1, 2])\n///\n///    > try_map([[1], [], [2]], head)\n///    Error(Nil)\n///\npub fn try_map(\n  over list: List(a),\n  with fun: fn(a) -> Result(b, e),\n) -> Result(List(b), e) {\n  do_try_map(list, fun, [])\n}\n\n/// Returns a list that is the given list with up to the given number of\n/// elements removed from the front of the list.\n///\n/// If the element has less than the number of elements an empty list is\n/// returned.\n///\n/// This function runs in linear time but does not copy the list.\n///\n/// ## Examples\n///\n///    > drop([1, 2, 3, 4], 2)\n///    [3, 4]\n///\n///    > drop([1, 2, 3, 4], 9)\n///    []\n///\npub fn drop(from list: List(a), up_to n: Int) -> List(a) {\n  case n <= 0 {\n    True -> list\n    False ->\n      case list {\n        [] -> []\n        [_, ..xs] -> drop(xs, n - 1)\n      }\n  }\n}\n\nfn do_take(list: List(a), n: Int, acc: List(a)) -> List(a) {\n  case n <= 0 {\n    True -> reverse(acc)\n    False ->\n      case list {\n        [] -> reverse(acc)\n        [x, ..xs] -> do_take(xs, n - 1, [x, ..acc])\n      }\n  }\n}\n\n/// Returns a list containing the first given number of elements from the given\n/// list.\n///\n/// If the element has less than the number of elements then the full list is\n/// returned.\n///\n/// This function runs in linear time but does not copy the list.\n///\n/// ## Examples\n///\n///    > take([1, 2, 3, 4], 2)\n///    [1, 2]\n///\n///    > take([1, 2, 3, 4], 9)\n///    [1, 2, 3, 4]\n///\npub fn take(from list: List(a), up_to n: Int) -> List(a) {\n  do_take(list, n, [])\n}\n\n/// Returns a new empty list.\n///\n/// ## Examples\n///\n///    > new()\n///    []\n///\npub fn new() -> List(a) {\n  []\n}\n\n/// Joins one list onto the end of another.\n///\n/// This function runs in linear time, and it traverses and copies the first\n/// list.\n///\n/// ## Examples\n///\n///    > append([1, 2], [3])\n///    [1, 2, 3]\n///\npub fn append(first: List(a), second: List(a)) -> List(a) {\n  do_append(first, second)\n}\n\nif erlang {\n  external fn do_append(List(a), List(a)) -> List(a) =\n    "lists" "append"\n}\n\nif javascript {\n  fn do_append(first: List(a), second: List(a)) -> List(a) {\n    do_append_acc(reverse(first), second)\n  }\n\n  fn do_append_acc(first: List(a), second: List(a)) -> List(a) {\n    case first {\n      [] -> second\n      [item, ..rest] -> do_append_acc(rest, [item, ..second])\n    }\n  }\n}\n\nfn do_flatten(lists: List(List(a)), acc: List(a)) -> List(a) {\n  case lists {\n    [] -> acc\n    [l, ..rest] -> do_flatten(rest, append(acc, l))\n  }\n}\n\n/// Flattens a list of lists into a single list.\n///\n/// This function runs in linear time, and it traverses and copies all the\n/// inner lists.\n///\n/// ## Examples\n///\n///    > flatten([[1], [2, 3], []])\n///    [1, 2, 3]\n///\npub fn flatten(lists: List(List(a))) -> List(a) {\n  do_flatten(lists, [])\n}\n\n/// Maps the list with the given function and then flattens the result.\n///\n/// ## Examples\n///\n/// ```\n/// > flat_map([2, 4, 6], fn(x) { [x, x + 1] })\n/// [2, 3, 4, 5, 6, 7]\n/// ```\n///\npub fn flat_map(over list: List(a), with fun: fn(a) -> List(b)) -> List(b) {\n  map(list, fun)\n  |> flatten\n}\n\n/// Reduces a list of elements into a single value by calling a given function\n/// on each element, going from left to right.\n///\n/// `fold([1, 2, 3], 0, add)` is the equivalent of `add(add(add(0, 1), 2), 3)`.\n///\n/// This function runs in linear time.\n///\npub fn fold(\n  over list: List(a),\n  from initial: acc,\n  with fun: fn(acc, a) -> acc,\n) -> acc {\n  case list {\n    [] -> initial\n    [x, ..rest] -> fold(rest, fun(initial, x), fun)\n  }\n}\n\n/// Reduces a list of elements into a single value by calling a given function\n/// on each element, going from right to left.\n///\n/// `fold_right([1, 2, 3], 0, add)` is the equivalent of\n/// `add(add(add(0, 3), 2), 1)`.\n///\n/// This function runs in linear time.\n///\n/// Unlike `fold` this function is not tail recursive. Where possible use\n/// `fold` instead as it will use less memory.\n///\npub fn fold_right(\n  over list: List(a),\n  from initial: acc,\n  with fun: fn(acc, a) -> acc,\n) -> acc {\n  case list {\n    [] -> initial\n    [x, ..rest] -> fun(fold_right(rest, initial, fun), x)\n  }\n}\n\nfn do_index_fold(\n  over: List(a),\n  acc: acc,\n  with: fn(acc, a, Int) -> acc,\n  index: Int,\n) -> acc {\n  case over {\n    [] -> acc\n    [first, ..rest] ->\n      do_index_fold(rest, with(acc, first, index), with, index + 1)\n  }\n}\n\n/// Like fold but the folding function also receives the index of the current element.\n///\n/// ## Examples\n///\n/// ```\n/// ["a", "b", "c"]\n/// |> list.index_fold([], fn(acc, item, index) { ... })\n/// ```\n///\npub fn index_fold(\n  over over: List(a),\n  from initial: acc,\n  with fun: fn(acc, a, Int) -> acc,\n) -> acc {\n  do_index_fold(over, initial, fun, 0)\n}\n\n/// A variant of fold that might fail.\n///\n/// The folding function should return `Result(accumulator, error)`.\n/// If the returned value is `Ok(accumulator)` try_fold will try the next value in the list.\n/// If the returned value is `Error(error)` try_fold will stop and return that error.\n///\n/// ## Examples\n///\n/// ```\n/// [1, 2, 3, 4]\n/// |> try_fold(0, fn(acc, i) {\n///   case i < 3 {\n///     True -> Ok(acc + i)\n///     False -> Error(Nil)\n///   }\n/// })\n/// ```\n///\npub fn try_fold(\n  over collection: List(a),\n  from accumulator: acc,\n  with fun: fn(acc, a) -> Result(acc, e),\n) -> Result(acc, e) {\n  case collection {\n    [] -> Ok(accumulator)\n    [first, ..rest] -> {\n      try accumulator = fun(accumulator, first)\n      try_fold(rest, accumulator, fun)\n    }\n  }\n}\n\npub type ContinueOrStop(a) {\n  Continue(a)\n  Stop(a)\n}\n\n/// A variant of fold that allows to stop folding earlier.\n///\n/// The folding function should return `ContinueOrStop(accumulator)`.\n/// If the returned value is `Continue(accumulator)` fold_until will try the next value in the list.\n/// If the returned value is `Stop(accumulator)` fold_until will stop and return that accumulator.\n///\n/// ## Examples\n///\n/// ```\n/// [1, 2, 3, 4]\n/// |> fold_until(0, fn(acc, i) {\n///   case i < 3 {\n///     True -> Continue(acc + i)\n///     False -> Stop(acc)\n///   }\n/// })\n/// ```\n///\npub fn fold_until(\n  over collection: List(a),\n  from accumulator: acc,\n  with fun: fn(acc, a) -> ContinueOrStop(acc),\n) -> acc {\n  case collection {\n    [] -> accumulator\n    [first, ..rest] ->\n      case fun(accumulator, first) {\n        Continue(next_accumulator) -> fold_until(rest, next_accumulator, fun)\n        Stop(b) -> b\n      }\n  }\n}\n\n/// Finds the first element in a given list for which the given function returns\n/// `True`.\n///\n/// Returns `Error(Nil)` if no such element is found.\n///\n/// ## Examples\n///\n///    > find([1, 2, 3], fn(x) { x > 2 })\n///    Ok(3)\n///\n///    > find([1, 2, 3], fn(x) { x > 4 })\n///    Error(Nil)\n///\n///    > find([], fn(_) { True })\n///    Error(Nil)\n///\npub fn find(\n  in haystack: List(a),\n  one_that is_desired: fn(a) -> Bool,\n) -> Result(a, Nil) {\n  case haystack {\n    [] -> Error(Nil)\n    [x, ..rest] ->\n      case is_desired(x) {\n        True -> Ok(x)\n        _ -> find(in: rest, one_that: is_desired)\n      }\n  }\n}\n\n/// Finds the first element in a given list for which the given function returns\n/// `Ok(new_value)`, then returns the wrapped `new_value`.\n///\n/// Returns `Error(Nil)` if no such element is found.\n///\n/// ## Examples\n///\n///    > find_map([[], [2], [3]], head)\n///    Ok(2)\n///\n///    > find_map([[], []], head)\n///    Error(Nil)\n///\n///    > find_map([], head)\n///    Error(Nil)\n///\npub fn find_map(\n  in haystack: List(a),\n  with fun: fn(a) -> Result(b, c),\n) -> Result(b, Nil) {\n  case haystack {\n    [] -> Error(Nil)\n    [x, ..rest] ->\n      case fun(x) {\n        Ok(x) -> Ok(x)\n        _ -> find_map(in: rest, with: fun)\n      }\n  }\n}\n\n/// Returns `True` if the given function returns `True` for all the elements in\n/// the given list. If the function returns `False` for any of the elements it\n/// immediately returns `False` without checking the rest of the list.\n///\n/// ## Examples\n///\n///    > all([], fn(x) { x > 3 })\n///    True\n///\n///    > all([4, 5], fn(x) { x > 3 })\n///    True\n///\n///    > all([4, 3], fn(x) { x > 3 })\n///    False\n///\npub fn all(in list: List(a), satisfying predicate: fn(a) -> Bool) -> Bool {\n  case list {\n    [] -> True\n    [x, ..rest] -> predicate(x) && all(rest, predicate)\n  }\n}\n\n/// Returns `True` if the given function returns `True` for any the elements in\n/// the given list. If the function returns `True` for any of the elements it\n/// immediately returns `True` without checking the rest of the list.\n///\n/// ## Examples\n///\n///    > any([], fn(x) { x > 3 })\n///    False\n///\n///    > any([4, 5], fn(x) { x > 3 })\n///    True\n///\n///    > any([4, 3], fn(x) { x > 4 })\n///    False\n///\n///    > any([3, 4], fn(x) { x > 3 })\n///    True\n///\npub fn any(in list: List(a), satisfying predicate: fn(a) -> Bool) -> Bool {\n  case list {\n    [] -> False\n    [x, ..rest] -> predicate(x) || any(rest, predicate)\n  }\n}\n\nfn do_zip(xs: List(a), ys: List(b), acc: List(#(a, b))) -> List(#(a, b)) {\n  case xs, ys {\n    [x, ..xs], [y, ..ys] -> do_zip(xs, ys, [#(x, y), ..acc])\n    _, _ -> reverse(acc)\n  }\n}\n\n/// Takes two lists and returns a single list of 2-element tuples.\n///\n/// If one of the lists is longer than the other, the remaining elements from\n/// the longer list are not used.\n///\n/// ## Examples\n///\n///    > zip([], [])\n///    []\n///\n///    > zip([1, 2], [3])\n///    [#(1, 3)]\n///\n///    > zip([1], [3, 4])\n///    [#(1, 3)]\n///\n///    > zip([1, 2], [3, 4])\n///    [#(1, 3), #(2, 4)]\n///\npub fn zip(xs: List(a), ys: List(b)) -> List(#(a, b)) {\n  do_zip(xs, ys, [])\n}\n\n/// Takes two lists and returns a single list of 2-element tuples.\n///\n/// If one of the lists is longer than the other, an `Error` is returned.\n///\n/// ## Examples\n///\n///    > strict_zip([], [])\n///    Ok([])\n///\n///    > strict_zip([1, 2], [3])\n///    Error(LengthMismatch)\n///\n///    > strict_zip([1], [3, 4])\n///    Error(LengthMismatch)\n///\n///    > strict_zip([1, 2], [3, 4])\n///    Ok([#(1, 3), #(2, 4)])\n///\npub fn strict_zip(\n  l1: List(a),\n  l2: List(b),\n) -> Result(List(#(a, b)), LengthMismatch) {\n  case length(of: l1) == length(of: l2) {\n    True -> Ok(zip(l1, l2))\n    False -> Error(LengthMismatch)\n  }\n}\n\nfn do_unzip(input, xs, ys) {\n  case input {\n    [] -> #(reverse(xs), reverse(ys))\n    [#(x, y), ..rest] -> do_unzip(rest, [x, ..xs], [y, ..ys])\n  }\n}\n\n/// Takes a single list of 2-element tuples and returns two lists.\n///\n/// ## Examples\n///\n///    > unzip([#(1, 2), #(3, 4)])\n///    #([1, 3], [2, 4])\n///\n///    > unzip([])\n///    #([], [])\n///\npub fn unzip(input: List(#(a, b))) -> #(List(a), List(b)) {\n  do_unzip(input, [], [])\n}\n\nfn do_intersperse(list: List(a), separator: a, acc: List(a)) -> List(a) {\n  case list {\n    [] -> reverse(acc)\n    [x, ..rest] -> do_intersperse(rest, separator, [x, separator, ..acc])\n  }\n}\n\n/// Inserts a given value between each existing element in a given list.\n///\n/// This function runs in linear time and copies the list.\n///\n/// ## Examples\n///\n///    > intersperse([1, 1, 1], 2)\n///    [1, 2, 1, 2, 1]\n///\n///    > intersperse([], 2)\n///    []\n///\npub fn intersperse(list: List(a), with elem: a) -> List(a) {\n  case list {\n    [] | [_] -> list\n    [x, ..rest] -> do_intersperse(rest, elem, [x])\n  }\n}\n\n/// Returns the element in the Nth position in the list, with 0 being the first\n/// position.\n///\n/// `Error(Nil)` is returned if the list is not long enough for the given index.\n///\n/// For any `index` less than 0 this function behaves as if it was set to 0.\n///\n/// ## Examples\n///\n///    > at([1, 2, 3], 1)\n///    Ok(2)\n///\n///    > at([1, 2, 3], 5)\n///    Error(Nil)\n///\npub fn at(in list: List(a), get index: Int) -> Result(a, Nil) {\n  list\n  |> drop(index)\n  |> first\n}\n\n/// Removes any duplicate elements from a given list.\n///\n/// This function returns in loglinear time.\n///\n/// ## Examples\n///\n///    > unique([1, 1, 1, 4, 7, 3, 3, 4])\n///    [1, 4, 7, 3]\n///\npub fn unique(list: List(a)) -> List(a) {\n  case list {\n    [] -> []\n    [x, ..rest] -> [x, ..unique(filter(rest, fn(y) { y != x }))]\n  }\n}\n\nfn merge_sort(a: List(a), b: List(a), compare: fn(a, a) -> Order) -> List(a) {\n  case a, b {\n    [], _ -> b\n    _, [] -> a\n    [ax, ..ar], [bx, ..br] ->\n      case compare(ax, bx) {\n        order.Lt -> [ax, ..merge_sort(ar, b, compare)]\n        _ -> [bx, ..merge_sort(a, br, compare)]\n      }\n  }\n}\n\nfn do_sort(\n  list: List(a),\n  compare: fn(a, a) -> Order,\n  list_length: Int,\n) -> List(a) {\n  case list_length < 2 {\n    True -> list\n    False -> {\n      let split_length = list_length / 2\n      let a_list = take(list, split_length)\n      let b_list = drop(list, split_length)\n      merge_sort(\n        do_sort(a_list, compare, split_length),\n        do_sort(b_list, compare, list_length - split_length),\n        compare,\n      )\n    }\n  }\n}\n\n/// Sorts from smallest to largest based upon the ordering specified by a given\n/// function.\n///\n/// ## Examples\n///\n///    > import gleam/int\n///    > list.sort([4, 3, 6, 5, 4, 1, 2], by: int.compare)\n///    [1, 2, 3, 4, 4, 5, 6]\n///\npub fn sort(list: List(a), by compare: fn(a, a) -> Order) -> List(a) {\n  do_sort(list, compare, length(list))\n}\n\n/// Creates a list of ints ranging from a given start and finish.\n///\n/// ## Examples\n///\n///    > range(0, 0)\n///    []\n///\n///    > range(0, 5)\n///    [0, 1, 2, 3, 4]\n///\n///    > range(1, -5)\n///    [1, 0, -1, -2, -3, -4]\n///\npub fn range(from start: Int, to stop: Int) -> List(Int) {\n  case int.compare(start, stop) {\n    order.Eq -> []\n    order.Gt -> [start, ..range(start - 1, stop)]\n    order.Lt -> [start, ..range(start + 1, stop)]\n  }\n}\n\nfn do_repeat(a: a, times: Int, acc: List(a)) -> List(a) {\n  case times <= 0 {\n    True -> acc\n    False -> do_repeat(a, times - 1, [a, ..acc])\n  }\n}\n\n/// Builds a list of a given value a given number of times.\n///\n/// ## Examples\n///\n///    > repeat("a", times: 0)\n///    []\n///\n///    > repeat("a", times: 5)\n///    ["a", "a", "a", "a", "a"]\n///\npub fn repeat(item a: a, times times: Int) -> List(a) {\n  do_repeat(a, times, [])\n}\n\nfn do_split(list: List(a), n: Int, taken: List(a)) -> #(List(a), List(a)) {\n  case n <= 0 {\n    True -> #(reverse(taken), list)\n    False ->\n      case list {\n        [] -> #(reverse(taken), [])\n        [x, ..xs] -> do_split(xs, n - 1, [x, ..taken])\n      }\n  }\n}\n\n/// Splits a list in two before the given index.\n///\n/// If the list is not long enough to have the given index the before list will\n/// be the input list, and the after list will be empty.\n///\n/// ## Examples\n///\n///    > split([6, 7, 8, 9], 0)\n///    #([], [6, 7, 8, 9])\n///\n///    > split([6, 7, 8, 9], 2)\n///    #([6, 7], [8, 9])\n///\n///    > split([6, 7, 8, 9], 4)\n///    #([6, 7, 8, 9], [])\n///\npub fn split(list list: List(a), at index: Int) -> #(List(a), List(a)) {\n  do_split(list, index, [])\n}\n\nfn do_split_while(\n  list: List(a),\n  f: fn(a) -> Bool,\n  acc: List(a),\n) -> #(List(a), List(a)) {\n  case list {\n    [] -> #(reverse(acc), [])\n    [x, ..xs] ->\n      case f(x) {\n        False -> #(reverse(acc), list)\n        _ -> do_split_while(xs, f, [x, ..acc])\n      }\n  }\n}\n\n/// Splits a list in two before the first element that a given function returns\n/// `False` for.\n///\n/// If the function returns `True` for all elements the first list will be the\n/// input list, and the second list will be empty.\n///\n/// ## Examples\n///\n///    > split_while([1, 2, 3, 4, 5], fn(x) { x <= 3 })\n///    #([1, 2, 3], [4, 5])\n///\n///    > split_while([1, 2, 3, 4, 5], fn(x) { x <= 5 })\n///    #([1, 2, 3, 4, 5], [])\n///\npub fn split_while(\n  list list: List(a),\n  satisfying predicate: fn(a) -> Bool,\n) -> #(List(a), List(a)) {\n  do_split_while(list, predicate, [])\n}\n\n/// Given a list of 2-element tuples, finds the first tuple that has a given\n/// key as the first element and returns the second element.\n///\n/// If no tuple is found with the given key then `Error(Nil)` is returned.\n///\n/// This function may be useful for interacting with Erlang code where lists of\n/// tuples are common.\n///\n/// ## Examples\n///\n///    > key_find([#("a", 0), #("b", 1)], "a")\n///    Ok(0)\n///\n///    > key_find([#("a", 0), #("b", 1)], "b")\n///    Ok(1)\n///\n///    > key_find([#("a", 0), #("b", 1)], "c")\n///    Error(Nil)\n///\npub fn key_find(\n  in keyword_list: List(#(k, v)),\n  find desired_key: k,\n) -> Result(v, Nil) {\n  find_map(\n    keyword_list,\n    fn(keyword) {\n      let #(key, value) = keyword\n      case key == desired_key {\n        True -> Ok(value)\n        False -> Error(Nil)\n      }\n    },\n  )\n}\n\nfn do_pop(haystack, predicate, checked) {\n  case haystack {\n    [] -> Error(Nil)\n    [x, ..rest] ->\n      case predicate(x) {\n        True -> Ok(#(x, append(reverse(checked), rest)))\n        False -> do_pop(rest, predicate, [x, ..checked])\n      }\n  }\n}\n\n/// Removes the first element in a given list for which the predicate funtion returns `True`.\n///\n/// Returns `Error(Nil)` if no such element is found.\n///\n/// ## Examples\n///\n///    > pop([1, 2, 3], fn(x) { x > 2 })\n///    Ok(#(3, [1, 2]))\n///\n///    > pop([1, 2, 3], fn(x) { x > 4 })\n///    Error(Nil)\n///\n///    > pop([], fn(_) { True })\n///    Error(Nil)\n///\npub fn pop(\n  in haystack: List(a),\n  one_that is_desired: fn(a) -> Bool,\n) -> Result(#(a, List(a)), Nil) {\n  do_pop(haystack, is_desired, [])\n}\n\nfn do_pop_map(haystack, mapper, checked) {\n  case haystack {\n    [] -> Error(Nil)\n    [x, ..rest] ->\n      case mapper(x) {\n        Ok(y) -> Ok(#(y, append(reverse(checked), rest)))\n        Error(_) -> do_pop_map(rest, mapper, [x, ..checked])\n      }\n  }\n}\n\n/// Removes the first element in a given list for which the given function returns\n/// `Ok(new_value)`, then returns the wrapped `new_value` as well as list with the value removed.\n///\n/// Returns `Error(Nil)` if no such element is found.\n///\n/// ## Examples\n///\n///    > pop_map([[], [2], [3]], head)\n///    Ok(#(2, [[], [3]]))\n///\n///    > pop_map([[], []], head)\n///    Error(Nil)\n///\n///    > pop_map([], head)\n///    Error(Nil)\n///\npub fn pop_map(\n  in haystack: List(a),\n  one_that is_desired: fn(a) -> Result(b, c),\n) -> Result(#(b, List(a)), Nil) {\n  do_pop_map(haystack, is_desired, [])\n}\n\n/// Given a list of 2-element tuples, finds the first tuple that has a given\n/// key as the first element. This function will return the second element\n/// of the found tuple and list with tuple removed.\n///\n/// If no tuple is found with the given key then `Error(Nil)` is returned.\n///\n/// ## Examples\n///\n///    > key_pop([#("a", 0), #("b", 1)], "a")\n///    Ok(#(0, [#("b", 1)]))\n///\n///    > key_pop([#("a", 0), #("b", 1)], "b")\n///    Ok(#(1, [#("a", 0)]))\n///\n///    > key_pop([#("a", 0), #("b", 1)], "c")\n///    Error(Nil)\n///\npub fn key_pop(\n  haystack: List(#(k, v)),\n  key: k,\n) -> Result(#(v, List(#(k, v))), Nil) {\n  pop_map(\n    haystack,\n    fn(entry) {\n      let #(k, v) = entry\n      case k {\n        k if k == key -> Ok(v)\n        _ -> Error(Nil)\n      }\n    },\n  )\n}\n\n/// Given a list of 2-element tuples, inserts a key and value into the list.\n///\n/// If there was already a tuple with the key then it is replaced, otherwise it\n/// is added to the end of the list.\n///\n///\n/// ## Examples\n///\n///    > key_set([#(5, 0), #(4, 1)], 4, 100)\n///    [#(5, 0), #(4, 100)]\n///\n///    > key_set([#(5, 0), #(4, 1)], 1, 100)\n///    [#(5, 0), #(4, 1), #(1, 100)]\n///\npub fn key_set(list: List(#(a, b)), key: a, value: b) -> List(#(a, b)) {\n  case list {\n    [] -> [#(key, value)]\n    [#(k, _), ..rest] if k == key -> [#(key, value), ..rest]\n    [first, ..rest] -> [first, ..key_set(rest, key, value)]\n  }\n}\n\n/// Calls a function for each element in a list, discarding the results.\n///\npub fn each(list: List(a), f: fn(a) -> b) -> Nil {\n  case list {\n    [] -> Nil\n    [x, ..xs] -> {\n      f(x)\n      each(xs, f)\n    }\n  }\n}\n\nfn do_partition(list, categorise, trues, falses) {\n  case list {\n    [] -> #(reverse(trues), reverse(falses))\n    [x, ..xs] ->\n      case categorise(x) {\n        True -> do_partition(xs, categorise, [x, ..trues], falses)\n        False -> do_partition(xs, categorise, trues, [x, ..falses])\n      }\n  }\n}\n\npub fn partition(\n  list: List(a),\n  with categorise: fn(a) -> Bool,\n) -> #(List(a), List(a)) {\n  do_partition(list, categorise, [], [])\n}\n\n/// Returns all the permutations of a list.\n/// All values must be unique.\n///\n/// ## Examples\n///\n///    > permutations([1, 2])\n///    [[1, 2], [2, 1]]\n///\npub fn permutations(l: List(a)) -> List(List(a)) {\n  case l {\n    [] -> [[]]\n    _ ->\n      map(\n        l,\n        fn(x) {\n          filter(l, fn(y) { y != x })\n          |> permutations\n          |> map(append([x], _))\n        },\n      )\n      |> flatten\n  }\n}\n\nfn do_window(acc: List(List(a)), l: List(a), n: Int) -> List(List(a)) {\n  let window = take(l, n)\n\n  case length(window) == n {\n    True -> do_window([window, ..acc], drop(l, 1), n)\n    False -> acc\n  }\n}\n\n/// Returns a list of sliding windows.\n///\n/// ## Examples\n///\n/// ```\n/// > window([1,2,3,4,5], 3)\n/// [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\n///\n/// > window([1, 2], 4)\n/// []\n/// ```\n///\npub fn window(l: List(a), by n: Int) -> List(List(a)) {\n  do_window([], l, n)\n  |> reverse\n}\n\n/// Returns a list of tuples containing two contiguous elements.\n///\n/// ## Examples\n///\n/// ```\n/// > window_by_2([1,2,3,4])\n/// [#(1, 2), #(2, 3), #(3, 4)]\n///\n/// > window_by_2([1])\n/// []\n/// ```\n///\npub fn window_by_2(l: List(a)) -> List(#(a, a)) {\n  zip(l, drop(l, 1))\n}\n\n/// Drops the first elements in a given list for which the predicate funtion returns `True`.\n///\n/// ## Examples\n///\n///    > drop_while([1, 2, 3, 4], fn (x) { x < 3 })\n///    [3, 4]\n///\npub fn drop_while(\n  in list: List(a),\n  satisfying predicate: fn(a) -> Bool,\n) -> List(a) {\n  case list {\n    [] -> []\n    [x, ..xs] ->\n      case predicate(x) {\n        True -> drop_while(xs, predicate)\n        False -> [x, ..xs]\n      }\n  }\n}\n\nfn do_take_while(\n  list: List(a),\n  predicate: fn(a) -> Bool,\n  acc: List(a),\n) -> List(a) {\n  case list {\n    [] -> reverse(acc)\n    [head, ..tail] ->\n      case predicate(head) {\n        True -> do_take_while(tail, predicate, [head, ..acc])\n        False -> reverse(acc)\n      }\n  }\n}\n\n/// Takes the first elements in a given list for which the predicate funtion returns `True`.\n///\n/// ## Examples\n///\n///    > take_while([1, 2, 3, 2, 4], fn (x) { x < 3 })\n///    [1, 2]\n///\npub fn take_while(\n  in list: List(a),\n  satisfying predicate: fn(a) -> Bool,\n) -> List(a) {\n  do_take_while(list, predicate, [])\n}\n\nfn do_chunk(\n  list: List(a),\n  f: fn(a) -> key,\n  previous_key: key,\n  current_chunk: List(a),\n  acc: List(List(a)),\n) -> List(List(a)) {\n  case list {\n    [head, ..tail] -> {\n      let key = f(head)\n      case key == previous_key {\n        False -> {\n          let new_acc = [reverse(current_chunk), ..acc]\n          do_chunk(tail, f, key, [head], new_acc)\n        }\n        _true -> do_chunk(tail, f, key, [head, ..current_chunk], acc)\n      }\n    }\n    _empty -> reverse([reverse(current_chunk), ..acc])\n  }\n}\n\n/// Returns a list of chunks in which\n/// the result of calling `f` on each element is the same.\n///\n/// ## Examples\n///\n///    > [1, 2, 2, 3, 4, 4, 6, 7, 7] |> chunk(by: fn(n) { n % 2 })\n///    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n///\npub fn chunk(in list: List(a), by f: fn(a) -> key) -> List(List(a)) {\n  case list {\n    [] -> []\n    [head, ..tail] -> do_chunk(tail, f, f(head), [head], [])\n  }\n}\n\nfn do_sized_chunk(\n  list: List(a),\n  count: Int,\n  left: Int,\n  current_chunk: List(a),\n  acc: List(List(a)),\n) -> List(List(a)) {\n  case list {\n    [] ->\n      case current_chunk {\n        [] -> reverse(acc)\n        remaining -> reverse([reverse(remaining), ..acc])\n      }\n    [head, ..tail] -> {\n      let chunk = [head, ..current_chunk]\n      case left > 1 {\n        False -> do_sized_chunk(tail, count, count, [], [reverse(chunk), ..acc])\n        True -> do_sized_chunk(tail, count, left - 1, chunk, acc)\n      }\n    }\n  }\n}\n\n/// Returns a list of chunks containing `count` elements each.\n///\n/// If the last chunk does not have `count` elements, it is instead\n/// a partial chunk, with less than `count` elements.\n///\n/// For any `count` less than 1 this function behaves as if it was set to 1.\n///\n/// ## Examples\n///\n///    > [1, 2, 3, 4, 5, 6] |> sized_chunk(into: 2)\n///    [[1, 2], [3, 4], [5, 6]]\n///\n///    > [1, 2, 3, 4, 5, 6, 7, 8] |> sized_chunk(into: 3)\n///    [[1, 2, 3], [4, 5, 6], [7, 8]]\n///\npub fn sized_chunk(in list: List(a), into count: Int) -> List(List(a)) {\n  do_sized_chunk(list, count, count, [], [])\n}\n\n/// This function acts similar to fold, but does not take an initial state.\n/// Instead, it starts from the first element in the list\n/// and combines it with each subsequent element in turn using the given function.\n/// The function is called as `fun(accumulator, current_element)`.\n///\n/// Returns `Ok` to indicate a successful run, and `Error` if called on an empty list.\n///\n/// ## Examples\n///\n///    > [] |> reduce(fn(acc, x) { acc + x })\n///    Error(Nil)\n///\n///    > [1, 2, 3, 4, 5] |> reduce(fn(acc, x) { acc + x })\n///    Ok(15)\n///\npub fn reduce(over list: List(a), with fun: fn(a, a) -> a) -> Result(a, Nil) {\n  case list {\n    [] -> Error(Nil)\n    [head, ..tail] -> Ok(fold(tail, head, fun))\n  }\n}\n\nfn do_scan(\n  list: List(a),\n  accumulator: acc,\n  accumulated: List(acc),\n  fun: fn(acc, a) -> acc,\n) -> List(acc) {\n  case list {\n    [] -> reverse(accumulated)\n    [x, ..xs] -> {\n      let next = fun(accumulator, x)\n      do_scan(xs, next, [next, ..accumulated], fun)\n    }\n  }\n}\n\n/// Similar to `fold`, but yields the state of the accumulator at each stage.\n///\n/// ## Examples\n///\n///    > scan(over: [1, 2, 3], from: 100, with: fn(acc, i) { acc + i })\n///    [101, 103, 106]\n///\npub fn scan(\n  over list: List(a),\n  from initial: acc,\n  with fun: fn(acc, a) -> acc,\n) -> List(acc) {\n  do_scan(list, initial, [], fun)\n}\n\n/// Returns the last element in the given list.\n///\n/// Returns `Error(Nil)` if the list is empty.\n///\n/// This function runs in linear time.\n/// For a collection oriented around performant access at either end,\n/// see `gleam/queue.Queue`.\n///\n/// ## Examples\n///\n///    > last([])\n///    Error(Nil)\n///\n///    > last([1, 2, 3, 4, 5])\n///    Ok(5)\n///\npub fn last(list: List(a)) -> Result(a, Nil) {\n  list\n  |> reduce(fn(_, elem) { elem })\n}\n\n/// Return unique combinations of elements in the list.\n///\n/// ## Examples\n///\n/// ```\n/// > combinations([1, 2, 3], 2)\n/// [[1, 2], [1, 3], [2, 3]]\n///\n///  > combinations([1, 2, 3, 4], 3)\n///  [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]\n/// ```\n///\npub fn combinations(items: List(a), by n: Int) -> List(List(a)) {\n  case n {\n    0 -> [[]]\n    _ ->\n      case items {\n        [] -> []\n        [x, ..xs] -> {\n          let first_combinations =\n            map(combinations(xs, n - 1), with: fn(com) { [x, ..com] })\n            |> reverse\n          fold(\n            first_combinations,\n            combinations(xs, n),\n            fn(acc, c) { [c, ..acc] },\n          )\n        }\n      }\n  }\n}\n\nfn do_combination_pairs(items: List(a)) -> List(List(#(a, a))) {\n  case items {\n    [] -> []\n    [x, ..xs] -> {\n      let first_combinations = map(xs, with: fn(other) { #(x, other) })\n      [first_combinations, ..do_combination_pairs(xs)]\n    }\n  }\n}\n\n/// Return unique pair combinations of elements in the list\n///\n/// ## Examples\n///\n/// ```\n/// > combination_pairs([1, 2, 3])\n/// [#(1, 2), #(1, 3), #(2, 3)]\n/// ```\n///\npub fn combination_pairs(items: List(a)) -> List(#(a, a)) {\n  do_combination_pairs(items)\n  |> flatten\n}\n\n/// Make a list alternating the elements from the given lists\n///\n/// ## Examples\n///\n/// ```\n/// > list.interleave([[1, 2], [101, 102], [201, 202]])\n/// [1, 101, 201, 2, 102, 202]\n/// ```\n///\npub fn interleave(list: List(List(a))) -> List(a) {\n  transpose(list)\n  |> flatten\n}\n\n/// Transpose rows and columns of the list of lists.\n///\n/// ## Examples\n///\n/// ```\n/// > transpose([[1, 2, 3], [101, 102, 103]])\n/// [[1, 101], [2, 102], [3, 103]]\n/// ```\npub fn transpose(list_of_list: List(List(a))) -> List(List(a)) {\n  let take_first = fn(list) {\n    case list {\n      [] -> []\n      [f] -> [f]\n      [f, ..] -> [f]\n    }\n  }\n\n  case list_of_list {\n    [] -> []\n    [[], ..xss] -> transpose(xss)\n    rows -> {\n      let firsts =\n        rows\n        |> map(take_first)\n        |> flatten\n      let rest = transpose(map(rows, drop(_, 1)))\n      [firsts, ..rest]\n    }\n  }\n}\n'},4841:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});const i='//// This module contains regular expression matching functions for strings.\n//// The matching algorithms of the library are based on the PCRE library, but not\n//// all of the PCRE library is interfaced and some parts of the library go beyond\n//// what PCRE offers. Currently PCRE version 8.40 (release date 2017-01-11) is used.\n\nimport gleam/option.{Option}\n\npub external type Regex\n\n/// The details about a particular match:\n///\npub type Match {\n  Match(\n    /// The full string of the match.\n    content: String,\n    /// A `Regex` can have subpatterns, sup-parts that are in parentheses.\n    submatches: List(Option(String)),\n  )\n}\n\n/// When a regular expression fails to compile:\n///\npub type CompileError {\n  CompileError(\n    /// The problem encountered that caused the compilation to fail\n    error: String,\n    /// The byte index into the string to where the problem was found\n    /// This value may not be correct in JavaScript environments.\n    byte_index: Int,\n  )\n}\n\npub type Options {\n  Options(case_insensitive: Bool, multi_line: Bool)\n}\n\n/// Creates a `Regex` with some additional options.\n///\n/// ## Examples\n///\n///    > let options = Options(case_insensitive: False, multi_line: True)\n///    > assert Ok(re) = compile("^[0-9]", with: options)\n///    > match(re, "abc\\n123")\n///    True\n///\n///    > let options = Options(case_insensitive: True, multi_line: False)\n///    > assert Ok(re) = compile("[A-Z]", with: options)\n///    > match(re, "abc123")\n///    True\n///\npub fn compile(\n  pattern: String,\n  with options: Options,\n) -> Result(Regex, CompileError) {\n  do_compile(pattern, options)\n}\n\nif erlang {\n  external fn do_compile(String, with: Options) -> Result(Regex, CompileError) =\n    "gleam_stdlib" "compile_regex"\n}\n\nif javascript {\n  external fn do_compile(String, with: Options) -> Result(Regex, CompileError) =\n    "../gleam_stdlib.mjs" "compile_regex"\n}\n\n/// Creates a new `Regex`.\n///\n/// ## Examples\n///\n///    > assert Ok(re) = from_string("[0-9]")\n///    > match(re, "abc123")\n///    True\n///\n///    > match(re, "abcxyz")\n///    False\n///\n///    > from_string("[0-9")\n///    Error(\n///      CompileError(\n///        error: "missing terminating ] for character class",\n///        byte_index: 4\n///      )\n///    )\n///\npub fn from_string(pattern: String) -> Result(Regex, CompileError) {\n  compile(pattern, Options(case_insensitive: False, multi_line: False))\n}\n\n/// Returns a boolean indicating whether there was a match or not.\n///\n/// ## Examples\n///\n///    > assert Ok(re) = from_string("^f.o.?")\n///    > check(with: re, content: "foo")\n///    True\n///\n///    > check(with: re, content: "boo")\n///    False\n///\npub fn check(with regex: Regex, content content: String) -> Bool {\n  do_check(regex, content)\n}\n\nif erlang {\n  external fn do_check(Regex, String) -> Bool =\n    "gleam_stdlib" "regex_check"\n}\n\nif javascript {\n  external fn do_check(Regex, String) -> Bool =\n    "../gleam_stdlib.mjs" "regex_check"\n}\n\n/// Splits a string.\n///\n/// ## Examples\n///\n///    > assert Ok(re) = from_string(" *, *")\n///    > split(with: re, content: "foo,32, 4, 9  ,0")\n///    ["foo", "32", "4", "9", "0"]\n///\npub fn split(with regex: Regex, content string: String) -> List(String) {\n  do_split(regex, string)\n}\n\nif erlang {\n  external fn do_split(Regex, String) -> List(String) =\n    "gleam_stdlib" "regex_split"\n}\n\nif javascript {\n  fn do_split(regex, string) -> List(String) {\n    js_split(string, regex)\n  }\n\n  external fn js_split(String, Regex) -> List(String) =\n    "../gleam_stdlib.mjs" "split"\n}\n\n/// Collects all matches of the regular expression.\n///\n/// ## Examples\n///\n///    > assert Ok(re) = regex.from_string("[oi]n a (\\\\w+)")\n///    > regex.scan(with: re, content: "I am on a boat in a lake.")\n///    [\n///      Match(\n///        content: "on a boat",\n///        submatches: [Some("boat")]\n///      ),\n///      Match(\n///        content: "in a lake",\n///        submatches: [Some("lake")]\n///      )\n///    ]\n///\npub fn scan(with regex: Regex, content string: String) -> List(Match) {\n  do_scan(regex, string)\n}\n\nif erlang {\n  external fn do_scan(Regex, String) -> List(Match) =\n    "gleam_stdlib" "regex_scan"\n}\n\nif javascript {\n  external fn do_scan(Regex, String) -> List(Match) =\n    "../gleam_stdlib.mjs" "regex_scan"\n}\n'}}]);