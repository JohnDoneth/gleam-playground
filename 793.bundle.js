"use strict";(self.webpackChunkgleam_playground=self.webpackChunkgleam_playground||[]).push([[793],{6241:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>r,language:()=>i});var r={comments:{lineComment:"//",blockComment:["(*","*)"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],folding:{markers:{start:new RegExp("^\\s*//\\s*#region\\b|^\\s*\\(\\*\\s*#region(.*)\\*\\)"),end:new RegExp("^\\s*//\\s*#endregion\\b|^\\s*\\(\\*\\s*#endregion\\s*\\*\\)")}}},i={defaultToken:"",tokenPostfix:".fs",keywords:["abstract","and","atomic","as","assert","asr","base","begin","break","checked","component","const","constraint","constructor","continue","class","default","delegate","do","done","downcast","downto","elif","else","end","exception","eager","event","external","extern","false","finally","for","fun","function","fixed","functor","global","if","in","include","inherit","inline","interface","internal","land","lor","lsl","lsr","lxor","lazy","let","match","member","mod","module","mutable","namespace","method","mixin","new","not","null","of","open","or","object","override","private","parallel","process","protected","pure","public","rec","return","static","sealed","struct","sig","then","to","true","tailcall","trait","try","type","upcast","use","val","void","virtual","volatile","when","while","with","yield"],symbols:/[=><!~?:&|+\-*\^%;\.,\/]+/,escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,integersuffix:/[uU]?[yslnLI]?/,floatsuffix:/[fFmM]?/,tokenizer:{root:[[/[a-zA-Z_]\w*/,{cases:{"@keywords":{token:"keyword.$0"},"@default":"identifier"}}],{include:"@whitespace"},[/\[<.*>\]/,"annotation"],[/^#(if|else|endif)/,"keyword"],[/[{}()\[\]]/,"@brackets"],[/[<>](?!@symbols)/,"@brackets"],[/@symbols/,"delimiter"],[/\d*\d+[eE]([\-+]?\d+)?(@floatsuffix)/,"number.float"],[/\d*\.\d+([eE][\-+]?\d+)?(@floatsuffix)/,"number.float"],[/0x[0-9a-fA-F]+LF/,"number.float"],[/0x[0-9a-fA-F]+(@integersuffix)/,"number.hex"],[/0b[0-1]+(@integersuffix)/,"number.bin"],[/\d+(@integersuffix)/,"number"],[/[;,.]/,"delimiter"],[/"([^"\\]|\\.)*$/,"string.invalid"],[/"""/,"string",'@string."""'],[/"/,"string",'@string."'],[/\@"/,{token:"string.quote",next:"@litstring"}],[/'[^\\']'B?/,"string"],[/(')(@escapes)(')/,["string","string.escape","string"]],[/'/,"string.invalid"]],whitespace:[[/[ \t\r\n]+/,""],[/\(\*(?!\))/,"comment","@comment"],[/\/\/.*$/,"comment"]],comment:[[/[^*(]+/,"comment"],[/\*\)/,"comment","@pop"],[/\*/,"comment"],[/\(\*\)/,"comment"],[/\(/,"comment"]],string:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/("""|"B?)/,{cases:{"$#==$S2":{token:"string",next:"@pop"},"@default":"string"}}]],litstring:[[/[^"]+/,"string"],[/""/,"string.escape"],[/"/,{token:"string.quote",next:"@pop"}]]}}},249:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>r,language:()=>i});var r={comments:{lineComment:"//",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:"`",close:"`",notIn:["string"]},{open:'"',close:'"',notIn:["string"]},{open:"'",close:"'",notIn:["string","comment"]}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:"`",close:"`"},{open:'"',close:'"'},{open:"'",close:"'"}]},i={defaultToken:"",tokenPostfix:".go",keywords:["break","case","chan","const","continue","default","defer","else","fallthrough","for","func","go","goto","if","import","interface","map","package","range","return","select","struct","switch","type","var","bool","true","false","uint8","uint16","uint32","uint64","int8","int16","int32","int64","float32","float64","complex64","complex128","byte","rune","uint","int","uintptr","string","nil"],operators:["+","-","*","/","%","&","|","^","<<",">>","&^","+=","-=","*=","/=","%=","&=","|=","^=","<<=",">>=","&^=","&&","||","<-","++","--","==","<",">","=","!","!=","<=",">=",":=","...","(",")","","]","{","}",",",";",".",":"],symbols:/[=><!~?:&|+\-*\/\^%]+/,escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,tokenizer:{root:[[/[a-zA-Z_]\w*/,{cases:{"@keywords":{token:"keyword.$0"},"@default":"identifier"}}],{include:"@whitespace"},[/\[\[.*\]\]/,"annotation"],[/^\s*#\w+/,"keyword"],[/[{}()\[\]]/,"@brackets"],[/[<>](?!@symbols)/,"@brackets"],[/@symbols/,{cases:{"@operators":"delimiter","@default":""}}],[/\d*\d+[eE]([\-+]?\d+)?/,"number.float"],[/\d*\.\d+([eE][\-+]?\d+)?/,"number.float"],[/0[xX][0-9a-fA-F']*[0-9a-fA-F]/,"number.hex"],[/0[0-7']*[0-7]/,"number.octal"],[/0[bB][0-1']*[0-1]/,"number.binary"],[/\d[\d']*/,"number"],[/\d/,"number"],[/[;,.]/,"delimiter"],[/"([^"\\]|\\.)*$/,"string.invalid"],[/"/,"string","@string"],[/`/,"string","@rawstring"],[/'[^\\']'/,"string"],[/(')(@escapes)(')/,["string","string.escape","string"]],[/'/,"string.invalid"]],whitespace:[[/[ \t\r\n]+/,""],[/\/\*\*(?!\/)/,"comment.doc","@doccomment"],[/\/\*/,"comment","@comment"],[/\/\/.*$/,"comment"]],comment:[[/[^\/*]+/,"comment"],[/\*\//,"comment","@pop"],[/[\/*]/,"comment"]],doccomment:[[/[^\/*]+/,"comment.doc"],[/\/\*/,"comment.doc.invalid"],[/\*\//,"comment.doc","@pop"],[/[\/*]/,"comment.doc"]],string:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,"string","@pop"]],rawstring:[[/[^\`]/,"string"],[/`/,"string","@pop"]]}}},5703:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>o,language:()=>a});var r=t(9587),i=["area","base","br","col","embed","hr","img","input","keygen","link","menuitem","meta","param","source","track","wbr"],o={wordPattern:/(-?\d*\.\d\w*)|([^\`\~\!\@\$\^\&\*\(\)\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\s]+)/g,comments:{blockComment:["{{!--","--}}"]},brackets:[["\x3c!--","--\x3e"],["<",">"],["{{","}}"],["{","}"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:"<",close:">"},{open:'"',close:'"'},{open:"'",close:"'"}],onEnterRules:[{beforeText:new RegExp("<(?!(?:"+i.join("|")+"))(\\w[\\w\\d]*)([^/>]*(?!/)>)[^<]*$","i"),afterText:/^<\/(\w[\w\d]*)\s*>$/i,action:{indentAction:r.Mj.IndentAction.IndentOutdent}},{beforeText:new RegExp("<(?!(?:"+i.join("|")+"))(\\w[\\w\\d]*)([^/>]*(?!/)>)[^<]*$","i"),action:{indentAction:r.Mj.IndentAction.Indent}}]},a={defaultToken:"",tokenPostfix:"",tokenizer:{root:[[/\{\{!--/,"comment.block.start.handlebars","@commentBlock"],[/\{\{!/,"comment.start.handlebars","@comment"],[/\{\{/,{token:"@rematch",switchTo:"@handlebarsInSimpleState.root"}],[/<!DOCTYPE/,"metatag.html","@doctype"],[/<!--/,"comment.html","@commentHtml"],[/(<)(\w+)(\/>)/,["delimiter.html","tag.html","delimiter.html"]],[/(<)(script)/,["delimiter.html",{token:"tag.html",next:"@script"}]],[/(<)(style)/,["delimiter.html",{token:"tag.html",next:"@style"}]],[/(<)([:\w]+)/,["delimiter.html",{token:"tag.html",next:"@otherTag"}]],[/(<\/)(\w+)/,["delimiter.html",{token:"tag.html",next:"@otherTag"}]],[/</,"delimiter.html"],[/\{/,"delimiter.html"],[/[^<{]+/]],doctype:[[/\{\{/,{token:"@rematch",switchTo:"@handlebarsInSimpleState.comment"}],[/[^>]+/,"metatag.content.html"],[/>/,"metatag.html","@pop"]],comment:[[/\}\}/,"comment.end.handlebars","@pop"],[/./,"comment.content.handlebars"]],commentBlock:[[/--\}\}/,"comment.block.end.handlebars","@pop"],[/./,"comment.content.handlebars"]],commentHtml:[[/\{\{/,{token:"@rematch",switchTo:"@handlebarsInSimpleState.comment"}],[/-->/,"comment.html","@pop"],[/[^-]+/,"comment.content.html"],[/./,"comment.content.html"]],otherTag:[[/\{\{/,{token:"@rematch",switchTo:"@handlebarsInSimpleState.otherTag"}],[/\/?>/,"delimiter.html","@pop"],[/"([^"]*)"/,"attribute.value"],[/'([^']*)'/,"attribute.value"],[/[\w\-]+/,"attribute.name"],[/=/,"delimiter"],[/[ \t\r\n]+/]],script:[[/\{\{/,{token:"@rematch",switchTo:"@handlebarsInSimpleState.script"}],[/type/,"attribute.name","@scriptAfterType"],[/"([^"]*)"/,"attribute.value"],[/'([^']*)'/,"attribute.value"],[/[\w\-]+/,"attribute.name"],[/=/,"delimiter"],[/>/,{token:"delimiter.html",next:"@scriptEmbedded.text/javascript",nextEmbedded:"text/javascript"}],[/[ \t\r\n]+/],[/(<\/)(script\s*)(>)/,["delimiter.html","tag.html",{token:"delimiter.html",next:"@pop"}]]],scriptAfterType:[[/\{\{/,{token:"@rematch",switchTo:"@handlebarsInSimpleState.scriptAfterType"}],[/=/,"delimiter","@scriptAfterTypeEquals"],[/>/,{token:"delimiter.html",next:"@scriptEmbedded.text/javascript",nextEmbedded:"text/javascript"}],[/[ \t\r\n]+/],[/<\/script\s*>/,{token:"@rematch",next:"@pop"}]],scriptAfterTypeEquals:[[/\{\{/,{token:"@rematch",switchTo:"@handlebarsInSimpleState.scriptAfterTypeEquals"}],[/"([^"]*)"/,{token:"attribute.value",switchTo:"@scriptWithCustomType.$1"}],[/'([^']*)'/,{token:"attribute.value",switchTo:"@scriptWithCustomType.$1"}],[/>/,{token:"delimiter.html",next:"@scriptEmbedded.text/javascript",nextEmbedded:"text/javascript"}],[/[ \t\r\n]+/],[/<\/script\s*>/,{token:"@rematch",next:"@pop"}]],scriptWithCustomType:[[/\{\{/,{token:"@rematch",switchTo:"@handlebarsInSimpleState.scriptWithCustomType.$S2"}],[/>/,{token:"delimiter.html",next:"@scriptEmbedded.$S2",nextEmbedded:"$S2"}],[/"([^"]*)"/,"attribute.value"],[/'([^']*)'/,"attribute.value"],[/[\w\-]+/,"attribute.name"],[/=/,"delimiter"],[/[ \t\r\n]+/],[/<\/script\s*>/,{token:"@rematch",next:"@pop"}]],scriptEmbedded:[[/\{\{/,{token:"@rematch",switchTo:"@handlebarsInEmbeddedState.scriptEmbedded.$S2",nextEmbedded:"@pop"}],[/<\/script/,{token:"@rematch",next:"@pop",nextEmbedded:"@pop"}]],style:[[/\{\{/,{token:"@rematch",switchTo:"@handlebarsInSimpleState.style"}],[/type/,"attribute.name","@styleAfterType"],[/"([^"]*)"/,"attribute.value"],[/'([^']*)'/,"attribute.value"],[/[\w\-]+/,"attribute.name"],[/=/,"delimiter"],[/>/,{token:"delimiter.html",next:"@styleEmbedded.text/css",nextEmbedded:"text/css"}],[/[ \t\r\n]+/],[/(<\/)(style\s*)(>)/,["delimiter.html","tag.html",{token:"delimiter.html",next:"@pop"}]]],styleAfterType:[[/\{\{/,{token:"@rematch",switchTo:"@handlebarsInSimpleState.styleAfterType"}],[/=/,"delimiter","@styleAfterTypeEquals"],[/>/,{token:"delimiter.html",next:"@styleEmbedded.text/css",nextEmbedded:"text/css"}],[/[ \t\r\n]+/],[/<\/style\s*>/,{token:"@rematch",next:"@pop"}]],styleAfterTypeEquals:[[/\{\{/,{token:"@rematch",switchTo:"@handlebarsInSimpleState.styleAfterTypeEquals"}],[/"([^"]*)"/,{token:"attribute.value",switchTo:"@styleWithCustomType.$1"}],[/'([^']*)'/,{token:"attribute.value",switchTo:"@styleWithCustomType.$1"}],[/>/,{token:"delimiter.html",next:"@styleEmbedded.text/css",nextEmbedded:"text/css"}],[/[ \t\r\n]+/],[/<\/style\s*>/,{token:"@rematch",next:"@pop"}]],styleWithCustomType:[[/\{\{/,{token:"@rematch",switchTo:"@handlebarsInSimpleState.styleWithCustomType.$S2"}],[/>/,{token:"delimiter.html",next:"@styleEmbedded.$S2",nextEmbedded:"$S2"}],[/"([^"]*)"/,"attribute.value"],[/'([^']*)'/,"attribute.value"],[/[\w\-]+/,"attribute.name"],[/=/,"delimiter"],[/[ \t\r\n]+/],[/<\/style\s*>/,{token:"@rematch",next:"@pop"}]],styleEmbedded:[[/\{\{/,{token:"@rematch",switchTo:"@handlebarsInEmbeddedState.styleEmbedded.$S2",nextEmbedded:"@pop"}],[/<\/style/,{token:"@rematch",next:"@pop",nextEmbedded:"@pop"}]],handlebarsInSimpleState:[[/\{\{\{?/,"delimiter.handlebars"],[/\}\}\}?/,{token:"delimiter.handlebars",switchTo:"@$S2.$S3"}],{include:"handlebarsRoot"}],handlebarsInEmbeddedState:[[/\{\{\{?/,"delimiter.handlebars"],[/\}\}\}?/,{token:"delimiter.handlebars",switchTo:"@$S2.$S3",nextEmbedded:"$S3"}],{include:"handlebarsRoot"}],handlebarsRoot:[[/"[^"]*"/,"string.handlebars"],[/[#/][^\s}]+/,"keyword.helper.handlebars"],[/else\b/,"keyword.helper.handlebars"],[/[\s]+/],[/[^}]/,"variable.parameter.handlebars"]]}}},3632:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>r,language:()=>i});var r={comments:{lineComment:"#",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"',notIn:["string"]}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'}]},i={defaultToken:"",tokenPostfix:".hcl",keywords:["var","local","path","for_each","any","string","number","bool","true","false","null","if ","else ","endif ","for ","in","endfor"],operators:["=",">=","<=","==","!=","+","-","*","/","%","&&","||","!","<",">","?","...",":"],symbols:/[=><!~?:&|+\-*\/\^%]+/,escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,terraformFunctions:/(abs|ceil|floor|log|max|min|pow|signum|chomp|format|formatlist|indent|join|lower|regex|regexall|replace|split|strrev|substr|title|trimspace|upper|chunklist|coalesce|coalescelist|compact|concat|contains|distinct|element|flatten|index|keys|length|list|lookup|map|matchkeys|merge|range|reverse|setintersection|setproduct|setunion|slice|sort|transpose|values|zipmap|base64decode|base64encode|base64gzip|csvdecode|jsondecode|jsonencode|urlencode|yamldecode|yamlencode|abspath|dirname|pathexpand|basename|file|fileexists|fileset|filebase64|templatefile|formatdate|timeadd|timestamp|base64sha256|base64sha512|bcrypt|filebase64sha256|filebase64sha512|filemd5|filemd1|filesha256|filesha512|md5|rsadecrypt|sha1|sha256|sha512|uuid|uuidv5|cidrhost|cidrnetmask|cidrsubnet|tobool|tolist|tomap|tonumber|toset|tostring)/,terraformMainBlocks:/(module|data|terraform|resource|provider|variable|output|locals)/,tokenizer:{root:[[/^@terraformMainBlocks([ \t]*)([\w-]+|"[\w-]+"|)([ \t]*)([\w-]+|"[\w-]+"|)([ \t]*)(\{)/,["type","","string","","string","","@brackets"]],[/(\w+[ \t]+)([ \t]*)([\w-]+|"[\w-]+"|)([ \t]*)([\w-]+|"[\w-]+"|)([ \t]*)(\{)/,["identifier","","string","","string","","@brackets"]],[/(\w+[ \t]+)([ \t]*)([\w-]+|"[\w-]+"|)([ \t]*)([\w-]+|"[\w-]+"|)(=)(\{)/,["identifier","","string","","operator","","@brackets"]],{include:"@terraform"}],terraform:[[/@terraformFunctions(\()/,["type","@brackets"]],[/[a-zA-Z_]\w*-*/,{cases:{"@keywords":{token:"keyword.$0"},"@default":"variable"}}],{include:"@whitespace"},{include:"@heredoc"},[/[{}()\[\]]/,"@brackets"],[/[<>](?!@symbols)/,"@brackets"],[/@symbols/,{cases:{"@operators":"operator","@default":""}}],[/\d*\d+[eE]([\-+]?\d+)?/,"number.float"],[/\d*\.\d+([eE][\-+]?\d+)?/,"number.float"],[/\d[\d']*/,"number"],[/\d/,"number"],[/[;,.]/,"delimiter"],[/"/,"string","@string"],[/'/,"invalid"]],heredoc:[[/<<[-]*\s*["]?([\w\-]+)["]?/,{token:"string.heredoc.delimiter",next:"@heredocBody.$1"}]],heredocBody:[[/([\w\-]+)$/,{cases:{"$1==$S2":[{token:"string.heredoc.delimiter",next:"@popall"}],"@default":"string.heredoc"}}],[/./,"string.heredoc"]],whitespace:[[/[ \t\r\n]+/,""],[/\/\*/,"comment","@comment"],[/\/\/.*$/,"comment"],[/#.*$/,"comment"]],comment:[[/[^\/*]+/,"comment"],[/\*\//,"comment","@pop"],[/[\/*]/,"comment"]],string:[[/\$\{/,{token:"delimiter",next:"@stringExpression"}],[/[^\\"\$]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,"string","@popall"]],stringInsideExpression:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,"string","@pop"]],stringExpression:[[/\}/,{token:"delimiter",next:"@pop"}],[/"/,"string","@stringInsideExpression"],{include:"@terraform"}]}}},7043:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>r,language:()=>i});var r={wordPattern:/(-?\d*\.\d\w*)|([^\`\~\!\#\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g,comments:{lineComment:"//",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"},{open:"<",close:">"}],folding:{markers:{start:new RegExp("^\\s*//\\s*(?:(?:#?region\\b)|(?:<editor-fold\\b))"),end:new RegExp("^\\s*//\\s*(?:(?:#?endregion\\b)|(?:</editor-fold>))")}}},i={defaultToken:"",tokenPostfix:".java",keywords:["abstract","continue","for","new","switch","assert","default","goto","package","synchronized","boolean","do","if","private","this","break","double","implements","protected","throw","byte","else","import","public","throws","case","enum","instanceof","return","transient","catch","extends","int","short","try","char","final","interface","static","void","class","finally","long","strictfp","volatile","const","float","native","super","while","true","false","yield","record","sealed","non-sealed","permits"],operators:["=",">","<","!","~","?",":","==","<=",">=","!=","&&","||","++","--","+","-","*","/","&","|","^","%","<<",">>",">>>","+=","-=","*=","/=","&=","|=","^=","%=","<<=",">>=",">>>="],symbols:/[=><!~?:&|+\-*\/\^%]+/,escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,digits:/\d+(_+\d+)*/,octaldigits:/[0-7]+(_+[0-7]+)*/,binarydigits:/[0-1]+(_+[0-1]+)*/,hexdigits:/[[0-9a-fA-F]+(_+[0-9a-fA-F]+)*/,tokenizer:{root:[["non-sealed","keyword.non-sealed"],[/[a-zA-Z_$][\w$]*/,{cases:{"@keywords":{token:"keyword.$0"},"@default":"identifier"}}],{include:"@whitespace"},[/[{}()\[\]]/,"@brackets"],[/[<>](?!@symbols)/,"@brackets"],[/@symbols/,{cases:{"@operators":"delimiter","@default":""}}],[/@\s*[a-zA-Z_\$][\w\$]*/,"annotation"],[/(@digits)[eE]([\-+]?(@digits))?[fFdD]?/,"number.float"],[/(@digits)\.(@digits)([eE][\-+]?(@digits))?[fFdD]?/,"number.float"],[/0[xX](@hexdigits)[Ll]?/,"number.hex"],[/0(@octaldigits)[Ll]?/,"number.octal"],[/0[bB](@binarydigits)[Ll]?/,"number.binary"],[/(@digits)[fFdD]/,"number.float"],[/(@digits)[lL]?/,"number"],[/[;,.]/,"delimiter"],[/"([^"\\]|\\.)*$/,"string.invalid"],[/"""/,"string","@multistring"],[/"/,"string","@string"],[/'[^\\']'/,"string"],[/(')(@escapes)(')/,["string","string.escape","string"]],[/'/,"string.invalid"]],whitespace:[[/[ \t\r\n]+/,""],[/\/\*\*(?!\/)/,"comment.doc","@javadoc"],[/\/\*/,"comment","@comment"],[/\/\/.*$/,"comment"]],comment:[[/[^\/*]+/,"comment"],[/\*\//,"comment","@pop"],[/[\/*]/,"comment"]],javadoc:[[/[^\/*]+/,"comment.doc"],[/\/\*/,"comment.doc.invalid"],[/\*\//,"comment.doc","@pop"],[/[\/*]/,"comment.doc"]],string:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,"string","@pop"]],multistring:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"""/,"string","@pop"],[/./,"string"]]}}},5593:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>r,language:()=>i});var r={wordPattern:/(#?-?\d*\.\d\w*%?)|([@#!.:]?[\w-?]+%?)|[@#!.]/g,comments:{blockComment:["/*","*/"],lineComment:"//"},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}",notIn:["string","comment"]},{open:"[",close:"]",notIn:["string","comment"]},{open:"(",close:")",notIn:["string","comment"]},{open:'"',close:'"',notIn:["string","comment"]},{open:"'",close:"'",notIn:["string","comment"]}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],folding:{markers:{start:new RegExp("^\\s*\\/\\*\\s*#region\\b\\s*(.*?)\\s*\\*\\/"),end:new RegExp("^\\s*\\/\\*\\s*#endregion\\b.*\\*\\/")}}},i={defaultToken:"",tokenPostfix:".less",identifier:"-?-?([a-zA-Z]|(\\\\(([0-9a-fA-F]{1,6}\\s?)|[^[0-9a-fA-F])))([\\w\\-]|(\\\\(([0-9a-fA-F]{1,6}\\s?)|[^[0-9a-fA-F])))*",identifierPlus:"-?-?([a-zA-Z:.]|(\\\\(([0-9a-fA-F]{1,6}\\s?)|[^[0-9a-fA-F])))([\\w\\-:.]|(\\\\(([0-9a-fA-F]{1,6}\\s?)|[^[0-9a-fA-F])))*",brackets:[{open:"{",close:"}",token:"delimiter.curly"},{open:"[",close:"]",token:"delimiter.bracket"},{open:"(",close:")",token:"delimiter.parenthesis"},{open:"<",close:">",token:"delimiter.angle"}],tokenizer:{root:[{include:"@nestedJSBegin"},["[ \\t\\r\\n]+",""],{include:"@comments"},{include:"@keyword"},{include:"@strings"},{include:"@numbers"},["[*_]?[a-zA-Z\\-\\s]+(?=:.*(;|(\\\\$)))","attribute.name","@attribute"],["url(\\-prefix)?\\(",{token:"tag",next:"@urldeclaration"}],["[{}()\\[\\]]","@brackets"],["[,:;]","delimiter"],["#@identifierPlus","tag.id"],["&","tag"],["\\.@identifierPlus(?=\\()","tag.class","@attribute"],["\\.@identifierPlus","tag.class"],["@identifierPlus","tag"],{include:"@operators"},["@(@identifier(?=[:,\\)]))","variable","@attribute"],["@(@identifier)","variable"],["@","key","@atRules"]],nestedJSBegin:[["``","delimiter.backtick"],["`",{token:"delimiter.backtick",next:"@nestedJSEnd",nextEmbedded:"text/javascript"}]],nestedJSEnd:[["`",{token:"delimiter.backtick",next:"@pop",nextEmbedded:"@pop"}]],operators:[["[<>=\\+\\-\\*\\/\\^\\|\\~]","operator"]],keyword:[["(@[\\s]*import|![\\s]*important|true|false|when|iscolor|isnumber|isstring|iskeyword|isurl|ispixel|ispercentage|isem|hue|saturation|lightness|alpha|lighten|darken|saturate|desaturate|fadein|fadeout|fade|spin|mix|round|ceil|floor|percentage)\\b","keyword"]],urldeclaration:[{include:"@strings"},["[^)\r\n]+","string"],["\\)",{token:"tag",next:"@pop"}]],attribute:[{include:"@nestedJSBegin"},{include:"@comments"},{include:"@strings"},{include:"@numbers"},{include:"@keyword"},["[a-zA-Z\\-]+(?=\\()","attribute.value","@attribute"],[">","operator","@pop"],["@identifier","attribute.value"],{include:"@operators"},["@(@identifier)","variable"],["[)\\}]","@brackets","@pop"],["[{}()\\[\\]>]","@brackets"],["[;]","delimiter","@pop"],["[,=:]","delimiter"],["\\s",""],[".","attribute.value"]],comments:[["\\/\\*","comment","@comment"],["\\/\\/+.*","comment"]],comment:[["\\*\\/","comment","@pop"],[".","comment"]],numbers:[["(\\d*\\.)?\\d+([eE][\\-+]?\\d+)?",{token:"attribute.value.number",next:"@units"}],["#[0-9a-fA-F_]+(?!\\w)","attribute.value.hex"]],units:[["(em|ex|ch|rem|vmin|vmax|vw|vh|vm|cm|mm|in|px|pt|pc|deg|grad|rad|turn|s|ms|Hz|kHz|%)?","attribute.value.unit","@pop"]],strings:[['~?"',{token:"string.delimiter",next:"@stringsEndDoubleQuote"}],["~?'",{token:"string.delimiter",next:"@stringsEndQuote"}]],stringsEndDoubleQuote:[['\\\\"',"string"],['"',{token:"string.delimiter",next:"@popall"}],[".","string"]],stringsEndQuote:[["\\\\'","string"],["'",{token:"string.delimiter",next:"@popall"}],[".","string"]],atRules:[{include:"@comments"},{include:"@strings"},["[()]","delimiter"],["[\\{;]","delimiter","@pop"],[".","key"]]}}},4028:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>o,language:()=>a});var r=t(9587),i=["area","base","br","col","embed","hr","img","input","keygen","link","menuitem","meta","param","source","track","wbr"],o={wordPattern:/(-?\d*\.\d\w*)|([^\`\~\!\@\$\^\&\*\(\)\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\s]+)/g,brackets:[["\x3c!--","--\x3e"],["<",">"],["{{","}}"],["{%","%}"],["{","}"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"%",close:"%"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:"<",close:">"},{open:'"',close:'"'},{open:"'",close:"'"}],onEnterRules:[{beforeText:new RegExp("<(?!(?:"+i.join("|")+"))(\\w[\\w\\d]*)([^/>]*(?!/)>)[^<]*$","i"),afterText:/^<\/(\w[\w\d]*)\s*>$/i,action:{indentAction:r.Mj.IndentAction.IndentOutdent}},{beforeText:new RegExp("<(?!(?:"+i.join("|")+"))(\\w[\\w\\d]*)([^/>]*(?!/)>)[^<]*$","i"),action:{indentAction:r.Mj.IndentAction.Indent}}]},a={defaultToken:"",tokenPostfix:"",builtinTags:["if","else","elseif","endif","render","assign","capture","endcapture","case","endcase","comment","endcomment","cycle","decrement","for","endfor","include","increment","layout","raw","endraw","render","tablerow","endtablerow","unless","endunless"],builtinFilters:["abs","append","at_least","at_most","capitalize","ceil","compact","date","default","divided_by","downcase","escape","escape_once","first","floor","join","json","last","lstrip","map","minus","modulo","newline_to_br","plus","prepend","remove","remove_first","replace","replace_first","reverse","round","rstrip","size","slice","sort","sort_natural","split","strip","strip_html","strip_newlines","times","truncate","truncatewords","uniq","upcase","url_decode","url_encode","where"],constants:["true","false"],operators:["==","!=",">","<",">=","<="],symbol:/[=><!]+/,identifier:/[a-zA-Z_][\w]*/,tokenizer:{root:[[/\{\%\s*comment\s*\%\}/,"comment.start.liquid","@comment"],[/\{\{/,{token:"@rematch",switchTo:"@liquidState.root"}],[/\{\%/,{token:"@rematch",switchTo:"@liquidState.root"}],[/(<)([\w\-]+)(\/>)/,["delimiter.html","tag.html","delimiter.html"]],[/(<)([:\w]+)/,["delimiter.html",{token:"tag.html",next:"@otherTag"}]],[/(<\/)([\w\-]+)/,["delimiter.html",{token:"tag.html",next:"@otherTag"}]],[/</,"delimiter.html"],[/\{/,"delimiter.html"],[/[^<{]+/]],comment:[[/\{\%\s*endcomment\s*\%\}/,"comment.end.liquid","@pop"],[/./,"comment.content.liquid"]],otherTag:[[/\{\{/,{token:"@rematch",switchTo:"@liquidState.otherTag"}],[/\{\%/,{token:"@rematch",switchTo:"@liquidState.otherTag"}],[/\/?>/,"delimiter.html","@pop"],[/"([^"]*)"/,"attribute.value"],[/'([^']*)'/,"attribute.value"],[/[\w\-]+/,"attribute.name"],[/=/,"delimiter"],[/[ \t\r\n]+/]],liquidState:[[/\{\{/,"delimiter.output.liquid"],[/\}\}/,{token:"delimiter.output.liquid",switchTo:"@$S2.$S3"}],[/\{\%/,"delimiter.tag.liquid"],[/raw\s*\%\}/,"delimiter.tag.liquid","@liquidRaw"],[/\%\}/,{token:"delimiter.tag.liquid",switchTo:"@$S2.$S3"}],{include:"liquidRoot"}],liquidRaw:[[/^(?!\{\%\s*endraw\s*\%\}).+/],[/\{\%/,"delimiter.tag.liquid"],[/@identifier/],[/\%\}/,{token:"delimiter.tag.liquid",next:"@root"}]],liquidRoot:[[/\d+(\.\d+)?/,"number.liquid"],[/"[^"]*"/,"string.liquid"],[/'[^']*'/,"string.liquid"],[/\s+/],[/@symbol/,{cases:{"@operators":"operator.liquid","@default":""}}],[/\./],[/@identifier/,{cases:{"@constants":"keyword.liquid","@builtinFilters":"predefined.liquid","@builtinTags":"predefined.liquid","@default":"variable.liquid"}}],[/[^}|%]/,"variable.liquid"]]}}},6082:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>r,language:()=>i});var r={wordPattern:/(-?\d*\.\d\w*)|([^\`\~\!\#\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g,comments:{lineComment:"//",blockComment:["{","}"]},brackets:[["{","}"],["[","]"],["(",")"],["<",">"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:"<",close:">"},{open:"'",close:"'"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:"<",close:">"},{open:"'",close:"'"}],folding:{markers:{start:new RegExp("^\\s*\\{\\$REGION(\\s\\'.*\\')?\\}"),end:new RegExp("^\\s*\\{\\$ENDREGION\\}")}}},i={defaultToken:"",tokenPostfix:".pascal",ignoreCase:!0,brackets:[{open:"{",close:"}",token:"delimiter.curly"},{open:"[",close:"]",token:"delimiter.square"},{open:"(",close:")",token:"delimiter.parenthesis"},{open:"<",close:">",token:"delimiter.angle"}],keywords:["absolute","abstract","all","and_then","array","as","asm","attribute","begin","bindable","case","class","const","contains","default","div","else","end","except","exports","external","far","file","finalization","finally","forward","generic","goto","if","implements","import","in","index","inherited","initialization","interrupt","is","label","library","mod","module","name","near","not","object","of","on","only","operator","or_else","otherwise","override","package","packed","pow","private","program","protected","public","published","interface","implementation","qualified","read","record","resident","requires","resourcestring","restricted","segment","set","shl","shr","specialize","stored","strict","then","threadvar","to","try","type","unit","uses","var","view","virtual","dynamic","overload","reintroduce","with","write","xor","true","false","procedure","function","constructor","destructor","property","break","continue","exit","abort","while","do","for","raise","repeat","until"],typeKeywords:["boolean","double","byte","integer","shortint","char","longint","float","string"],operators:["=",">","<","<=",">=","<>",":",":=","and","or","+","-","*","/","@","&","^","%"],symbols:/[=><:@\^&|+\-*\/\^%]+/,tokenizer:{root:[[/[a-zA-Z_][\w]*/,{cases:{"@keywords":{token:"keyword.$0"},"@default":"identifier"}}],{include:"@whitespace"},[/[{}()\[\]]/,"@brackets"],[/[<>](?!@symbols)/,"@brackets"],[/@symbols/,{cases:{"@operators":"delimiter","@default":""}}],[/\d*\.\d+([eE][\-+]?\d+)?/,"number.float"],[/\$[0-9a-fA-F]{1,16}/,"number.hex"],[/\d+/,"number"],[/[;,.]/,"delimiter"],[/'([^'\\]|\\.)*$/,"string.invalid"],[/'/,"string","@string"],[/'[^\\']'/,"string"],[/'/,"string.invalid"],[/\#\d+/,"string"]],comment:[[/[^\*\}]+/,"comment"],[/\}/,"comment","@pop"],[/[\{]/,"comment"]],string:[[/[^\\']+/,"string"],[/\\./,"string.escape.invalid"],[/'/,{token:"string.quote",bracket:"@close",next:"@pop"}]],whitespace:[[/[ \t\r\n]+/,"white"],[/\{/,"comment","@comment"],[/\/\/.*$/,"comment"]]}}},4407:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>r,language:()=>i});var r={comments:{lineComment:"//",blockComment:["/*","*/"]},brackets:[["[","]"],["(",")"],["{","}"]],autoClosingPairs:[{open:'"',close:'"',notIn:["string","comment","identifier"]},{open:"[",close:"]",notIn:["string","comment","identifier"]},{open:"(",close:")",notIn:["string","comment","identifier"]},{open:"{",close:"}",notIn:["string","comment","identifier"]}]},i={defaultToken:"",tokenPostfix:".pq",ignoreCase:!1,brackets:[{open:"[",close:"]",token:"delimiter.square"},{open:"{",close:"}",token:"delimiter.brackets"},{open:"(",close:")",token:"delimiter.parenthesis"}],operatorKeywords:["and","not","or"],keywords:["as","each","else","error","false","if","in","is","let","meta","otherwise","section","shared","then","true","try","type"],constructors:["#binary","#date","#datetime","#datetimezone","#duration","#table","#time"],constants:["#infinity","#nan","#sections","#shared"],typeKeywords:["action","any","anynonnull","none","null","logical","number","time","date","datetime","datetimezone","duration","text","binary","list","record","table","function"],builtinFunctions:["Access.Database","Action.Return","Action.Sequence","Action.Try","ActiveDirectory.Domains","AdoDotNet.DataSource","AdoDotNet.Query","AdobeAnalytics.Cubes","AnalysisServices.Database","AnalysisServices.Databases","AzureStorage.BlobContents","AzureStorage.Blobs","AzureStorage.Tables","Binary.Buffer","Binary.Combine","Binary.Compress","Binary.Decompress","Binary.End","Binary.From","Binary.FromList","Binary.FromText","Binary.InferContentType","Binary.Length","Binary.ToList","Binary.ToText","BinaryFormat.7BitEncodedSignedInteger","BinaryFormat.7BitEncodedUnsignedInteger","BinaryFormat.Binary","BinaryFormat.Byte","BinaryFormat.ByteOrder","BinaryFormat.Choice","BinaryFormat.Decimal","BinaryFormat.Double","BinaryFormat.Group","BinaryFormat.Length","BinaryFormat.List","BinaryFormat.Null","BinaryFormat.Record","BinaryFormat.SignedInteger16","BinaryFormat.SignedInteger32","BinaryFormat.SignedInteger64","BinaryFormat.Single","BinaryFormat.Text","BinaryFormat.Transform","BinaryFormat.UnsignedInteger16","BinaryFormat.UnsignedInteger32","BinaryFormat.UnsignedInteger64","Byte.From","Character.FromNumber","Character.ToNumber","Combiner.CombineTextByDelimiter","Combiner.CombineTextByEachDelimiter","Combiner.CombineTextByLengths","Combiner.CombineTextByPositions","Combiner.CombineTextByRanges","Comparer.Equals","Comparer.FromCulture","Comparer.Ordinal","Comparer.OrdinalIgnoreCase","Csv.Document","Cube.AddAndExpandDimensionColumn","Cube.AddMeasureColumn","Cube.ApplyParameter","Cube.AttributeMemberId","Cube.AttributeMemberProperty","Cube.CollapseAndRemoveColumns","Cube.Dimensions","Cube.DisplayFolders","Cube.Measures","Cube.Parameters","Cube.Properties","Cube.PropertyKey","Cube.ReplaceDimensions","Cube.Transform","Currency.From","DB2.Database","Date.AddDays","Date.AddMonths","Date.AddQuarters","Date.AddWeeks","Date.AddYears","Date.Day","Date.DayOfWeek","Date.DayOfWeekName","Date.DayOfYear","Date.DaysInMonth","Date.EndOfDay","Date.EndOfMonth","Date.EndOfQuarter","Date.EndOfWeek","Date.EndOfYear","Date.From","Date.FromText","Date.IsInCurrentDay","Date.IsInCurrentMonth","Date.IsInCurrentQuarter","Date.IsInCurrentWeek","Date.IsInCurrentYear","Date.IsInNextDay","Date.IsInNextMonth","Date.IsInNextNDays","Date.IsInNextNMonths","Date.IsInNextNQuarters","Date.IsInNextNWeeks","Date.IsInNextNYears","Date.IsInNextQuarter","Date.IsInNextWeek","Date.IsInNextYear","Date.IsInPreviousDay","Date.IsInPreviousMonth","Date.IsInPreviousNDays","Date.IsInPreviousNMonths","Date.IsInPreviousNQuarters","Date.IsInPreviousNWeeks","Date.IsInPreviousNYears","Date.IsInPreviousQuarter","Date.IsInPreviousWeek","Date.IsInPreviousYear","Date.IsInYearToDate","Date.IsLeapYear","Date.Month","Date.MonthName","Date.QuarterOfYear","Date.StartOfDay","Date.StartOfMonth","Date.StartOfQuarter","Date.StartOfWeek","Date.StartOfYear","Date.ToRecord","Date.ToText","Date.WeekOfMonth","Date.WeekOfYear","Date.Year","DateTime.AddZone","DateTime.Date","DateTime.FixedLocalNow","DateTime.From","DateTime.FromFileTime","DateTime.FromText","DateTime.IsInCurrentHour","DateTime.IsInCurrentMinute","DateTime.IsInCurrentSecond","DateTime.IsInNextHour","DateTime.IsInNextMinute","DateTime.IsInNextNHours","DateTime.IsInNextNMinutes","DateTime.IsInNextNSeconds","DateTime.IsInNextSecond","DateTime.IsInPreviousHour","DateTime.IsInPreviousMinute","DateTime.IsInPreviousNHours","DateTime.IsInPreviousNMinutes","DateTime.IsInPreviousNSeconds","DateTime.IsInPreviousSecond","DateTime.LocalNow","DateTime.Time","DateTime.ToRecord","DateTime.ToText","DateTimeZone.FixedLocalNow","DateTimeZone.FixedUtcNow","DateTimeZone.From","DateTimeZone.FromFileTime","DateTimeZone.FromText","DateTimeZone.LocalNow","DateTimeZone.RemoveZone","DateTimeZone.SwitchZone","DateTimeZone.ToLocal","DateTimeZone.ToRecord","DateTimeZone.ToText","DateTimeZone.ToUtc","DateTimeZone.UtcNow","DateTimeZone.ZoneHours","DateTimeZone.ZoneMinutes","Decimal.From","Diagnostics.ActivityId","Diagnostics.Trace","DirectQueryCapabilities.From","Double.From","Duration.Days","Duration.From","Duration.FromText","Duration.Hours","Duration.Minutes","Duration.Seconds","Duration.ToRecord","Duration.ToText","Duration.TotalDays","Duration.TotalHours","Duration.TotalMinutes","Duration.TotalSeconds","Embedded.Value","Error.Record","Excel.CurrentWorkbook","Excel.Workbook","Exchange.Contents","Expression.Constant","Expression.Evaluate","Expression.Identifier","Facebook.Graph","File.Contents","Folder.Contents","Folder.Files","Function.From","Function.Invoke","Function.InvokeAfter","Function.IsDataSource","GoogleAnalytics.Accounts","Guid.From","HdInsight.Containers","HdInsight.Contents","HdInsight.Files","Hdfs.Contents","Hdfs.Files","Informix.Database","Int16.From","Int32.From","Int64.From","Int8.From","ItemExpression.From","Json.Document","Json.FromValue","Lines.FromBinary","Lines.FromText","Lines.ToBinary","Lines.ToText","List.Accumulate","List.AllTrue","List.Alternate","List.AnyTrue","List.Average","List.Buffer","List.Combine","List.Contains","List.ContainsAll","List.ContainsAny","List.Count","List.Covariance","List.DateTimeZones","List.DateTimes","List.Dates","List.Difference","List.Distinct","List.Durations","List.FindText","List.First","List.FirstN","List.Generate","List.InsertRange","List.Intersect","List.IsDistinct","List.IsEmpty","List.Last","List.LastN","List.MatchesAll","List.MatchesAny","List.Max","List.MaxN","List.Median","List.Min","List.MinN","List.Mode","List.Modes","List.NonNullCount","List.Numbers","List.PositionOf","List.PositionOfAny","List.Positions","List.Product","List.Random","List.Range","List.RemoveFirstN","List.RemoveItems","List.RemoveLastN","List.RemoveMatchingItems","List.RemoveNulls","List.RemoveRange","List.Repeat","List.ReplaceMatchingItems","List.ReplaceRange","List.ReplaceValue","List.Reverse","List.Select","List.Single","List.SingleOrDefault","List.Skip","List.Sort","List.StandardDeviation","List.Sum","List.Times","List.Transform","List.TransformMany","List.Union","List.Zip","Logical.From","Logical.FromText","Logical.ToText","MQ.Queue","MySQL.Database","Number.Abs","Number.Acos","Number.Asin","Number.Atan","Number.Atan2","Number.BitwiseAnd","Number.BitwiseNot","Number.BitwiseOr","Number.BitwiseShiftLeft","Number.BitwiseShiftRight","Number.BitwiseXor","Number.Combinations","Number.Cos","Number.Cosh","Number.Exp","Number.Factorial","Number.From","Number.FromText","Number.IntegerDivide","Number.IsEven","Number.IsNaN","Number.IsOdd","Number.Ln","Number.Log","Number.Log10","Number.Mod","Number.Permutations","Number.Power","Number.Random","Number.RandomBetween","Number.Round","Number.RoundAwayFromZero","Number.RoundDown","Number.RoundTowardZero","Number.RoundUp","Number.Sign","Number.Sin","Number.Sinh","Number.Sqrt","Number.Tan","Number.Tanh","Number.ToText","OData.Feed","Odbc.DataSource","Odbc.Query","OleDb.DataSource","OleDb.Query","Oracle.Database","Percentage.From","PostgreSQL.Database","RData.FromBinary","Record.AddField","Record.Combine","Record.Field","Record.FieldCount","Record.FieldNames","Record.FieldOrDefault","Record.FieldValues","Record.FromList","Record.FromTable","Record.HasFields","Record.RemoveFields","Record.RenameFields","Record.ReorderFields","Record.SelectFields","Record.ToList","Record.ToTable","Record.TransformFields","Replacer.ReplaceText","Replacer.ReplaceValue","RowExpression.Column","RowExpression.From","Salesforce.Data","Salesforce.Reports","SapBusinessWarehouse.Cubes","SapHana.Database","SharePoint.Contents","SharePoint.Files","SharePoint.Tables","Single.From","Soda.Feed","Splitter.SplitByNothing","Splitter.SplitTextByAnyDelimiter","Splitter.SplitTextByDelimiter","Splitter.SplitTextByEachDelimiter","Splitter.SplitTextByLengths","Splitter.SplitTextByPositions","Splitter.SplitTextByRanges","Splitter.SplitTextByRepeatedLengths","Splitter.SplitTextByWhitespace","Sql.Database","Sql.Databases","SqlExpression.SchemaFrom","SqlExpression.ToExpression","Sybase.Database","Table.AddColumn","Table.AddIndexColumn","Table.AddJoinColumn","Table.AddKey","Table.AggregateTableColumn","Table.AlternateRows","Table.Buffer","Table.Column","Table.ColumnCount","Table.ColumnNames","Table.ColumnsOfType","Table.Combine","Table.CombineColumns","Table.Contains","Table.ContainsAll","Table.ContainsAny","Table.DemoteHeaders","Table.Distinct","Table.DuplicateColumn","Table.ExpandListColumn","Table.ExpandRecordColumn","Table.ExpandTableColumn","Table.FillDown","Table.FillUp","Table.FilterWithDataTable","Table.FindText","Table.First","Table.FirstN","Table.FirstValue","Table.FromColumns","Table.FromList","Table.FromPartitions","Table.FromRecords","Table.FromRows","Table.FromValue","Table.Group","Table.HasColumns","Table.InsertRows","Table.IsDistinct","Table.IsEmpty","Table.Join","Table.Keys","Table.Last","Table.LastN","Table.MatchesAllRows","Table.MatchesAnyRows","Table.Max","Table.MaxN","Table.Min","Table.MinN","Table.NestedJoin","Table.Partition","Table.PartitionValues","Table.Pivot","Table.PositionOf","Table.PositionOfAny","Table.PrefixColumns","Table.Profile","Table.PromoteHeaders","Table.Range","Table.RemoveColumns","Table.RemoveFirstN","Table.RemoveLastN","Table.RemoveMatchingRows","Table.RemoveRows","Table.RemoveRowsWithErrors","Table.RenameColumns","Table.ReorderColumns","Table.Repeat","Table.ReplaceErrorValues","Table.ReplaceKeys","Table.ReplaceMatchingRows","Table.ReplaceRelationshipIdentity","Table.ReplaceRows","Table.ReplaceValue","Table.ReverseRows","Table.RowCount","Table.Schema","Table.SelectColumns","Table.SelectRows","Table.SelectRowsWithErrors","Table.SingleRow","Table.Skip","Table.Sort","Table.SplitColumn","Table.ToColumns","Table.ToList","Table.ToRecords","Table.ToRows","Table.TransformColumnNames","Table.TransformColumnTypes","Table.TransformColumns","Table.TransformRows","Table.Transpose","Table.Unpivot","Table.UnpivotOtherColumns","Table.View","Table.ViewFunction","TableAction.DeleteRows","TableAction.InsertRows","TableAction.UpdateRows","Tables.GetRelationships","Teradata.Database","Text.AfterDelimiter","Text.At","Text.BeforeDelimiter","Text.BetweenDelimiters","Text.Clean","Text.Combine","Text.Contains","Text.End","Text.EndsWith","Text.Format","Text.From","Text.FromBinary","Text.Insert","Text.Length","Text.Lower","Text.Middle","Text.NewGuid","Text.PadEnd","Text.PadStart","Text.PositionOf","Text.PositionOfAny","Text.Proper","Text.Range","Text.Remove","Text.RemoveRange","Text.Repeat","Text.Replace","Text.ReplaceRange","Text.Select","Text.Split","Text.SplitAny","Text.Start","Text.StartsWith","Text.ToBinary","Text.ToList","Text.Trim","Text.TrimEnd","Text.TrimStart","Text.Upper","Time.EndOfHour","Time.From","Time.FromText","Time.Hour","Time.Minute","Time.Second","Time.StartOfHour","Time.ToRecord","Time.ToText","Type.AddTableKey","Type.ClosedRecord","Type.Facets","Type.ForFunction","Type.ForRecord","Type.FunctionParameters","Type.FunctionRequiredParameters","Type.FunctionReturn","Type.Is","Type.IsNullable","Type.IsOpenRecord","Type.ListItem","Type.NonNullable","Type.OpenRecord","Type.RecordFields","Type.ReplaceFacets","Type.ReplaceTableKeys","Type.TableColumn","Type.TableKeys","Type.TableRow","Type.TableSchema","Type.Union","Uri.BuildQueryString","Uri.Combine","Uri.EscapeDataString","Uri.Parts","Value.Add","Value.As","Value.Compare","Value.Divide","Value.Equals","Value.Firewall","Value.FromText","Value.Is","Value.Metadata","Value.Multiply","Value.NativeQuery","Value.NullableEquals","Value.RemoveMetadata","Value.ReplaceMetadata","Value.ReplaceType","Value.Subtract","Value.Type","ValueAction.NativeStatement","ValueAction.Replace","Variable.Value","Web.Contents","Web.Page","WebAction.Request","Xml.Document","Xml.Tables"],builtinConstants:["BinaryEncoding.Base64","BinaryEncoding.Hex","BinaryOccurrence.Optional","BinaryOccurrence.Repeating","BinaryOccurrence.Required","ByteOrder.BigEndian","ByteOrder.LittleEndian","Compression.Deflate","Compression.GZip","CsvStyle.QuoteAfterDelimiter","CsvStyle.QuoteAlways","Culture.Current","Day.Friday","Day.Monday","Day.Saturday","Day.Sunday","Day.Thursday","Day.Tuesday","Day.Wednesday","ExtraValues.Error","ExtraValues.Ignore","ExtraValues.List","GroupKind.Global","GroupKind.Local","JoinAlgorithm.Dynamic","JoinAlgorithm.LeftHash","JoinAlgorithm.LeftIndex","JoinAlgorithm.PairwiseHash","JoinAlgorithm.RightHash","JoinAlgorithm.RightIndex","JoinAlgorithm.SortMerge","JoinKind.FullOuter","JoinKind.Inner","JoinKind.LeftAnti","JoinKind.LeftOuter","JoinKind.RightAnti","JoinKind.RightOuter","JoinSide.Left","JoinSide.Right","MissingField.Error","MissingField.Ignore","MissingField.UseNull","Number.E","Number.Epsilon","Number.NaN","Number.NegativeInfinity","Number.PI","Number.PositiveInfinity","Occurrence.All","Occurrence.First","Occurrence.Last","Occurrence.Optional","Occurrence.Repeating","Occurrence.Required","Order.Ascending","Order.Descending","Precision.Decimal","Precision.Double","QuoteStyle.Csv","QuoteStyle.None","RelativePosition.FromEnd","RelativePosition.FromStart","RoundingMode.AwayFromZero","RoundingMode.Down","RoundingMode.ToEven","RoundingMode.TowardZero","RoundingMode.Up","SapHanaDistribution.All","SapHanaDistribution.Connection","SapHanaDistribution.Off","SapHanaDistribution.Statement","SapHanaRangeOperator.Equals","SapHanaRangeOperator.GreaterThan","SapHanaRangeOperator.GreaterThanOrEquals","SapHanaRangeOperator.LessThan","SapHanaRangeOperator.LessThanOrEquals","SapHanaRangeOperator.NotEquals","TextEncoding.Ascii","TextEncoding.BigEndianUnicode","TextEncoding.Unicode","TextEncoding.Utf16","TextEncoding.Utf8","TextEncoding.Windows","TraceLevel.Critical","TraceLevel.Error","TraceLevel.Information","TraceLevel.Verbose","TraceLevel.Warning","WebMethod.Delete","WebMethod.Get","WebMethod.Head","WebMethod.Patch","WebMethod.Post","WebMethod.Put"],builtinTypes:["Action.Type","Any.Type","Binary.Type","BinaryEncoding.Type","BinaryOccurrence.Type","Byte.Type","ByteOrder.Type","Character.Type","Compression.Type","CsvStyle.Type","Currency.Type","Date.Type","DateTime.Type","DateTimeZone.Type","Day.Type","Decimal.Type","Double.Type","Duration.Type","ExtraValues.Type","Function.Type","GroupKind.Type","Guid.Type","Int16.Type","Int32.Type","Int64.Type","Int8.Type","JoinAlgorithm.Type","JoinKind.Type","JoinSide.Type","List.Type","Logical.Type","MissingField.Type","None.Type","Null.Type","Number.Type","Occurrence.Type","Order.Type","Password.Type","Percentage.Type","Precision.Type","QuoteStyle.Type","Record.Type","RelativePosition.Type","RoundingMode.Type","SapHanaDistribution.Type","SapHanaRangeOperator.Type","Single.Type","Table.Type","Text.Type","TextEncoding.Type","Time.Type","TraceLevel.Type","Type.Type","Uri.Type","WebMethod.Type"],tokenizer:{root:[[/#"[\w \.]+"/,"identifier.quote"],[/\d*\.\d+([eE][\-+]?\d+)?/,"number.float"],[/0[xX][0-9a-fA-F]+/,"number.hex"],[/\d+([eE][\-+]?\d+)?/,"number"],[/(#?[a-z]+)\b/,{cases:{"@typeKeywords":"type","@keywords":"keyword","@constants":"constant","@constructors":"constructor","@operatorKeywords":"operators","@default":"identifier"}}],[/\b([A-Z][a-zA-Z0-9]+\.Type)\b/,{cases:{"@builtinTypes":"type","@default":"identifier"}}],[/\b([A-Z][a-zA-Z0-9]+\.[A-Z][a-zA-Z0-9]+)\b/,{cases:{"@builtinFunctions":"keyword.function","@builtinConstants":"constant","@default":"identifier"}}],[/\b([a-zA-Z_][\w\.]*)\b/,"identifier"],{include:"@whitespace"},{include:"@comments"},{include:"@strings"},[/[{}()\[\]]/,"@brackets"],[/([=\+<>\-\*&@\?\/!])|([<>]=)|(<>)|(=>)|(\.\.\.)|(\.\.)/,"operators"],[/[,;]/,"delimiter"]],whitespace:[[/\s+/,"white"]],comments:[["\\/\\*","comment","@comment"],["\\/\\/+.*","comment"]],comment:[["\\*\\/","comment","@pop"],[".","comment"]],strings:[['"',"string","@string"]],string:[['""',"string.escape"],['"',"string","@pop"],[".","string"]]}}},7287:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>o});var r=t(9587),i={comments:{lineComment:"#",blockComment:["'''","'''"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"',notIn:["string"]},{open:"'",close:"'",notIn:["string","comment"]}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],onEnterRules:[{beforeText:new RegExp("^\\s*(?:def|class|for|if|elif|else|while|try|with|finally|except|async).*?:\\s*$"),action:{indentAction:r.Mj.IndentAction.Indent}}],folding:{offSide:!0,markers:{start:new RegExp("^\\s*#region\\b"),end:new RegExp("^\\s*#endregion\\b")}}},o={defaultToken:"",tokenPostfix:".python",keywords:["False","None","True","and","as","assert","async","await","break","class","continue","def","del","elif","else","except","exec","finally","for","from","global","if","import","in","is","lambda","nonlocal","not","or","pass","print","raise","return","try","while","with","yield","int","float","long","complex","hex","abs","all","any","apply","basestring","bin","bool","buffer","bytearray","callable","chr","classmethod","cmp","coerce","compile","complex","delattr","dict","dir","divmod","enumerate","eval","execfile","file","filter","format","frozenset","getattr","globals","hasattr","hash","help","id","input","intern","isinstance","issubclass","iter","len","locals","list","map","max","memoryview","min","next","object","oct","open","ord","pow","print","property","reversed","range","raw_input","reduce","reload","repr","reversed","round","self","set","setattr","slice","sorted","staticmethod","str","sum","super","tuple","type","unichr","unicode","vars","xrange","zip","__dict__","__methods__","__members__","__class__","__bases__","__name__","__mro__","__subclasses__","__init__","__import__"],brackets:[{open:"{",close:"}",token:"delimiter.curly"},{open:"[",close:"]",token:"delimiter.bracket"},{open:"(",close:")",token:"delimiter.parenthesis"}],tokenizer:{root:[{include:"@whitespace"},{include:"@numbers"},{include:"@strings"},[/[,:;]/,"delimiter"],[/[{}\[\]()]/,"@brackets"],[/@[a-zA-Z_]\w*/,"tag"],[/[a-zA-Z_]\w*/,{cases:{"@keywords":"keyword","@default":"identifier"}}]],whitespace:[[/\s+/,"white"],[/(^#.*$)/,"comment"],[/'''/,"string","@endDocString"],[/"""/,"string","@endDblDocString"]],endDocString:[[/[^']+/,"string"],[/\\'/,"string"],[/'''/,"string","@popall"],[/'/,"string"]],endDblDocString:[[/[^"]+/,"string"],[/\\"/,"string"],[/"""/,"string","@popall"],[/"/,"string"]],numbers:[[/-?0x([abcdef]|[ABCDEF]|\d)+[lL]?/,"number.hex"],[/-?(\d*\.)?\d+([eE][+\-]?\d+)?[jJ]?[lL]?/,"number"]],strings:[[/'$/,"string.escape","@popall"],[/'/,"string.escape","@stringBody"],[/"$/,"string.escape","@popall"],[/"/,"string.escape","@dblStringBody"]],stringBody:[[/[^\\']+$/,"string","@popall"],[/[^\\']+/,"string"],[/\\./,"string"],[/'/,"string.escape","@popall"],[/\\$/,"string"]],dblStringBody:[[/[^\\"]+$/,"string","@popall"],[/[^\\"]+/,"string"],[/\\./,"string"],[/"/,"string.escape","@popall"],[/\\$/,"string"]]}}},9400:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>r,language:()=>i});var r={comments:{lineComment:"//"},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"',notIn:["string","comment"]}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'}]},i={keywords:["namespace","open","as","operation","function","body","adjoint","newtype","controlled","if","elif","else","repeat","until","fixup","for","in","while","return","fail","within","apply","Adjoint","Controlled","Adj","Ctl","is","self","auto","distribute","invert","intrinsic","let","set","w/","new","not","and","or","use","borrow","using","borrowing","mutable"],typeKeywords:["Unit","Int","BigInt","Double","Bool","String","Qubit","Result","Pauli","Range"],invalidKeywords:["abstract","base","bool","break","byte","case","catch","char","checked","class","const","continue","decimal","default","delegate","do","double","enum","event","explicit","extern","finally","fixed","float","foreach","goto","implicit","int","interface","lock","long","null","object","operator","out","override","params","private","protected","public","readonly","ref","sbyte","sealed","short","sizeof","stackalloc","static","string","struct","switch","this","throw","try","typeof","unit","ulong","unchecked","unsafe","ushort","virtual","void","volatile"],constants:["true","false","PauliI","PauliX","PauliY","PauliZ","One","Zero"],builtin:["X","Y","Z","H","HY","S","T","SWAP","CNOT","CCNOT","MultiX","R","RFrac","Rx","Ry","Rz","R1","R1Frac","Exp","ExpFrac","Measure","M","MultiM","Message","Length","Assert","AssertProb","AssertEqual"],operators:["and=","<-","->","*","*=","@","!","^","^=",":","::","..","==","...","=","=>",">",">=","<","<=","-","-=","!=","or=","%","%=","|","+","+=","?","/","/=","&&&","&&&=","^^^","^^^=",">>>",">>>=","<<<","<<<=","|||","|||=","~~~","_","w/","w/="],namespaceFollows:["namespace","open"],symbols:/[=><!~?:&|+\-*\/\^%@._]+/,escapes:/\\[\s\S]/,tokenizer:{root:[[/[a-zA-Z_$][\w$]*/,{cases:{"@namespaceFollows":{token:"keyword.$0",next:"@namespace"},"@typeKeywords":"type","@keywords":"keyword","@constants":"constant","@builtin":"keyword","@invalidKeywords":"invalid","@default":"identifier"}}],{include:"@whitespace"},[/[{}()\[\]]/,"@brackets"],[/@symbols/,{cases:{"@operators":"operator","@default":""}}],[/\d*\.\d+([eE][\-+]?\d+)?/,"number.float"],[/\d+/,"number"],[/[;,.]/,"delimiter"],[/"/,{token:"string.quote",bracket:"@open",next:"@string"}]],string:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/"/,{token:"string.quote",bracket:"@close",next:"@pop"}]],namespace:[{include:"@whitespace"},[/[A-Za-z]\w*/,"namespace"],[/[\.=]/,"delimiter"],["","","@pop"]],whitespace:[[/[ \t\r\n]+/,"white"],[/(\/\/).*/,"comment"]]}}},2140:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>r,language:()=>i});var r={comments:{lineComment:"#"},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'}]},i={defaultToken:"",tokenPostfix:".r",roxygen:["@alias","@aliases","@assignee","@author","@backref","@callGraph","@callGraphDepth","@callGraphPrimitives","@concept","@describeIn","@description","@details","@docType","@encoding","@evalNamespace","@evalRd","@example","@examples","@export","@exportClass","@exportMethod","@exportPattern","@family","@field","@formals","@format","@import","@importClassesFrom","@importFrom","@importMethodsFrom","@include","@inherit","@inheritDotParams","@inheritParams","@inheritSection","@keywords","@md","@method","@name","@noMd","@noRd","@note","@param","@rawNamespace","@rawRd","@rdname","@references","@return","@S3method","@section","@seealso","@setClass","@slot","@source","@template","@templateVar","@title","@TODO","@usage","@useDynLib"],constants:["NULL","FALSE","TRUE","NA","Inf","NaN","NA_integer_","NA_real_","NA_complex_","NA_character_","T","F","LETTERS","letters","month.abb","month.name","pi","R.version.string"],keywords:["break","next","return","if","else","for","in","repeat","while","array","category","character","complex","double","function","integer","list","logical","matrix","numeric","vector","data.frame","factor","library","require","attach","detach","source"],special:["\\n","\\r","\\t","\\b","\\a","\\f","\\v","\\'",'\\"',"\\\\"],brackets:[{open:"{",close:"}",token:"delimiter.curly"},{open:"[",close:"]",token:"delimiter.bracket"},{open:"(",close:")",token:"delimiter.parenthesis"}],tokenizer:{root:[{include:"@numbers"},{include:"@strings"},[/[{}\[\]()]/,"@brackets"],{include:"@operators"},[/#'$/,"comment.doc"],[/#'/,"comment.doc","@roxygen"],[/(^#.*$)/,"comment"],[/\s+/,"white"],[/[,:;]/,"delimiter"],[/@[a-zA-Z]\w*/,"tag"],[/[a-zA-Z]\w*/,{cases:{"@keywords":"keyword","@constants":"constant","@default":"identifier"}}]],roxygen:[[/@\w+/,{cases:{"@roxygen":"tag","@eos":{token:"comment.doc",next:"@pop"},"@default":"comment.doc"}}],[/\s+/,{cases:{"@eos":{token:"comment.doc",next:"@pop"},"@default":"comment.doc"}}],[/.*/,{token:"comment.doc",next:"@pop"}]],numbers:[[/0[xX][0-9a-fA-F]+/,"number.hex"],[/-?(\d*\.)?\d+([eE][+\-]?\d+)?/,"number"]],operators:[[/<{1,2}-/,"operator"],[/->{1,2}/,"operator"],[/%[^%\s]+%/,"operator"],[/\*\*/,"operator"],[/%%/,"operator"],[/&&/,"operator"],[/\|\|/,"operator"],[/<</,"operator"],[/>>/,"operator"],[/[-+=&|!<>^~*/:$]/,"operator"]],strings:[[/'/,"string.escape","@stringBody"],[/"/,"string.escape","@dblStringBody"]],stringBody:[[/\\./,{cases:{"@special":"string","@default":"error-token"}}],[/'/,"string.escape","@popall"],[/./,"string"]],dblStringBody:[[/\\./,{cases:{"@special":"string","@default":"error-token"}}],[/"/,"string.escape","@popall"],[/./,"string"]]}}},1065:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>r,language:()=>i});var r={brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:"<",close:">",notIn:["string"]}],surroundingPairs:[{open:"(",close:")"},{open:"[",close:"]"},{open:"`",close:"`"}],folding:{markers:{start:new RegExp("^\\s*\x3c!--\\s*#?region\\b.*--\x3e"),end:new RegExp("^\\s*\x3c!--\\s*#?endregion\\b.*--\x3e")}}},i={defaultToken:"",tokenPostfix:".rst",control:/[\\`*_\[\]{}()#+\-\.!]/,escapes:/\\(?:@control)/,empty:["area","base","basefont","br","col","frame","hr","img","input","isindex","link","meta","param"],alphanumerics:/[A-Za-z0-9]/,simpleRefNameWithoutBq:/(?:@alphanumerics[-_+:.]*@alphanumerics)+|(?:@alphanumerics+)/,simpleRefName:/(?:`@phrase`|@simpleRefNameWithoutBq)/,phrase:/@simpleRefNameWithoutBq(?:\s@simpleRefNameWithoutBq)*/,citationName:/[A-Za-z][A-Za-z0-9-_.]*/,blockLiteralStart:/(?:[!"#$%&'()*+,-./:;<=>?@\[\]^_`{|}~]|[\s])/,precedingChars:/(?:[ -:/'"<([{])/,followingChars:/(?:[ -.,:;!?/'")\]}>]|$)/,punctuation:/(=|-|~|`|#|"|\^|\+|\*|:|\.|'|_|\+)/,tokenizer:{root:[[/^(@punctuation{3,}$){1,1}?/,"keyword"],[/^\s*([\*\-+‣•]|[a-zA-Z0-9]+\.|\([a-zA-Z0-9]+\)|[a-zA-Z0-9]+\))\s/,"keyword"],[/([ ]::)\s*$/,"keyword","@blankLineOfLiteralBlocks"],[/(::)\s*$/,"keyword","@blankLineOfLiteralBlocks"],{include:"@tables"},{include:"@explicitMarkupBlocks"},{include:"@inlineMarkup"}],explicitMarkupBlocks:[{include:"@citations"},{include:"@footnotes"},[/^(\.\.\s)(@simpleRefName)(::\s)(.*)$/,[{token:"",next:"subsequentLines"},"keyword","",""]],[/^(\.\.)(\s+)(_)(@simpleRefName)(:)(\s+)(.*)/,[{token:"",next:"hyperlinks"},"","","string.link","","","string.link"]],[/^((?:(?:\.\.)(?:\s+))?)(__)(:)(\s+)(.*)/,[{token:"",next:"subsequentLines"},"","","","string.link"]],[/^(__\s+)(.+)/,["","string.link"]],[/^(\.\.)( \|)([^| ]+[^|]*[^| ]*)(\| )(@simpleRefName)(:: .*)/,[{token:"",next:"subsequentLines"},"","string.link","","keyword",""],"@rawBlocks"],[/(\|)([^| ]+[^|]*[^| ]*)(\|_{0,2})/,["","string.link",""]],[/^(\.\.)([ ].*)$/,[{token:"",next:"@comments"},"comment"]]],inlineMarkup:[{include:"@citationsReference"},{include:"@footnotesReference"},[/(@simpleRefName)(_{1,2})/,["string.link",""]],[/(`)([^<`]+\s+)(<)(.*)(>)(`)(_)/,["","string.link","","string.link","","",""]],[/\*\*([^\\*]|\*(?!\*))+\*\*/,"strong"],[/\*[^*]+\*/,"emphasis"],[/(``)((?:[^`]|\`(?!`))+)(``)/,["","keyword",""]],[/(__\s+)(.+)/,["","keyword"]],[/(:)((?:@simpleRefNameWithoutBq)?)(:`)([^`]+)(`)/,["","keyword","","",""]],[/(`)([^`]+)(`:)((?:@simpleRefNameWithoutBq)?)(:)/,["","","","keyword",""]],[/(`)([^`]+)(`)/,""],[/(_`)(@phrase)(`)/,["","string.link",""]]],citations:[[/^(\.\.\s+\[)((?:@citationName))(\]\s+)(.*)/,[{token:"",next:"@subsequentLines"},"string.link","",""]]],citationsReference:[[/(\[)(@citationName)(\]_)/,["","string.link",""]]],footnotes:[[/^(\.\.\s+\[)((?:[0-9]+))(\]\s+.*)/,[{token:"",next:"@subsequentLines"},"string.link",""]],[/^(\.\.\s+\[)((?:#@simpleRefName?))(\]\s+)(.*)/,[{token:"",next:"@subsequentLines"},"string.link","",""]],[/^(\.\.\s+\[)((?:\*))(\]\s+)(.*)/,[{token:"",next:"@subsequentLines"},"string.link","",""]]],footnotesReference:[[/(\[)([0-9]+)(\])(_)/,["","string.link","",""]],[/(\[)(#@simpleRefName?)(\])(_)/,["","string.link","",""]],[/(\[)(\*)(\])(_)/,["","string.link","",""]]],blankLineOfLiteralBlocks:[[/^$/,"","@subsequentLinesOfLiteralBlocks"],[/^.*$/,"","@pop"]],subsequentLinesOfLiteralBlocks:[[/(@blockLiteralStart+)(.*)/,["keyword",""]],[/^(?!blockLiteralStart)/,"","@popall"]],subsequentLines:[[/^[\s]+.*/,""],[/^(?!\s)/,"","@pop"]],hyperlinks:[[/^[\s]+.*/,"string.link"],[/^(?!\s)/,"","@pop"]],comments:[[/^[\s]+.*/,"comment"],[/^(?!\s)/,"","@pop"]],tables:[[/\+-[+-]+/,"keyword"],[/\+=[+=]+/,"keyword"]]}}},180:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>r,language:()=>i});var r={wordPattern:/(unary_[@~!#%^&*()\-=+\\|:<>\/?]+)|([a-zA-Z_$][\w$]*?_=)|(`[^`]+`)|([a-zA-Z_$][\w$]*)/g,comments:{lineComment:"//",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],folding:{markers:{start:new RegExp("^\\s*//\\s*(?:(?:#?region\\b)|(?:<editor-fold\\b))"),end:new RegExp("^\\s*//\\s*(?:(?:#?endregion\\b)|(?:</editor-fold>))")}}},i={tokenPostfix:".scala",keywords:["asInstanceOf","catch","class","classOf","def","do","else","extends","finally","for","foreach","forSome","if","import","isInstanceOf","macro","match","new","object","package","return","throw","trait","try","type","until","val","var","while","with","yield","given","enum","then"],softKeywords:["as","export","extension","end","derives","on"],constants:["true","false","null","this","super"],modifiers:["abstract","final","implicit","lazy","override","private","protected","sealed"],softModifiers:["inline","opaque","open","transparent","using"],name:/(?:[a-z_$][\w$]*|`[^`]+`)/,type:/(?:[A-Z][\w$]*)/,symbols:/[=><!~?:&|+\-*\/^\\%@#]+/,digits:/\d+(_+\d+)*/,hexdigits:/[[0-9a-fA-F]+(_+[0-9a-fA-F]+)*/,escapes:/\\(?:[btnfr\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,fstring_conv:/[bBhHsScCdoxXeEfgGaAt]|[Tn](?:[HIklMSLNpzZsQ]|[BbhAaCYyjmde]|[RTrDFC])/,tokenizer:{root:[[/\braw"""/,{token:"string.quote",bracket:"@open",next:"@rawstringt"}],[/\braw"/,{token:"string.quote",bracket:"@open",next:"@rawstring"}],[/\bs"""/,{token:"string.quote",bracket:"@open",next:"@sstringt"}],[/\bs"/,{token:"string.quote",bracket:"@open",next:"@sstring"}],[/\bf""""/,{token:"string.quote",bracket:"@open",next:"@fstringt"}],[/\bf"/,{token:"string.quote",bracket:"@open",next:"@fstring"}],[/"""/,{token:"string.quote",bracket:"@open",next:"@stringt"}],[/"/,{token:"string.quote",bracket:"@open",next:"@string"}],[/(@digits)[eE]([\-+]?(@digits))?[fFdD]?/,"number.float","@allowMethod"],[/(@digits)\.(@digits)([eE][\-+]?(@digits))?[fFdD]?/,"number.float","@allowMethod"],[/0[xX](@hexdigits)[Ll]?/,"number.hex","@allowMethod"],[/(@digits)[fFdD]/,"number.float","@allowMethod"],[/(@digits)[lL]?/,"number","@allowMethod"],[/\b_\*/,"key"],[/\b(_)\b/,"keyword","@allowMethod"],[/\bimport\b/,"keyword","@import"],[/\b(case)([ \t]+)(class)\b/,["keyword.modifier","white","keyword"]],[/\bcase\b/,"keyword","@case"],[/\bva[lr]\b/,"keyword","@vardef"],[/\b(def)([ \t]+)((?:unary_)?@symbols|@name(?:_=)|@name)/,["keyword","white","identifier"]],[/@name(?=[ \t]*:(?!:))/,"variable"],[/(\.)(@name|@symbols)/,["operator",{token:"@rematch",next:"@allowMethod"}]],[/([{(])(\s*)(@name(?=\s*=>))/,["@brackets","white","variable"]],[/@name/,{cases:{"@keywords":"keyword","@softKeywords":"keyword","@modifiers":"keyword.modifier","@softModifiers":"keyword.modifier","@constants":{token:"constant",next:"@allowMethod"},"@default":{token:"identifier",next:"@allowMethod"}}}],[/@type/,"type","@allowMethod"],{include:"@whitespace"},[/@[a-zA-Z_$][\w$]*(?:\.[a-zA-Z_$][\w$]*)*/,"annotation"],[/[{(]/,"@brackets"],[/[})]/,"@brackets","@allowMethod"],[/\[/,"operator.square"],[/](?!\s*(?:va[rl]|def|type)\b)/,"operator.square","@allowMethod"],[/]/,"operator.square"],[/([=-]>|<-|>:|<:|:>|<%)(?=[\s\w()[\]{},\."'`])/,"keyword"],[/@symbols/,"operator"],[/[;,\.]/,"delimiter"],[/'[a-zA-Z$][\w$]*(?!')/,"attribute.name"],[/'[^\\']'/,"string","@allowMethod"],[/(')(@escapes)(')/,["string","string.escape",{token:"string",next:"@allowMethod"}]],[/'/,"string.invalid"]],import:[[/;/,"delimiter","@pop"],[/^|$/,"","@pop"],[/[ \t]+/,"white"],[/[\n\r]+/,"white","@pop"],[/\/\*/,"comment","@comment"],[/@name|@type/,"type"],[/[(){}]/,"@brackets"],[/[[\]]/,"operator.square"],[/[\.,]/,"delimiter"]],allowMethod:[[/^|$/,"","@pop"],[/[ \t]+/,"white"],[/[\n\r]+/,"white","@pop"],[/\/\*/,"comment","@comment"],[/(?==>[\s\w([{])/,"keyword","@pop"],[/(@name|@symbols)(?=[ \t]*[[({"'`]|[ \t]+(?:[+-]?\.?\d|\w))/,{cases:{"@keywords":{token:"keyword",next:"@pop"},"->|<-|>:|<:|<%":{token:"keyword",next:"@pop"},"@default":{token:"@rematch",next:"@pop"}}}],["","","@pop"]],comment:[[/[^\/*]+/,"comment"],[/\/\*/,"comment","@push"],[/\*\//,"comment","@pop"],[/[\/*]/,"comment"]],case:[[/\b_\*/,"key"],[/\b(_|true|false|null|this|super)\b/,"keyword","@allowMethod"],[/\bif\b|=>/,"keyword","@pop"],[/`[^`]+`/,"identifier","@allowMethod"],[/@name/,"variable","@allowMethod"],[/:::?|\||@(?![a-z_$])/,"keyword"],{include:"@root"}],vardef:[[/\b_\*/,"key"],[/\b(_|true|false|null|this|super)\b/,"keyword"],[/@name/,"variable"],[/:::?|\||@(?![a-z_$])/,"keyword"],[/=|:(?!:)/,"operator","@pop"],[/$/,"white","@pop"],{include:"@root"}],string:[[/[^\\"\n\r]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,{token:"string.quote",bracket:"@close",switchTo:"@allowMethod"}]],stringt:[[/[^\\"\n\r]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"(?=""")/,"string"],[/"""/,{token:"string.quote",bracket:"@close",switchTo:"@allowMethod"}],[/"/,"string"]],fstring:[[/@escapes/,"string.escape"],[/"/,{token:"string.quote",bracket:"@close",switchTo:"@allowMethod"}],[/\$\$/,"string"],[/(\$)([a-z_]\w*)/,["operator","identifier"]],[/\$\{/,"operator","@interp"],[/%%/,"string"],[/(%)([\-#+ 0,(])(\d+|\.\d+|\d+\.\d+)(@fstring_conv)/,["metatag","keyword.modifier","number","metatag"]],[/(%)(\d+|\.\d+|\d+\.\d+)(@fstring_conv)/,["metatag","number","metatag"]],[/(%)([\-#+ 0,(])(@fstring_conv)/,["metatag","keyword.modifier","metatag"]],[/(%)(@fstring_conv)/,["metatag","metatag"]],[/./,"string"]],fstringt:[[/@escapes/,"string.escape"],[/"(?=""")/,"string"],[/"""/,{token:"string.quote",bracket:"@close",switchTo:"@allowMethod"}],[/\$\$/,"string"],[/(\$)([a-z_]\w*)/,["operator","identifier"]],[/\$\{/,"operator","@interp"],[/%%/,"string"],[/(%)([\-#+ 0,(])(\d+|\.\d+|\d+\.\d+)(@fstring_conv)/,["metatag","keyword.modifier","number","metatag"]],[/(%)(\d+|\.\d+|\d+\.\d+)(@fstring_conv)/,["metatag","number","metatag"]],[/(%)([\-#+ 0,(])(@fstring_conv)/,["metatag","keyword.modifier","metatag"]],[/(%)(@fstring_conv)/,["metatag","metatag"]],[/./,"string"]],sstring:[[/@escapes/,"string.escape"],[/"/,{token:"string.quote",bracket:"@close",switchTo:"@allowMethod"}],[/\$\$/,"string"],[/(\$)([a-z_]\w*)/,["operator","identifier"]],[/\$\{/,"operator","@interp"],[/./,"string"]],sstringt:[[/@escapes/,"string.escape"],[/"(?=""")/,"string"],[/"""/,{token:"string.quote",bracket:"@close",switchTo:"@allowMethod"}],[/\$\$/,"string"],[/(\$)([a-z_]\w*)/,["operator","identifier"]],[/\$\{/,"operator","@interp"],[/./,"string"]],interp:[[/{/,"operator","@push"],[/}/,"operator","@pop"],{include:"@root"}],rawstring:[[/[^"]/,"string"],[/"/,{token:"string.quote",bracket:"@close",switchTo:"@allowMethod"}]],rawstringt:[[/[^"]/,"string"],[/"(?=""")/,"string"],[/"""/,{token:"string.quote",bracket:"@close",switchTo:"@allowMethod"}],[/"/,"string"]],whitespace:[[/[ \t\r\n]+/,"white"],[/\/\*/,"comment","@comment"],[/\/\/.*$/,"comment"]]}}},2060:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>r,language:()=>i});var r={comments:{lineComment:";",blockComment:["#|","|#"]},brackets:[["(",")"],["{","}"],["[","]"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'}]},i={defaultToken:"",ignoreCase:!0,tokenPostfix:".scheme",brackets:[{open:"(",close:")",token:"delimiter.parenthesis"},{open:"{",close:"}",token:"delimiter.curly"},{open:"[",close:"]",token:"delimiter.square"}],keywords:["case","do","let","loop","if","else","when","cons","car","cdr","cond","lambda","lambda*","syntax-rules","format","set!","quote","eval","append","list","list?","member?","load"],constants:["#t","#f"],operators:["eq?","eqv?","equal?","and","or","not","null?"],tokenizer:{root:[[/#[xXoObB][0-9a-fA-F]+/,"number.hex"],[/[+-]?\d+(?:(?:\.\d*)?(?:[eE][+-]?\d+)?)?/,"number.float"],[/(?:\b(?:(define|define-syntax|define-macro))\b)(\s+)((?:\w|\-|\!|\?)*)/,["keyword","white","variable"]],{include:"@whitespace"},{include:"@strings"},[/[a-zA-Z_#][a-zA-Z0-9_\-\?\!\*]*/,{cases:{"@keywords":"keyword","@constants":"constant","@operators":"operators","@default":"identifier"}}]],comment:[[/[^\|#]+/,"comment"],[/#\|/,"comment","@push"],[/\|#/,"comment","@pop"],[/[\|#]/,"comment"]],whitespace:[[/[ \t\r\n]+/,"white"],[/#\|/,"comment","@comment"],[/;.*$/,"comment"]],strings:[[/"$/,"string","@popall"],[/"(?=.)/,"string","@multiLineString"]],multiLineString:[[/[^\\"]+$/,"string","@popall"],[/[^\\"]+/,"string"],[/\\./,"string.escape"],[/"/,"string","@popall"],[/\\$/,"string"]]}}},6587:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>r,language:()=>i});var r={comments:{lineComment:"//",blockComment:["(*","*)"]},brackets:[["{","}"],["[","]"],["(",")"],["var","end_var"],["var_input","end_var"],["var_output","end_var"],["var_in_out","end_var"],["var_temp","end_var"],["var_global","end_var"],["var_access","end_var"],["var_external","end_var"],["type","end_type"],["struct","end_struct"],["program","end_program"],["function","end_function"],["function_block","end_function_block"],["action","end_action"],["step","end_step"],["initial_step","end_step"],["transaction","end_transaction"],["configuration","end_configuration"],["tcp","end_tcp"],["recource","end_recource"],["channel","end_channel"],["library","end_library"],["folder","end_folder"],["binaries","end_binaries"],["includes","end_includes"],["sources","end_sources"]],autoClosingPairs:[{open:"[",close:"]"},{open:"{",close:"}"},{open:"(",close:")"},{open:"/*",close:"*/"},{open:"'",close:"'",notIn:["string_sq"]},{open:'"',close:'"',notIn:["string_dq"]},{open:"var_input",close:"end_var"},{open:"var_output",close:"end_var"},{open:"var_in_out",close:"end_var"},{open:"var_temp",close:"end_var"},{open:"var_global",close:"end_var"},{open:"var_access",close:"end_var"},{open:"var_external",close:"end_var"},{open:"type",close:"end_type"},{open:"struct",close:"end_struct"},{open:"program",close:"end_program"},{open:"function",close:"end_function"},{open:"function_block",close:"end_function_block"},{open:"action",close:"end_action"},{open:"step",close:"end_step"},{open:"initial_step",close:"end_step"},{open:"transaction",close:"end_transaction"},{open:"configuration",close:"end_configuration"},{open:"tcp",close:"end_tcp"},{open:"recource",close:"end_recource"},{open:"channel",close:"end_channel"},{open:"library",close:"end_library"},{open:"folder",close:"end_folder"},{open:"binaries",close:"end_binaries"},{open:"includes",close:"end_includes"},{open:"sources",close:"end_sources"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"},{open:"var",close:"end_var"},{open:"var_input",close:"end_var"},{open:"var_output",close:"end_var"},{open:"var_in_out",close:"end_var"},{open:"var_temp",close:"end_var"},{open:"var_global",close:"end_var"},{open:"var_access",close:"end_var"},{open:"var_external",close:"end_var"},{open:"type",close:"end_type"},{open:"struct",close:"end_struct"},{open:"program",close:"end_program"},{open:"function",close:"end_function"},{open:"function_block",close:"end_function_block"},{open:"action",close:"end_action"},{open:"step",close:"end_step"},{open:"initial_step",close:"end_step"},{open:"transaction",close:"end_transaction"},{open:"configuration",close:"end_configuration"},{open:"tcp",close:"end_tcp"},{open:"recource",close:"end_recource"},{open:"channel",close:"end_channel"},{open:"library",close:"end_library"},{open:"folder",close:"end_folder"},{open:"binaries",close:"end_binaries"},{open:"includes",close:"end_includes"},{open:"sources",close:"end_sources"}],folding:{markers:{start:new RegExp("^\\s*#pragma\\s+region\\b"),end:new RegExp("^\\s*#pragma\\s+endregion\\b")}}},i={defaultToken:"",tokenPostfix:".st",ignoreCase:!0,brackets:[{token:"delimiter.curly",open:"{",close:"}"},{token:"delimiter.parenthesis",open:"(",close:")"},{token:"delimiter.square",open:"[",close:"]"}],keywords:["if","end_if","elsif","else","case","of","to","__try","__catch","__finally","do","with","by","while","repeat","end_while","end_repeat","end_case","for","end_for","task","retain","non_retain","constant","with","at","exit","return","interval","priority","address","port","on_channel","then","iec","file","uses","version","packagetype","displayname","copyright","summary","vendor","common_source","from","extends"],constant:["false","true","null"],defineKeywords:["var","var_input","var_output","var_in_out","var_temp","var_global","var_access","var_external","end_var","type","end_type","struct","end_struct","program","end_program","function","end_function","function_block","end_function_block","interface","end_interface","method","end_method","property","end_property","namespace","end_namespace","configuration","end_configuration","tcp","end_tcp","resource","end_resource","channel","end_channel","library","end_library","folder","end_folder","binaries","end_binaries","includes","end_includes","sources","end_sources","action","end_action","step","initial_step","end_step","transaction","end_transaction"],typeKeywords:["int","sint","dint","lint","usint","uint","udint","ulint","real","lreal","time","date","time_of_day","date_and_time","string","bool","byte","word","dword","array","pointer","lword"],operators:["=",">","<",":",":=","<=",">=","<>","&","+","-","*","**","MOD","^","or","and","not","xor","abs","acos","asin","atan","cos","exp","expt","ln","log","sin","sqrt","tan","sel","max","min","limit","mux","shl","shr","rol","ror","indexof","sizeof","adr","adrinst","bitadr","is_valid","ref","ref_to"],builtinVariables:[],builtinFunctions:["sr","rs","tp","ton","tof","eq","ge","le","lt","ne","round","trunc","ctd","сtu","ctud","r_trig","f_trig","move","concat","delete","find","insert","left","len","replace","right","rtc"],symbols:/[=><!~?:&|+\-*\/\^%]+/,escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,tokenizer:{root:[[/(\.\.)/,"delimiter"],[/\b(16#[0-9A-Fa-f\_]*)+\b/,"number.hex"],[/\b(2#[01\_]+)+\b/,"number.binary"],[/\b(8#[0-9\_]*)+\b/,"number.octal"],[/\b\d*\.\d+([eE][\-+]?\d+)?\b/,"number.float"],[/\b(L?REAL)#[0-9\_\.e]+\b/,"number.float"],[/\b(BYTE|(?:D|L)?WORD|U?(?:S|D|L)?INT)#[0-9\_]+\b/,"number"],[/\d+/,"number"],[/\b(T|DT|TOD)#[0-9:-_shmyd]+\b/,"tag"],[/\%(I|Q|M)(X|B|W|D|L)[0-9\.]+/,"tag"],[/\%(I|Q|M)[0-9\.]*/,"tag"],[/\b[A-Za-z]{1,6}#[0-9]+\b/,"tag"],[/\b(TO_|CTU_|CTD_|CTUD_|MUX_|SEL_)[A_Za-z]+\b/,"predefined"],[/\b[A_Za-z]+(_TO_)[A_Za-z]+\b/,"predefined"],[/[;]/,"delimiter"],[/[.]/,{token:"delimiter",next:"@params"}],[/[a-zA-Z_]\w*/,{cases:{"@operators":"operators","@keywords":"keyword","@typeKeywords":"type","@defineKeywords":"variable","@constant":"constant","@builtinVariables":"predefined","@builtinFunctions":"predefined","@default":"identifier"}}],{include:"@whitespace"},[/[{}()\[\]]/,"@brackets"],[/"([^"\\]|\\.)*$/,"string.invalid"],[/"/,{token:"string.quote",bracket:"@open",next:"@string_dq"}],[/'/,{token:"string.quote",bracket:"@open",next:"@string_sq"}],[/'[^\\']'/,"string"],[/(')(@escapes)(')/,["string","string.escape","string"]],[/'/,"string.invalid"]],params:[[/\b[A-Za-z0-9_]+\b(?=\()/,{token:"identifier",next:"@pop"}],[/\b[A-Za-z0-9_]+\b/,"variable.name","@pop"]],comment:[[/[^\/*]+/,"comment"],[/\/\*/,"comment","@push"],["\\*/","comment","@pop"],[/[\/*]/,"comment"]],comment2:[[/[^\(*]+/,"comment"],[/\(\*/,"comment","@push"],["\\*\\)","comment","@pop"],[/[\(*]/,"comment"]],whitespace:[[/[ \t\r\n]+/,"white"],[/\/\/.*$/,"comment"],[/\/\*/,"comment","@comment"],[/\(\*/,"comment","@comment2"]],string_dq:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,{token:"string.quote",bracket:"@close",next:"@pop"}]],string_sq:[[/[^\\']+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/'/,{token:"string.quote",bracket:"@close",next:"@pop"}]]}}},7637:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>r,language:()=>i});var r={brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}]},i={tokenPostfix:".tcl",specialFunctions:["set","unset","rename","variable","proc","coroutine","foreach","incr","append","lappend","linsert","lreplace"],mainFunctions:["if","then","elseif","else","case","switch","while","for","break","continue","return","package","namespace","catch","exit","eval","expr","uplevel","upvar"],builtinFunctions:["file","info","concat","join","lindex","list","llength","lrange","lsearch","lsort","split","array","parray","binary","format","regexp","regsub","scan","string","subst","dict","cd","clock","exec","glob","pid","pwd","close","eof","fblocked","fconfigure","fcopy","fileevent","flush","gets","open","puts","read","seek","socket","tell","interp","after","auto_execok","auto_load","auto_mkindex","auto_reset","bgerror","error","global","history","load","source","time","trace","unknown","unset","update","vwait","winfo","wm","bind","event","pack","place","grid","font","bell","clipboard","destroy","focus","grab","lower","option","raise","selection","send","tk","tkwait","tk_bisque","tk_focusNext","tk_focusPrev","tk_focusFollowsMouse","tk_popup","tk_setPalette"],symbols:/[=><!~?:&|+\-*\/\^%]+/,brackets:[{open:"(",close:")",token:"delimiter.parenthesis"},{open:"{",close:"}",token:"delimiter.curly"},{open:"[",close:"]",token:"delimiter.square"}],escapes:/\\(?:[abfnrtv\\"'\[\]\{\};\$]|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,variables:/(?:\$+(?:(?:\:\:?)?[a-zA-Z_]\w*)+)/,tokenizer:{root:[[/[a-zA-Z_]\w*/,{cases:{"@specialFunctions":{token:"keyword.flow",next:"@specialFunc"},"@mainFunctions":"keyword","@builtinFunctions":"variable","@default":"operator.scss"}}],[/\s+\-+(?!\d|\.)\w*|{\*}/,"metatag"],{include:"@whitespace"},[/[{}()\[\]]/,"@brackets"],[/@symbols/,"operator"],[/\$+(?:\:\:)?\{/,{token:"identifier",next:"@nestedVariable"}],[/@variables/,"type.identifier"],[/\.(?!\d|\.)[\w\-]*/,"operator.sql"],[/\d+(\.\d+)?/,"number"],[/\d+/,"number"],[/;/,"delimiter"],[/"/,{token:"string.quote",bracket:"@open",next:"@dstring"}],[/'/,{token:"string.quote",bracket:"@open",next:"@sstring"}]],dstring:[[/\[/,{token:"@brackets",next:"@nestedCall"}],[/\$+(?:\:\:)?\{/,{token:"identifier",next:"@nestedVariable"}],[/@variables/,"type.identifier"],[/[^\\$\[\]"]+/,"string"],[/@escapes/,"string.escape"],[/"/,{token:"string.quote",bracket:"@close",next:"@pop"}]],sstring:[[/\[/,{token:"@brackets",next:"@nestedCall"}],[/\$+(?:\:\:)?\{/,{token:"identifier",next:"@nestedVariable"}],[/@variables/,"type.identifier"],[/[^\\$\[\]']+/,"string"],[/@escapes/,"string.escape"],[/'/,{token:"string.quote",bracket:"@close",next:"@pop"}]],whitespace:[[/[ \t\r\n]+/,"white"],[/#.*\\$/,{token:"comment",next:"@newlineComment"}],[/#.*(?!\\)$/,"comment"]],newlineComment:[[/.*\\$/,"comment"],[/.*(?!\\)$/,{token:"comment",next:"@pop"}]],nestedVariable:[[/[^\{\}\$]+/,"type.identifier"],[/\}/,{token:"identifier",next:"@pop"}]],nestedCall:[[/\[/,{token:"@brackets",next:"@nestedCall"}],[/\]/,{token:"@brackets",next:"@pop"}],{include:"root"}],specialFunc:[[/"/,{token:"string",next:"@dstring"}],[/'/,{token:"string",next:"@sstring"}],[/\S+/,{token:"type",next:"@pop"}]]}}},8424:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>r,language:()=>i});var r={wordPattern:/(-?\d*\.\d\w*)|([^\`\~\!\@\$\^\&\*\(\)\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\s]+)/g,comments:{blockComment:["{#","#}"]},brackets:[["{#","#}"],["{%","%}"],["{{","}}"],["(",")"],["[","]"],["\x3c!--","--\x3e"],["<",">"]],autoClosingPairs:[{open:"{# ",close:" #}"},{open:"{% ",close:" %}"},{open:"{{ ",close:" }}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:'"',close:'"'},{open:"'",close:"'"},{open:"<",close:">"}]},i={defaultToken:"",tokenPostfix:"",ignoreCase:!0,keywords:["apply","autoescape","block","deprecated","do","embed","extends","flush","for","from","if","import","include","macro","sandbox","set","use","verbatim","with","endapply","endautoescape","endblock","endembed","endfor","endif","endmacro","endsandbox","endset","endwith","true","false"],tokenizer:{root:[[/\s+/],[/{#/,"comment.twig","@commentState"],[/{%[-~]?/,"delimiter.twig","@blockState"],[/{{[-~]?/,"delimiter.twig","@variableState"],[/<!DOCTYPE/,"metatag.html","@doctype"],[/<!--/,"comment.html","@comment"],[/(<)((?:[\w\-]+:)?[\w\-]+)(\s*)(\/>)/,["delimiter.html","tag.html","","delimiter.html"]],[/(<)(script)/,["delimiter.html",{token:"tag.html",next:"@script"}]],[/(<)(style)/,["delimiter.html",{token:"tag.html",next:"@style"}]],[/(<)((?:[\w\-]+:)?[\w\-]+)/,["delimiter.html",{token:"tag.html",next:"@otherTag"}]],[/(<\/)((?:[\w\-]+:)?[\w\-]+)/,["delimiter.html",{token:"tag.html",next:"@otherTag"}]],[/</,"delimiter.html"],[/[^<]+/]],commentState:[[/#}/,"comment.twig","@pop"],[/./,"comment.twig"]],blockState:[[/[-~]?%}/,"delimiter.twig","@pop"],[/\s+/],[/(verbatim)(\s*)([-~]?%})/,["keyword.twig","",{token:"delimiter.twig",next:"@rawDataState"}]],{include:"expression"}],rawDataState:[[/({%[-~]?)(\s*)(endverbatim)(\s*)([-~]?%})/,["delimiter.twig","","keyword.twig","",{token:"delimiter.twig",next:"@popall"}]],[/./,"string.twig"]],variableState:[[/[-~]?}}/,"delimiter.twig","@pop"],{include:"expression"}],stringState:[[/"/,"string.twig","@pop"],[/#{\s*/,"string.twig","@interpolationState"],[/[^#"\\]*(?:(?:\\.|#(?!\{))[^#"\\]*)*/,"string.twig"]],interpolationState:[[/}/,"string.twig","@pop"],{include:"expression"}],expression:[[/\s+/],[/\+|-|\/{1,2}|%|\*{1,2}/,"operators.twig"],[/(and|or|not|b-and|b-xor|b-or)(\s+)/,["operators.twig",""]],[/==|!=|<|>|>=|<=/,"operators.twig"],[/(starts with|ends with|matches)(\s+)/,["operators.twig",""]],[/(in)(\s+)/,["operators.twig",""]],[/(is)(\s+)/,["operators.twig",""]],[/\||~|:|\.{1,2}|\?{1,2}/,"operators.twig"],[/[^\W\d][\w]*/,{cases:{"@keywords":"keyword.twig","@default":"variable.twig"}}],[/\d+(\.\d+)?/,"number.twig"],[/\(|\)|\[|\]|{|}|,/,"delimiter.twig"],[/"([^#"\\]*(?:\\.[^#"\\]*)*)"|\'([^\'\\]*(?:\\.[^\'\\]*)*)\'/,"string.twig"],[/"/,"string.twig","@stringState"],[/=>/,"operators.twig"],[/=/,"operators.twig"]],doctype:[[/[^>]+/,"metatag.content.html"],[/>/,"metatag.html","@pop"]],comment:[[/-->/,"comment.html","@pop"],[/[^-]+/,"comment.content.html"],[/./,"comment.content.html"]],otherTag:[[/\/?>/,"delimiter.html","@pop"],[/"([^"]*)"/,"attribute.value.html"],[/'([^']*)'/,"attribute.value.html"],[/[\w\-]+/,"attribute.name.html"],[/=/,"delimiter.html"],[/[ \t\r\n]+/]],script:[[/type/,"attribute.name.html","@scriptAfterType"],[/"([^"]*)"/,"attribute.value.html"],[/'([^']*)'/,"attribute.value.html"],[/[\w\-]+/,"attribute.name.html"],[/=/,"delimiter.html"],[/>/,{token:"delimiter.html",next:"@scriptEmbedded",nextEmbedded:"text/javascript"}],[/[ \t\r\n]+/],[/(<\/)(script\s*)(>)/,["delimiter.html","tag.html",{token:"delimiter.html",next:"@pop"}]]],scriptAfterType:[[/=/,"delimiter.html","@scriptAfterTypeEquals"],[/>/,{token:"delimiter.html",next:"@scriptEmbedded",nextEmbedded:"text/javascript"}],[/[ \t\r\n]+/],[/<\/script\s*>/,{token:"@rematch",next:"@pop"}]],scriptAfterTypeEquals:[[/"([^"]*)"/,{token:"attribute.value.html",switchTo:"@scriptWithCustomType.$1"}],[/'([^']*)'/,{token:"attribute.value.html",switchTo:"@scriptWithCustomType.$1"}],[/>/,{token:"delimiter.html",next:"@scriptEmbedded",nextEmbedded:"text/javascript"}],[/[ \t\r\n]+/],[/<\/script\s*>/,{token:"@rematch",next:"@pop"}]],scriptWithCustomType:[[/>/,{token:"delimiter.html",next:"@scriptEmbedded.$S2",nextEmbedded:"$S2"}],[/"([^"]*)"/,"attribute.value.html"],[/'([^']*)'/,"attribute.value.html"],[/[\w\-]+/,"attribute.name.html"],[/=/,"delimiter.html"],[/[ \t\r\n]+/],[/<\/script\s*>/,{token:"@rematch",next:"@pop"}]],scriptEmbedded:[[/<\/script/,{token:"@rematch",next:"@pop",nextEmbedded:"@pop"}],[/[^<]+/,""]],style:[[/type/,"attribute.name.html","@styleAfterType"],[/"([^"]*)"/,"attribute.value.html"],[/'([^']*)'/,"attribute.value.html"],[/[\w\-]+/,"attribute.name.html"],[/=/,"delimiter.html"],[/>/,{token:"delimiter.html",next:"@styleEmbedded",nextEmbedded:"text/css"}],[/[ \t\r\n]+/],[/(<\/)(style\s*)(>)/,["delimiter.html","tag.html",{token:"delimiter.html",next:"@pop"}]]],styleAfterType:[[/=/,"delimiter.html","@styleAfterTypeEquals"],[/>/,{token:"delimiter.html",next:"@styleEmbedded",nextEmbedded:"text/css"}],[/[ \t\r\n]+/],[/<\/style\s*>/,{token:"@rematch",next:"@pop"}]],styleAfterTypeEquals:[[/"([^"]*)"/,{token:"attribute.value.html",switchTo:"@styleWithCustomType.$1"}],[/'([^']*)'/,{token:"attribute.value.html",switchTo:"@styleWithCustomType.$1"}],[/>/,{token:"delimiter.html",next:"@styleEmbedded",nextEmbedded:"text/css"}],[/[ \t\r\n]+/],[/<\/style\s*>/,{token:"@rematch",next:"@pop"}]],styleWithCustomType:[[/>/,{token:"delimiter.html",next:"@styleEmbedded.$S2",nextEmbedded:"$S2"}],[/"([^"]*)"/,"attribute.value.html"],[/'([^']*)'/,"attribute.value.html"],[/[\w\-]+/,"attribute.name.html"],[/=/,"delimiter.html"],[/[ \t\r\n]+/],[/<\/style\s*>/,{token:"@rematch",next:"@pop"}]],styleEmbedded:[[/<\/style/,{token:"@rematch",next:"@pop",nextEmbedded:"@pop"}],[/[^<]+/,""]]}}},5566:(e,n,t)=>{t.r(n),t.d(n,{default:()=>r});const r='//// BitBuilder is a type used for efficiently concatenating bits to create bit\n//// strings.\n////\n//// If we append one bit string to another the bit strings must be copied to a\n//// new location in memory so that they can sit together. This behaviour\n//// enables efficient reading of the string but copying can be expensive,\n//// especially if we want to join many bit strings together.\n////\n//// BitBuilder is different in that it can be joined together in constant\n//// time using minimal memory, and then can be efficiently converted to a\n//// bit string using the `to_bit_string` function.\n////\n//// On Erlang this type is compatible with Erlang\'s iolists.\n\nimport gleam/string_builder.{StringBuilder}\nimport gleam/bit_string\nimport gleam/list\n\nif erlang {\n  pub external type BitBuilder\n}\n\nif javascript {\n  pub opaque type BitBuilder {\n    Bits(BitString)\n    Text(StringBuilder)\n    Many(List(BitBuilder))\n  }\n}\n\n/// Prepends a bit string to the start of a builder.\n///\n/// Runs in constant time.\n///\npub fn prepend(to: BitBuilder, prefix: BitString) -> BitBuilder {\n  append_builder(from_bit_string(prefix), to)\n}\n\n/// Appends a bit string to the end of a builder.\n///\n/// Runs in constant time.\n///\npub fn append(to: BitBuilder, suffix: BitString) -> BitBuilder {\n  append_builder(to, from_bit_string(suffix))\n}\n\n/// Prepends a builder onto the start of another.\n///\n/// Runs in constant time.\n///\npub fn prepend_builder(to: BitBuilder, prefix: BitBuilder) -> BitBuilder {\n  append_builder(prefix, to)\n}\n\n/// Appends a builder onto the end of another.\n///\n/// Runs in constant time.\n///\npub fn append_builder(\n  to first: BitBuilder,\n  suffix second: BitBuilder,\n) -> BitBuilder {\n  do_append_builder(first, second)\n}\n\nif erlang {\n  external fn do_append_builder(\n    to: BitBuilder,\n    suffix: BitBuilder,\n  ) -> BitBuilder =\n    "gleam_stdlib" "iodata_append"\n}\n\nif javascript {\n  fn do_append_builder(first: BitBuilder, second: BitBuilder) -> BitBuilder {\n    case second {\n      Many(builders) -> Many([first, ..builders])\n      _ -> Many([first, second])\n    }\n  }\n}\n\n/// Prepends a string onto the start of a builder.\n///\n/// Runs in constant time when running on Erlang.\n/// Runs in linear time with the length of the string otherwise.\n///\npub fn prepend_string(to: BitBuilder, prefix: String) -> BitBuilder {\n  append_builder(from_string(prefix), to)\n}\n\n/// Appends a string onto the end of a builder.\n///\n/// Runs in constant time when running on Erlang.\n/// Runs in linear time with the length of the string otherwise.\n///\npub fn append_string(to: BitBuilder, suffix: String) -> BitBuilder {\n  append_builder(to, from_string(suffix))\n}\n\n/// Joins a list of builders into a single builders.\n///\n/// Runs in constant time.\n///\npub fn concat(builders: List(BitBuilder)) -> BitBuilder {\n  do_concat(builders)\n}\n\nif erlang {\n  external fn do_concat(List(BitBuilder)) -> BitBuilder =\n    "gleam_stdlib" "identity"\n}\n\nif javascript {\n  fn do_concat(builders: List(BitBuilder)) -> BitBuilder {\n    Many(builders)\n  }\n}\n\n/// Creates a new builder from a string.\n///\n/// Runs in constant time when running on Erlang.\n/// Runs in linear time otherwise.\n///\npub fn from_string(string: String) -> BitBuilder {\n  do_from_string(string)\n}\n\nif erlang {\n  external fn do_from_string(String) -> BitBuilder =\n    "gleam_stdlib" "wrap_list"\n}\n\nif javascript {\n  fn do_from_string(string: String) -> BitBuilder {\n    Text(string_builder.from_string(string))\n  }\n}\n\n/// Creates a new builder from a string builder.\n///\n/// Runs in constant time when running on Erlang.\n/// Runs in linear time otherwise.\n///\npub fn from_string_builder(builder: StringBuilder) -> BitBuilder {\n  do_from_string_builder(builder)\n}\n\nif erlang {\n  external fn do_from_string_builder(StringBuilder) -> BitBuilder =\n    "gleam_stdlib" "identity"\n}\n\nif javascript {\n  fn do_from_string_builder(builder: StringBuilder) -> BitBuilder {\n    Text(builder)\n  }\n}\n\n/// Creates a new builder from a bit string.\n///\n/// Runs in constant time.\n///\npub fn from_bit_string(bits: BitString) -> BitBuilder {\n  do_from_bit_string(bits)\n}\n\nif erlang {\n  external fn do_from_bit_string(BitString) -> BitBuilder =\n    "gleam_stdlib" "wrap_list"\n}\n\nif javascript {\n  fn do_from_bit_string(bits: BitString) -> BitBuilder {\n    Bits(bits)\n  }\n}\n\n/// Turns an builder into a bit string.\n///\n/// Runs in linear time.\n///\n/// When running on Erlang this function is implemented natively by the\n/// virtual machine and is highly optimised.\n///\npub fn to_bit_string(builder: BitBuilder) -> BitString {\n  do_to_bit_string(builder)\n}\n\nif erlang {\n  external fn do_to_bit_string(BitBuilder) -> BitString =\n    "erlang" "list_to_bitstring"\n}\n\nif javascript {\n  fn do_to_bit_string(builder: BitBuilder) -> BitString {\n    [[builder]]\n    |> to_list([])\n    |> list.reverse\n    |> bit_string.concat\n  }\n\n  fn to_list(\n    stack: List(List(BitBuilder)),\n    acc: List(BitString),\n  ) -> List(BitString) {\n    case stack {\n      [] -> acc\n\n      [[], ..remaining_stack] -> to_list(remaining_stack, acc)\n\n      [[Bits(bits), ..rest], ..remaining_stack] ->\n        to_list([rest, ..remaining_stack], [bits, ..acc])\n\n      [[Text(builder), ..rest], ..remaining_stack] -> {\n        let bits = bit_string.from_string(string_builder.to_string(builder))\n        to_list([rest, ..remaining_stack], [bits, ..acc])\n      }\n\n      [[Many(builders), ..rest], ..remaining_stack] ->\n        to_list([builders, rest, ..remaining_stack], acc)\n    }\n  }\n}\n\n/// Returns the size of the builder\'s content in bytes.\n///\n/// Runs in linear time.\n///\npub fn byte_size(builder: BitBuilder) -> Int {\n  do_byte_size(builder)\n}\n\nif erlang {\n  external fn do_byte_size(BitBuilder) -> Int =\n    "erlang" "iolist_size"\n}\n\nif javascript {\n  fn do_byte_size(builder: BitBuilder) -> Int {\n    [[builder]]\n    |> to_list([])\n    |> list.fold(0, fn(acc, builder) { bit_string.byte_size(builder) + acc })\n  }\n}\n'},5548:(e,n,t)=>{t.r(n),t.d(n,{default:()=>r});const r='import gleam/result\nimport gleam/option.{Option}\nimport gleam/list\nimport gleam/pair\n\n/// A dictionary of keys and values.\n///\n/// Any type can be used for the keys and values of a map, but all the keys\n/// must be of the same type and all the values must be of the same type.\n///\n/// Each key can only be present in a map once.\n///\n/// Maps are not ordered in any way, and any unintentional ordering is not to\n/// be relied upon in your code as it may change in future versions of Erlang\n/// or Gleam.\n///\n/// See [the Erlang map module](https://erlang.org/doc/man/maps.html) for more\n/// information.\n///\npub external type Map(key, value)\n\n/// Determines the number of key-value pairs in the map.\n/// This function runs in constant time and does not need to iterate the map.\n///\n/// ## Examples\n///\n///    > new() |> size()\n///    0\n///\n///    > new() |> insert("key", "value") |> size()\n///    1\n///\n///\npub fn size(map: Map(k, v)) -> Int {\n  do_size(map)\n}\n\nif erlang {\n  external fn do_size(Map(k, v)) -> Int =\n    "maps" "size"\n}\n\nif javascript {\n  external fn do_size(Map(k, v)) -> Int =\n    "../gleam_stdlib.mjs" "map_size"\n}\n\n/// Converts the map to a list of 2-element tuples `#(key, value)`, one for\n/// each key-value pair in the map.\n///\n/// The tuples in the list have no specific order.\n///\n/// ## Examples\n///\n///    > new() |> to_list()\n///    []\n///\n///    > new() |> insert("key", 0) |> to_list()\n///    [#("key", 0)]\n///\npub fn to_list(map: Map(key, value)) -> List(#(key, value)) {\n  do_to_list(map)\n}\n\nif erlang {\n  external fn do_to_list(Map(key, value)) -> List(#(key, value)) =\n    "maps" "to_list"\n}\n\nif javascript {\n  external fn do_to_list(Map(key, value)) -> List(#(key, value)) =\n    "../gleam_stdlib.mjs" "map_to_list"\n}\n\n/// Converts a list of 2-element tuples `#(key, value)` to a map.\n///\n/// If two tuples have the same key the last one in the list will be the one\n/// that is present in the map.\n///\npub fn from_list(list: List(#(k, v))) -> Map(k, v) {\n  do_from_list(list)\n}\n\nif erlang {\n  external fn do_from_list(List(#(key, value))) -> Map(key, value) =\n    "maps" "from_list"\n}\n\nif javascript {\n  fn do_from_list(list: List(#(k, v))) -> Map(k, v) {\n    list.fold(list, new(), insert_pair)\n  }\n}\n\n/// Determines whether or not a value present in the map for a given key.\n///\n/// ## Examples\n///\n///    > new() |> insert("a", 0) |> has_key("a")\n///    True\n///\n///    > new() |> insert("a", 0) |> has_key("b")\n///    False\n///\npub fn has_key(map: Map(k, v), key: k) -> Bool {\n  do_has_key(key, map)\n}\n\nif erlang {\n  external fn do_has_key(key, Map(key, v)) -> Bool =\n    "maps" "is_key"\n}\n\nif javascript {\n  fn do_has_key(key: k, map: Map(k, v)) -> Bool {\n    get(map, key) != Error(Nil)\n  }\n}\n\n/// Creates a fresh map that contains no values.\n///\npub fn new() -> Map(key, value) {\n  do_new()\n}\n\nif erlang {\n  external fn do_new() -> Map(key, value) =\n    "maps" "new"\n}\n\nif javascript {\n  external fn do_new() -> Map(key, value) =\n    "../gleam_stdlib.mjs" "new_map"\n}\n\n/// Fetches a value from a map for a given key.\n///\n/// The map may not have a value for the key, so the value is wrapped in a\n/// `Result`.\n///\n/// ## Examples\n///\n///    > new() |> insert("a", 0) |> get("a")\n///    Ok(0)\n///\n///    > new() |> insert("a", 0) |> get("b")\n///    Error(Nil)\n///\npub fn get(from: Map(key, value), get: key) -> Result(value, Nil) {\n  do_get(from, get)\n}\n\nif erlang {\n  external fn do_get(Map(key, value), key) -> Result(value, Nil) =\n    "gleam_stdlib" "map_get"\n}\n\nif javascript {\n  external fn do_get(Map(key, value), key) -> Result(value, Nil) =\n    "../gleam_stdlib.mjs" "map_get"\n}\n\n/// Inserts a value into the map with the given key.\n///\n/// If the map already has a value for the given key then the value is\n/// replaced with the new value.\n///\n/// ## Examples\n///\n///    > new() |> insert("a", 0) |> to_list\n///    [#("a", 0)]\n///\n///    > new() |> insert("a", 0) |> insert("a", 5) |> to_list\n///    [#("a", 5)]\n///\npub fn insert(into map: Map(k, v), for key: k, insert value: v) -> Map(k, v) {\n  do_insert(key, value, map)\n}\n\nif erlang {\n  external fn do_insert(key, value, Map(key, value)) -> Map(key, value) =\n    "maps" "put"\n}\n\nif javascript {\n  external fn do_insert(key, value, Map(key, value)) -> Map(key, value) =\n    "../gleam_stdlib.mjs" "map_insert"\n}\n\n/// Updates all values in a given map by calling a given function on each key\n/// and value.\n///\n/// ## Examples\n///\n///    > [#(3, 3), #(2, 4)]\n///    > |> from_list\n///    > |> map_values(fn(key, value) { key * value })\n///    [#(3, 9), #(2, 8)]\n///\n///\npub fn map_values(in map: Map(k, v), with fun: fn(k, v) -> w) -> Map(k, w) {\n  do_map_values(fun, map)\n}\n\nif erlang {\n  external fn do_map_values(fn(key, value) -> b, Map(key, value)) -> Map(key, b) =\n    "maps" "map"\n}\n\nif javascript {\n  fn do_map_values(f: fn(key, value) -> b, map: Map(key, value)) -> Map(key, b) {\n    let f = fn(map, k, v) { insert(map, k, f(k, v)) }\n    map\n    |> fold(from: new(), with: f)\n  }\n}\n\n/// Gets a list of all keys in a given map.\n///\n/// Maps are not ordered so the keys are not returned in any specific order. Do\n/// not write code that relies on the order keys are returned by this function\n/// as it may change in later versions of Gleam or Erlang.\n///\n/// ## Examples\n///\n///    > keys([#("a", 0), #("b", 1)])\n///    ["a", "b"]\n///\npub fn keys(map: Map(keys, v)) -> List(keys) {\n  do_keys(map)\n}\n\nif erlang {\n  external fn do_keys(Map(keys, v)) -> List(keys) =\n    "maps" "keys"\n}\n\nif javascript {\n  fn do_keys(map: Map(k, v)) -> List(k) {\n    map\n    |> to_list\n    |> list.map(pair.first)\n  }\n}\n\n/// Gets a list of all values in a given map.\n///\n/// Maps are not ordered so the values are not returned in any specific order. Do\n/// not write code that relies on the order values are returned by this function\n/// as it may change in later versions of Gleam or Erlang.\n///\n/// ## Examples\n///\n///    > keys(from_list([#("a", 0), #("b", 1)]))\n///    [0, 1]\n///\npub fn values(map: Map(k, values)) -> List(values) {\n  do_values(map)\n}\n\nif erlang {\n  external fn do_values(Map(k, values)) -> List(values) =\n    "maps" "values"\n}\n\nif javascript {\n  fn do_values(map: Map(k, v)) -> List(v) {\n    map\n    |> to_list\n    |> list.map(pair.second)\n  }\n}\n\n/// Creates a new map from a given map, minus any entries that a given function\n/// returns `False` for.\n///\n/// ## Examples\n///\n///    > from_list([#("a", 0), #("b", 1)])\n///    > |> filter(fn(key, value) { value != 0 })\n///    from_list([#("b", 1)])\n///\n///    > from_list([#("a", 0), #("b", 1)])\n///    > |> filter(fn(key, value) { True })\n///    from_list([#("a", 0), #("b", 1)])\n///\npub fn filter(in map: Map(k, v), for property: fn(k, v) -> Bool) -> Map(k, v) {\n  do_filter(property, map)\n}\n\nif erlang {\n  external fn do_filter(\n    fn(key, value) -> Bool,\n    Map(key, value),\n  ) -> Map(key, value) =\n    "maps" "filter"\n}\n\nif javascript {\n  fn do_filter(\n    f: fn(key, value) -> Bool,\n    map: Map(key, value),\n  ) -> Map(key, value) {\n    let insert = fn(map, k, v) {\n      case f(k, v) {\n        True -> insert(map, k, v)\n        _ -> map\n      }\n    }\n    map\n    |> fold(from: new(), with: insert)\n  }\n}\n\n/// Creates a new map from a given map, only including any entries for which the\n/// keys are in a given list.\n///\n/// ## Examples\n///\n///    > from_list([#("a", 0), #("b", 1)])\n///    > |> take(["b"])\n///    from_list([#("b", 1)])\n///\n///    > from_list([#("a", 0), #("b", 1)])\n///    > |> take(["a", "b", "c"])\n///    from_list([#("a", 0), #("b", 1)])\n///\npub fn take(from map: Map(k, v), keeping desired_keys: List(k)) -> Map(k, v) {\n  do_take(desired_keys, map)\n}\n\nif erlang {\n  external fn do_take(List(k), Map(k, v)) -> Map(k, v) =\n    "maps" "with"\n}\n\nif javascript {\n  fn do_take(desired_keys: List(k), map: Map(k, v)) -> Map(k, v) {\n    let insert = fn(taken, key) {\n      case get(map, key) {\n        Ok(value) -> insert(taken, key, value)\n        _ -> taken\n      }\n    }\n    list.fold(over: desired_keys, from: new(), with: insert)\n  }\n}\n\n/// Creates a new map from a pair of given maps by combining their entries.\n///\n/// If there are entries with the same keys in both maps the entry from the\n/// second map takes precedence.\n///\n/// ## Examples\n///\n///    > let a = from_list([#("a", 0), #("b", 1)])\n///    > let b = from_list([#("b", 2), #("c", 3)])\n///    > merge(a, b)\n///    from_list([#("a", 0), #("b", 2), #("c", 3)])\n///\npub fn merge(into map: Map(k, v), from new_entries: Map(k, v)) -> Map(k, v) {\n  do_merge(map, new_entries)\n}\n\nif erlang {\n  external fn do_merge(Map(k, v), Map(k, v)) -> Map(k, v) =\n    "maps" "merge"\n}\n\nif javascript {\n  fn insert_pair(map: Map(k, v), pair: #(k, v)) -> Map(k, v) {\n    insert(map, pair.0, pair.1)\n  }\n\n  fn do_merge(map: Map(k, v), new_entries: Map(k, v)) -> Map(k, v) {\n    new_entries\n    |> to_list\n    |> list.fold(map, insert_pair)\n  }\n}\n\n/// Creates a new map from a given map with all the same entries except for the\n/// one with a given key, if it exists.\n///\n/// ## Examples\n///\n///    > delete([#("a", 0), #("b", 1)], "a")\n///    from_list([#("b", 1)])\n///\n///    > delete([#("a", 0), #("b", 1)], "c")\n///    from_list([#("a", 0), #("b", 1)])\n///\npub fn delete(from map: Map(k, v), delete key: k) -> Map(k, v) {\n  do_delete(key, map)\n}\n\nif erlang {\n  external fn do_delete(k, Map(k, v)) -> Map(k, v) =\n    "maps" "remove"\n}\n\nif javascript {\n  external fn do_delete(k, Map(k, v)) -> Map(k, v) =\n    "../gleam_stdlib.mjs" "map_remove"\n}\n\n/// Creates a new map from a given map with all the same entries except any with\n/// keys found in a given list.\n///\n/// ## Examples\n///\n///    > drop([#("a", 0), #("b", 1)], ["a"])\n///    from_list([#("b", 2)])\n///\n///    > delete([#("a", 0), #("b", 1)], ["c"])\n///    from_list([#("a", 0), #("b", 1)])\n///\n///    > drop([#("a", 0), #("b", 1)], ["a", "b", "c"])\n///    from_list([])\n///\npub fn drop(from map: Map(k, v), drop disallowed_keys: List(k)) -> Map(k, v) {\n  list.fold(over: disallowed_keys, from: map, with: delete)\n}\n\n/// Creates a new map with one entry updated using a given function.\n///\n/// If there was not an entry in the map for the given key then the function\n/// gets `None` as its argument, otherwise it gets `Some(value)`.\n///\n/// ## Example\n///\n///    > let increment = fn(x) {\n///    >   case x {\n///    >     Some(i) -> i + 1\n///    >     None -> 0\n///    >   }\n///    > }\n///    > let map = from_list([#("a", 0)])\n///    >\n///    > update(map, "a" increment)\n///    from_list([#("a", 1)])\n///\n///    > update(map, "b" increment)\n///    from_list([#("a", 0), #("b", 0)])\n///\npub fn update(\n  in map: Map(k, v),\n  update key: k,\n  with fun: fn(Option(v)) -> v,\n) -> Map(k, v) {\n  map\n  |> get(key)\n  |> option.from_result\n  |> fun\n  |> insert(map, key, _)\n}\n\nfn do_fold(list: List(#(k, v)), initial: acc, fun: fn(acc, k, v) -> acc) -> acc {\n  case list {\n    [] -> initial\n    [#(k, v), ..tail] -> do_fold(tail, fun(initial, k, v), fun)\n  }\n}\n\n/// Combines all entries into a single value by calling a given function on each\n/// one.\n///\n/// Maps are not ordered so the values are not returned in any specific order. Do\n/// not write code that relies on the order entries are used by this function\n/// as it may change in later versions of Gleam or Erlang.\n///\n/// # Examples\n///\n///    > let map = from_list([#("a", 1), #("b", 3), #("c", 9)])\n///    > fold(map, 0, fn(accumulator, key, value) { accumulator + value })\n///    13\n///\n///    > import gleam/string.{append}\n///    > fold(map, "", fn(accumulator, key, value) { append(accumulator, key) })\n///    "abc"\n///\npub fn fold(\n  over map: Map(k, v),\n  from initial: acc,\n  with fun: fn(acc, k, v) -> acc,\n) -> acc {\n  map\n  |> to_list\n  |> do_fold(initial, fun)\n}\n'},4046:(e,n,t)=>{t.r(n),t.d(n,{default:()=>r});const r='import gleam/list\n\n/// `Option` represents a value that may be present or not. `Some` means the value is\n/// present, `None` means the value is not.\n///\n/// This is Gleam\'s alternative to having a value that could be Null, as is\n/// possible in some other languages.\n///\npub type Option(a) {\n  Some(a)\n  None\n}\n\n/// Combines a list of `Option`s into a single `Option`.\n/// If all elements in the list are `Some` then returns a `Some` holding the list of values.\n/// If any element is `None` then returns`None`.\n///\n/// ## Examples\n///\n/// ```\n///    > all([Some(1), Some(2)])\n///    Some([1, 2])\n///\n///    > all([Some(1), None])\n///    None\n/// ```\n///\npub fn all(list: List(Option(a))) -> Option(List(a)) {\n  list.fold_right(\n    list,\n    from: Some([]),\n    with: fn(acc, item) {\n      case acc, item {\n        Some(values), Some(value) -> Some([value, ..values])\n        _, _ -> None\n      }\n    },\n  )\n}\n\n/// Checks whether the `Option` is a `Some` value.\n///\n/// ## Examples\n///\n///    > is_some(Some(1))\n///    True\n///\n///    > is_some(None)\n///    False\n///\npub fn is_some(option: Option(a)) -> Bool {\n  option != None\n}\n\n/// Checks whether the `Option` is a `None` value.\n///\n/// ## Examples\n///\n///    > is_none(Some(1))\n///    False\n///\n///    > is_none(None)\n///    True\n///\npub fn is_none(option: Option(a)) -> Bool {\n  option == None\n}\n\n/// Converts an `Option` type to a `Result` type.\n///\n/// ## Examples\n///\n///    > to_result(Some(1), "some_error")\n///    Ok(1)\n///    > to_result(None, "some_error")\n///    Error("some_error")\n///\npub fn to_result(option: Option(a), e) -> Result(a, e) {\n  case option {\n    Some(a) -> Ok(a)\n    _ -> Error(e)\n  }\n}\n\n/// Converts a `Result` type to an `Option` type.\n///\n/// ## Examples\n///\n///    > from_result(Ok(1))\n///    Some(1)\n///    > from_result(Error("some_error"))\n///    None\n///\npub fn from_result(result: Result(a, e)) -> Option(a) {\n  case result {\n    Ok(a) -> Some(a)\n    _ -> None\n  }\n}\n\n/// Extracts the value from an `Option`, returning a default value if there is none.\n///\n/// ## Examples\n///\n///    > unwrap(Some(1), 0)\n///    1\n///\n///    > unwrap(None, 0)\n///    0\n///\npub fn unwrap(option: Option(a), or default: a) -> a {\n  case option {\n    Some(x) -> x\n    None -> default\n  }\n}\n\n/// Extracts the value from an `Option`, evaluating the default function if the option is `None`.\n///\n/// ## Examples\n///\n///    > lazy_unwrap(Some(1), fn() { 0 })\n///    1\n///\n///    > lazy_unwrap(None, fn() { 0 })\n///    0\n///\npub fn lazy_unwrap(option: Option(a), or default: fn() -> a) -> a {\n  case option {\n    Some(x) -> x\n    None -> default()\n  }\n}\n\n/// Updates a value held within the `Some` of an `Option` by calling a given function\n/// on it.\n///\n/// If the `Option` is a `None` rather than `Some`, the function is not called and the\n/// `Option` stays the same.\n///\n/// ## Examples\n///\n///    > map(over: Some(1), with: fn(x) { x + 1 })\n///    Some(2)\n///\n///    > map(over: None, with: fn(x) { x + 1 })\n///    None\n///\npub fn map(over option: Option(a), with fun: fn(a) -> b) -> Option(b) {\n  case option {\n    Some(x) -> Some(fun(x))\n    None -> None\n  }\n}\n\n/// Merges a nested `Option` into a single layer.\n///\n/// ## Examples\n///\n///    > flatten(Some(Some(1)))\n///    Some(1)\n///\n///    > flatten(Some(None))\n///    None\n///\n///    > flatten(None)\n///    None\n///\npub fn flatten(option: Option(Option(a))) -> Option(a) {\n  case option {\n    Some(x) -> x\n    None -> None\n  }\n}\n\n/// Updates a value held within the `Some` of an `Option` by calling a given function\n/// on it, where the given function also returns an `Option`. The two options are\n/// then merged together into one `Option`.\n///\n/// If the `Option` is a `None` rather than `Some` the function is not called and the\n/// option stays the same.\n///\n/// This function is the equivalent of calling `map` followed by `flatten`, and\n/// it is useful for chaining together multiple functions that return `Option`.\n///\n/// ## Examples\n///\n///    > then(Some(1), fn(x) { Some(x + 1) })\n///    Some(2)\n///\n///    > then(Some(1), fn(x) { Some(#("a", x)) })\n///    Some(#("a", 1))\n///\n///    > then(Some(1), fn(_) { None })\n///    None\n///\n///    > then(None, fn(x) { Some(x + 1) })\n///    None\n///\npub fn then(option: Option(a), apply fun: fn(a) -> Option(b)) -> Option(b) {\n  case option {\n    Some(x) -> fun(x)\n    None -> None\n  }\n}\n\n/// Returns the first value if it is `Some`, otherwise returns the second value.\n///\n/// ## Examples\n///\n///    > or(Some(1), Some(2))\n///    Some(1)\n///\n///    > or(Some(1), None)\n///    Some(1)\n///\n///    > or(None, Some(2))\n///    Some(2)\n///\n///    > or(None, None)\n///    None\n///\npub fn or(first: Option(a), second: Option(a)) -> Option(a) {\n  case first {\n    Some(_) -> first\n    None -> second\n  }\n}\n\n/// Returns the first value if it is `Some`, otherwise evaluates the given function for a fallback value.\n///\n/// ## Examples\n///\n///    > lazy_or(Some(1), fn() { Some(2) })\n///    Some(1)\n///\n///    > lazy_or(Some(1), fn() { None })\n///    Some(1)\n///\n///    > lazy_or(None, fn() { Some(2) })\n///    Some(2)\n///\n///    > lazy_or(None, fn() { None })\n///    None\n///\npub fn lazy_or(first: Option(a), second: fn() -> Option(a)) -> Option(a) {\n  case first {\n    Some(_) -> first\n    None -> second()\n  }\n}\n\n/// Given a list of `Option`s,\n/// returns only the values inside `Some`.\n///\n/// ## Examples\n///\n/// ```\n/// > values([Some(1), None, Some(3)])\n/// [1, 3]\n/// ```\n///\npub fn values(options: List(Option(a))) -> List(a) {\n  list.filter_map(options, fn(op) { to_result(op, "") })\n}\n'},4071:(e,n,t)=>{t.r(n),t.d(n,{default:()=>r});const r="/// Represents the result of a single comparison to determine the precise\n/// ordering of two values.\n///\npub type Order {\n  /// Less-than\n  Lt\n\n  /// Equal\n  Eq\n\n  /// Greater than\n  Gt\n}\n\n/// Inverts an order, so less-than becomes greater-than and greater-than\n/// becomes less-than.\n///\n/// ## Examples\n///\n///    > reverse(Lt)\n///    Gt\n///\n///    > reverse(Eq)\n///    Eq\n///\n///    > reverse(Lt)\n///    Gt\n///\npub fn reverse(order: Order) -> Order {\n  case order {\n    Lt -> Gt\n    Eq -> Eq\n    Gt -> Lt\n  }\n}\n\n/// Produces a numeric representation of the order.\n///\n/// ## Examples\n///\n///    > to_int(Lt)\n///    -1\n///\n///    > to_int(Eq)\n///    0\n///\n///    > to_int(Gt)\n///    1\n///\npub fn to_int(order: Order) -> Int {\n  case order {\n    Lt -> -1\n    Eq -> 0\n    Gt -> 1\n  }\n}\n\n/// Compares two `Order` values to one another, producing a new `Order`.\n///\n/// ## Examples\n///\n///    > compare(Eq, with: Lt)\n///    Gt\n///\npub fn compare(a: Order, with b: Order) -> Order {\n  case a, b {\n    x, y if x == y -> Eq\n    Lt, _ | Eq, Gt -> Lt\n    _, _ -> Gt\n  }\n}\n\n/// Returns the largest of two orders.\n///\n/// ## Examples\n///\n///    > max(Eq, Lt)\n///    Eq\n///\npub fn max(a: Order, b: Order) -> Order {\n  case a, b {\n    Gt, _ -> Gt\n    Eq, Lt -> Eq\n    _, _ -> b\n  }\n}\n\n/// Returns the smallest of two orders.\n///\n/// ## Examples\n///\n///    > min(Eq, Lt)\n///    Lt\n///\npub fn min(a: Order, b: Order) -> Order {\n  case a, b {\n    Lt, _ -> Lt\n    Eq, Gt -> Eq\n    _, _ -> b\n  }\n}\n"},517:(e,n,t)=>{t.r(n),t.d(n,{default:()=>r});const r="/// Returns the first element in a pair.\n///\n/// ## Examples\n///\n///    > first(#(1, 2))\n///    1\n///\npub fn first(pair: #(a, b)) -> a {\n  let #(a, _) = pair\n  a\n}\n\n/// Returns the second element in a pair.\n///\n/// ## Examples\n///\n///    > second(#(1, 2))\n///    2\n///\npub fn second(pair: #(a, b)) -> b {\n  let #(_, a) = pair\n  a\n}\n\n/// Returns a new pair with the elements swapped.\n///\n/// ## Examples\n///\n///    > swap(#(1, 2))\n///    #(2, 1)\n///\npub fn swap(pair: #(a, b)) -> #(b, a) {\n  let #(a, b) = pair\n  #(b, a)\n}\n\n/// Returns a new pair with the first element having had `with` applied to\n/// it.\n///\n/// ## Examples\n///\n///    > #(1, 2) |> map_first(fn(n) { n * 2 })\n///    #(2, 2)\n///\npub fn map_first(of pair: #(a, b), with fun: fn(a) -> c) -> #(c, b) {\n  let #(a, b) = pair\n  #(fun(a), b)\n}\n\n/// Returns a new pair with the second element having had `with` applied to\n/// it.\n///\n/// ## Examples\n///\n///    > #(1, 2) |> map_second(fn(n) { n * 2 })\n///    #(1, 4)\n///\npub fn map_second(of pair: #(a, b), with fun: fn(b) -> c) -> #(a, c) {\n  let #(a, b) = pair\n  #(a, fun(b))\n}\n"},1882:(e,n,t)=>{t.r(n),t.d(n,{default:()=>r});const r='//// Result represents the result of something that may succeed or not.\n//// `Ok` means it was successful, `Error` means it was not successful.\n\nimport gleam/list\n\n/// Checks whether the result is an `Ok` value.\n///\n/// ## Examples\n///\n///    > is_ok(Ok(1))\n///    True\n///\n///    > is_ok(Error(Nil))\n///    False\n///\npub fn is_ok(result: Result(a, e)) -> Bool {\n  case result {\n    Error(_) -> False\n    Ok(_) -> True\n  }\n}\n\n/// Checks whether the result is an `Error` value.\n///\n/// ## Examples\n///\n///    > is_error(Ok(1))\n///    False\n///\n///    > is_error(Error(Nil))\n///    True\n///\npub fn is_error(result: Result(a, e)) -> Bool {\n  case result {\n    Ok(_) -> False\n    Error(_) -> True\n  }\n}\n\n/// Updates a value held within the `Ok` of a result by calling a given function\n/// on it.\n///\n/// If the result is an `Error` rather than `Ok` the function is not called and the\n/// result stays the same.\n///\n/// ## Examples\n///\n///    > map(over: Ok(1), with: fn(x) { x + 1 })\n///    Ok(2)\n///\n///    > map(over: Error(1), with: fn(x) { x + 1 })\n///    Error(1)\n///\npub fn map(over result: Result(a, e), with fun: fn(a) -> b) -> Result(b, e) {\n  case result {\n    Ok(x) -> Ok(fun(x))\n    Error(e) -> Error(e)\n  }\n}\n\n/// Updates a value held within the `Error` of a result by calling a given function\n/// on it.\n///\n/// If the result is `Ok` rather than `Error` the function is not called and the\n/// result stays the same.\n///\n/// ## Examples\n///\n///    > map_error(over: Error(1), with: fn(x) { x + 1 })\n///    Error(2)\n///\n///    > map_error(over: Ok(1), with: fn(x) { x + 1 })\n///    Ok(1)\n///\npub fn map_error(\n  over result: Result(a, e),\n  with fun: fn(e) -> f,\n) -> Result(a, f) {\n  case result {\n    Ok(x) -> Ok(x)\n    Error(error) -> Error(fun(error))\n  }\n}\n\n/// Merges a nested `Result` into a single layer.\n///\n/// ## Examples\n///\n///    > flatten(Ok(Ok(1)))\n///    Ok(1)\n///\n///    > flatten(Ok(Error("")))\n///    Error("")\n///\n///    > flatten(Error(Nil))\n///    Error(Nil)\n///\npub fn flatten(result: Result(Result(a, e), e)) -> Result(a, e) {\n  case result {\n    Ok(x) -> x\n    Error(error) -> Error(error)\n  }\n}\n\n/// Updates a value held within the `Ok` of a result by calling a given function\n/// on it, where the given function also returns a result. The two results are\n/// then merged together into one result.\n///\n/// If the result is an `Error` rather than `Ok` the function is not called and the\n/// result stays the same.\n///\n/// This function is the equivalent of calling `map` followed by `flatten`, and\n/// it is useful for chaining together multiple functions that may fail.\n///\n/// ## Examples\n///\n///    > then(Ok(1), fn(x) { Ok(x + 1) })\n///    Ok(2)\n///\n///    > then(Ok(1), fn(x) { Ok(#("a", x)) })\n///    Ok(#("a", 1))\n///\n///    > then(Ok(1), fn(_) { Error("Oh no") })\n///    Error("Oh no")\n///\n///    > then(Error(Nil), fn(x) { Ok(x + 1) })\n///    Error(Nil)\n///\npub fn then(\n  result: Result(a, e),\n  apply fun: fn(a) -> Result(b, e),\n) -> Result(b, e) {\n  case result {\n    Ok(x) -> fun(x)\n    Error(e) -> Error(e)\n  }\n}\n\n/// Extracts the `Ok` value from a result, returning a default value if the result\n/// is an `Error`.\n///\n/// ## Examples\n///\n///    > unwrap(Ok(1), 0)\n///    1\n///\n///    > unwrap(Error(""), 0)\n///    0\n///\npub fn unwrap(result: Result(a, e), or default: a) -> a {\n  case result {\n    Ok(v) -> v\n    Error(_) -> default\n  }\n}\n\n/// Extracts the `Ok` value from a result, evaluating the default function if the result\n/// is an `Error`.\n///\n/// ## Examples\n///\n///    > lazy_unwrap(Ok(1), fn() { 0 })\n///    1\n///\n///    > lazy_unwrap(Error(""), fn() { 0 })\n///    0\n///\npub fn lazy_unwrap(result: Result(a, e), or default: fn() -> a) -> a {\n  case result {\n    Ok(v) -> v\n    Error(_) -> default()\n  }\n}\n\n/// Transforms any error into `Error(Nil)`.\n///\n/// ## Examples\n///\n///    > nil_error(Error(1))\n///    Error(Nil)\n///\n///    > nil_error(Ok(1))\n///    Ok(1)\n///\npub fn nil_error(result: Result(a, e)) -> Result(a, Nil) {\n  map_error(result, fn(_) { Nil })\n}\n\n/// Returns the first value if it is `Ok`, otherwise returns the second value.\n///\n/// ## Examples\n///\n///    > or(Ok(1), Ok(2))\n///    Ok(1)\n///\n///    > or(Ok(1), Error("Error 2"))\n///    Ok(1)\n///\n///    > or(Error("Error 1"), Ok(2))\n///    Ok(2)\n///\n///    > or(Error("Error 1"), Error("Error 2"))\n///    Error("Error 2")\n///\npub fn or(first: Result(a, e), second: Result(a, e)) -> Result(a, e) {\n  case first {\n    Ok(_) -> first\n    Error(_) -> second\n  }\n}\n\n/// Returns the first value if it is `Ok`, otherwise evaluates the given function for a fallback value.\n///\n/// ## Examples\n///\n///    > lazy_or(Ok(1), fn() { Ok(2) })\n///    Ok(1)\n///\n///    > lazy_or(Ok(1), fn() { Error("Error 2") })\n///    Ok(1)\n///\n///    > lazy_or(Error("Error 1"), fn() { Ok(2) })\n///    Ok(2)\n///\n///    > lazy_or(Error("Error 1"), fn() { Error("Error 2") })\n///    Error("Error 2")\n///\npub fn lazy_or(\n  first: Result(a, e),\n  second: fn() -> Result(a, e),\n) -> Result(a, e) {\n  case first {\n    Ok(_) -> first\n    Error(_) -> second()\n  }\n}\n\n/// Combines a list of results into a single result.\n/// If all elements in the list are `Ok` then returns an `Ok` holding the list of values.\n/// If any element is `Error` then returns the first error.\n///\n/// ## Examples\n///    > all([Ok(1), Ok(2)])\n///    Ok([1, 2])\n///\n///    > all([Ok(1), Error("e")])\n///    Error("e")\npub fn all(results: List(Result(a, e))) -> Result(List(a), e) {\n  list.try_map(results, fn(x) { x })\n}\n\npub fn replace_error(result: Result(a, e1), error: e2) -> Result(a, e2) {\n  result\n  |> map_error(fn(_) { error })\n}\n\n/// Given a list of results, returns only the values inside `Ok`.\n///\n/// ## Examples\n///\n/// ```\n/// > values([Ok(1), None, Ok(3)])\n/// [1, 3]\n/// ```\n///\npub fn values(results: List(Result(a, e))) -> List(a) {\n  list.filter_map(results, fn(r) { r })\n}\n'},8251:(e,n,t)=>{t.r(n),t.d(n,{default:()=>r});const r='//// Utilities for working with URIs\n////\n//// This module provides functions for working with URIs (for example, parsing\n//// URIs or encoding query strings). The functions in this module are implemented\n//// according to [RFC 3986](https://tools.ietf.org/html/rfc3986).\n////\n//// Query encoding (Form encoding) is defined in the w3c specification.\n//// https://www.w3.org/TR/html52/sec-forms.html#urlencoded-form-data\n\nimport gleam/function\nimport gleam/string_builder.{StringBuilder}\nimport gleam/int\nimport gleam/list\nimport gleam/map\nimport gleam/option.{None, Option, Some}\nimport gleam/pair\nimport gleam/regex\nimport gleam/result\nimport gleam/string\n\n/// Type representing holding the parsed components of an URI.\n/// All components of a URI are optional, except the path.\n///\npub type Uri {\n  Uri(\n    scheme: Option(String),\n    userinfo: Option(String),\n    host: Option(String),\n    port: Option(Int),\n    path: String,\n    query: Option(String),\n    fragment: Option(String),\n  )\n}\n\n/// Parses a compliant URI string into the `Uri` Type.\n/// If the string is not a valid URI string then an error is returned.\n///\n/// The opposite operation is `uri.to_string`\n///\n/// ## Examples\n///\n/// ```\n/// > parse("https://example.com:1234/a/b?query=true#fragment")\n///\n/// Ok(Uri(scheme: Some("https"), ...))\n/// ```\n///\npub fn parse(uri_string: String) -> Result(Uri, Nil) {\n  do_parse(uri_string)\n}\n\nif erlang {\n  external fn do_parse(String) -> Result(Uri, Nil) =\n    "gleam_stdlib" "uri_parse"\n}\n\nif javascript {\n  fn do_parse(uri_string: String) -> Result(Uri, Nil) {\n    // From https://tools.ietf.org/html/rfc3986#appendix-B\n    let pattern =\n      //    12                        3  4          5       6  7        8 \n      "^(([a-z][a-z0-9\\\\+\\\\-\\\\.]*):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#.*)?"\n    let matches =\n      pattern\n      |> regex_submatches(uri_string)\n      |> pad_list(8)\n\n    let #(scheme, authority, path, query, fragment) = case matches {\n      [\n        _scheme_with_colon,\n        scheme,\n        authority_with_slashes,\n        _authority,\n        path,\n        query_with_question_mark,\n        _query,\n        fragment,\n      ] -> #(\n        scheme,\n        authority_with_slashes,\n        path,\n        query_with_question_mark,\n        fragment,\n      )\n      _ -> #(None, None, None, None, None)\n    }\n\n    let scheme = noneify_empty_string(scheme)\n    let path = option.unwrap(path, "")\n    let query = noneify_query(query)\n    let #(userinfo, host, port) = split_authority(authority)\n    let fragment =\n      fragment\n      |> option.to_result(Nil)\n      |> result.then(string.pop_grapheme)\n      |> result.map(pair.second)\n      |> option.from_result\n    let scheme =\n      scheme\n      |> noneify_empty_string\n      |> option.map(string.lowercase)\n    Ok(Uri(\n      scheme: scheme,\n      userinfo: userinfo,\n      host: host,\n      port: port,\n      path: path,\n      query: query,\n      fragment: fragment,\n    ))\n  }\n\n  fn regex_submatches(pattern: String, string: String) -> List(Option(String)) {\n    pattern\n    |> regex.compile(regex.Options(case_insensitive: True, multi_line: False))\n    |> result.nil_error\n    |> result.map(regex.scan(_, string))\n    |> result.then(list.first)\n    |> result.map(fn(m: regex.Match) { m.submatches })\n    |> result.unwrap([])\n  }\n\n  fn noneify_query(x: Option(String)) -> Option(String) {\n    case x {\n      None -> None\n      Some(x) ->\n        case string.pop_grapheme(x) {\n          Ok(#("?", query)) -> Some(query)\n          _ -> None\n        }\n    }\n  }\n\n  fn noneify_empty_string(x: Option(String)) -> Option(String) {\n    case x {\n      Some("") | None -> None\n      Some(_) -> x\n    }\n  }\n\n  // Split an authority into its userinfo, host and port parts.\n  fn split_authority(\n    authority: Option(String),\n  ) -> #(Option(String), Option(String), Option(Int)) {\n    case option.unwrap(authority, "") {\n      "" -> #(None, None, None)\n      "//" -> #(None, Some(""), None)\n      authority -> {\n        let matches =\n          "^(//)?((.*)@)?(\\\\[[a-zA-Z0-9:.]*\\\\]|[^:]*)(:(\\\\d*))?"\n          |> regex_submatches(authority)\n          |> pad_list(6)\n        case matches {\n          [_, _, userinfo, host, _, port] -> {\n            let userinfo = noneify_empty_string(userinfo)\n            let host = noneify_empty_string(host)\n            let port =\n              port\n              |> option.unwrap("")\n              |> int.parse\n              |> option.from_result\n            #(userinfo, host, port)\n          }\n          _ -> #(None, None, None)\n        }\n      }\n    }\n  }\n\n  fn pad_list(list: List(Option(a)), size: Int) -> List(Option(a)) {\n    list\n    |> list.append(list.repeat(None, extra_required(list, size)))\n  }\n\n  fn extra_required(list: List(a), remaining: Int) -> Int {\n    case list {\n      _ if remaining == 0 -> 0\n      [] -> remaining\n      [_, ..xs] -> extra_required(xs, remaining - 1)\n    }\n  }\n}\n\n/// Parses an urlencoded query string into a list of key value pairs.\n/// Returns an error for invalid encoding.\n///\n/// The opposite operation is `uri.query_to_string`.\n///\n/// ## Examples\n///\n/// ```\n/// > parse_query("a=1&b=2")\n///\n/// Ok([#("a", "1"), #("b", "2")])\n/// ```\n///\npub fn parse_query(query: String) -> Result(List(#(String, String)), Nil) {\n  do_parse_query(query)\n}\n\nif erlang {\n  external fn do_parse_query(String) -> Result(List(#(String, String)), Nil) =\n    "gleam_stdlib" "parse_query"\n}\n\nif javascript {\n  external fn do_parse_query(String) -> Result(List(#(String, String)), Nil) =\n    "../gleam_stdlib.mjs" "parse_query"\n}\n\n/// Encodes a list of key value pairs as a URI query string.\n///\n/// The opposite operation is `uri.parse_query`.\n///\n/// ## Examples\n///\n/// ```\n/// > query_to_string([#("a", "1"), #("b", "2")])\n///\n/// "a=1&b=2"\n/// ```\n///\npub fn query_to_string(query: List(#(String, String))) -> String {\n  query\n  |> list.map(query_pair)\n  |> list.intersperse(string_builder.from_string("&"))\n  |> string_builder.concat\n  |> string_builder.to_string\n}\n\nfn query_pair(pair: #(String, String)) -> StringBuilder {\n  string_builder.from_strings([\n    percent_encode(pair.0),\n    "=",\n    percent_encode(pair.1),\n  ])\n}\n\n/// Encodes a string into a percent encoded representation.\n///\n/// ## Examples\n///\n/// ```\n/// > percent_encode("100% great")\n///\n/// "100%25%20great"\n/// ```\n///\npub fn percent_encode(value: String) -> String {\n  do_percent_encode(value)\n}\n\nif erlang {\n  external fn do_percent_encode(String) -> String =\n    "gleam_stdlib" "percent_encode"\n}\n\nif javascript {\n  external fn do_percent_encode(String) -> String =\n    "../gleam_stdlib.mjs" "percent_encode"\n}\n\n/// Decodes a percent encoded string.\n///\n/// ## Examples\n///\n/// ```\n/// > percent_decode("100%25+great")\n///\n/// Ok("100% great")\n/// ```\n///\npub fn percent_decode(value: String) -> Result(String, Nil) {\n  do_percent_decode(value)\n}\n\nif erlang {\n  external fn do_percent_decode(String) -> Result(String, Nil) =\n    "gleam_stdlib" "percent_decode"\n}\n\nif javascript {\n  external fn do_percent_decode(String) -> Result(String, Nil) =\n    "../gleam_stdlib.mjs" "percent_decode"\n}\n\nfn do_remove_dot_segments(\n  input: List(String),\n  accumulator: List(String),\n) -> List(String) {\n  case input {\n    [] -> list.reverse(accumulator)\n    [segment, ..rest] -> {\n      let accumulator = case segment, accumulator {\n        "", accumulator -> accumulator\n        ".", accumulator -> accumulator\n        "..", [] -> []\n        "..", [_, ..accumulator] -> accumulator\n        segment, accumulator -> [segment, ..accumulator]\n      }\n      do_remove_dot_segments(rest, accumulator)\n    }\n  }\n}\n\nfn remove_dot_segments(input: List(String)) -> List(String) {\n  do_remove_dot_segments(input, [])\n}\n\n/// Splits the path section of a URI into it\'s constituent segments.\n///\n/// Removes empty segments and resolves dot-segments as specified in\n/// [section 5.2](https://www.ietf.org/rfc/rfc3986.html#section-5.2) of the RFC.\n///\n/// ## Examples\n///\n/// ```\n/// > path_segments("/users/1")\n///\n/// ["users" ,"1"]\n/// ```\n///\npub fn path_segments(path: String) -> List(String) {\n  remove_dot_segments(string.split(path, "/"))\n}\n\n/// Encodes a `Uri` value as a URI string.\n///\n/// The opposite operation is `uri.parse`.\n///\n/// ## Examples\n///\n/// ```\n/// > let uri = Uri(Some("http"), None, Some("example.com"), ...)\n/// > to_string(uri)\n///\n/// "https://example.com"\n/// ```\n///\npub fn to_string(uri: Uri) -> String {\n  let parts = case uri.fragment {\n    Some(fragment) -> ["#", fragment]\n    _ -> []\n  }\n  let parts = case uri.query {\n    Some(query) -> ["?", query, ..parts]\n    _ -> parts\n  }\n  let parts = [uri.path, ..parts]\n  let parts = case uri.host, string.starts_with(uri.path, "/") {\n    Some(host), False if host != "" -> ["/", ..parts]\n    _, _ -> parts\n  }\n  let parts = case uri.host, uri.port {\n    Some(_), Some(port) -> [":", int.to_string(port), ..parts]\n    _, _ -> parts\n  }\n  let parts = case uri.scheme, uri.userinfo, uri.host {\n    Some(s), Some(u), Some(h) -> [s, "://", u, "@", h, ..parts]\n    Some(s), None, Some(h) -> [s, "://", h, ..parts]\n    Some(s), Some(_), None | Some(s), None, None -> [s, ":", ..parts]\n    None, None, Some(h) -> ["//", h, ..parts]\n    None, Some(_), None | None, None, None -> parts\n  }\n  string.concat(parts)\n}\n\n/// Fetches the origin of a URI.\n///\n/// Returns the origin of a uri as defined in\n/// https://tools.ietf.org/html/rfc6454\n///\n/// The supported URI schemes are `http` and `https`.\n/// URLs without a scheme will return `Error`.\n///\n/// ## Examples\n///\n/// ```\n/// > assert Ok(uri) = parse("http://example.com/path?foo#bar")\n/// > origin(uri)\n///\n/// Ok("http://example.com")\n/// ```\n///\npub fn origin(uri: Uri) -> Result(String, Nil) {\n  let Uri(scheme: scheme, host: host, port: port, ..) = uri\n  case scheme {\n    Some("https") if port == Some(443) -> {\n      let origin = Uri(scheme, None, host, None, "", None, None)\n      Ok(to_string(origin))\n    }\n    Some("http") if port == Some(80) -> {\n      let origin = Uri(scheme, None, host, None, "", None, None)\n      Ok(to_string(origin))\n    }\n    Some(s) if s == "http" || s == "https" -> {\n      let origin = Uri(scheme, None, host, port, "", None, None)\n      Ok(to_string(origin))\n    }\n    _ -> Error(Nil)\n  }\n}\n\nfn drop_last(elements: List(a)) -> List(a) {\n  list.take(from: elements, up_to: list.length(elements) - 1)\n}\n\nfn join_segments(segments: List(String)) -> String {\n  string.join(["", ..segments], "/")\n}\n\n/// Resolves a URI with respect to the given base URI.\n///\n/// The base URI must be an absolute URI or this function will return an error.\n/// The algorithm for merging uris is described in [RFC 3986](https://tools.ietf.org/html/rfc3986#section-5.2)\n///\npub fn merge(base: Uri, relative: Uri) -> Result(Uri, Nil) {\n  case base {\n    Uri(scheme: Some(_), host: Some(_), ..) ->\n      case relative {\n        Uri(host: Some(_), ..) -> {\n          let path =\n            string.split(relative.path, "/")\n            |> remove_dot_segments()\n            |> join_segments()\n          let resolved =\n            Uri(\n              option.or(relative.scheme, base.scheme),\n              None,\n              relative.host,\n              option.or(relative.port, base.port),\n              path,\n              relative.query,\n              relative.fragment,\n            )\n          Ok(resolved)\n        }\n        Uri(scheme: None, host: None, ..) -> {\n          let #(new_path, new_query) = case relative.path {\n            "" -> #(base.path, option.or(relative.query, base.query))\n            _ -> {\n              let path_segments = case string.starts_with(relative.path, "/") {\n                True -> string.split(relative.path, "/")\n                False ->\n                  string.split(base.path, "/")\n                  |> drop_last()\n                  |> list.append(string.split(relative.path, "/"))\n              }\n              let path =\n                path_segments\n                |> remove_dot_segments()\n                |> join_segments()\n              #(path, relative.query)\n            }\n          }\n          let resolved =\n            Uri(\n              base.scheme,\n              None,\n              base.host,\n              base.port,\n              new_path,\n              new_query,\n              relative.fragment,\n            )\n          Ok(resolved)\n        }\n      }\n    _ -> Error(Nil)\n  }\n}\n'}}]);