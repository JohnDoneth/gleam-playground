/*! For license information please see 213.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkgleam_playground=self.webpackChunkgleam_playground||[]).push([[213],{848:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>r});var i={comments:{lineComment:"*"},brackets:[["[","]"],["(",")"]]},r={defaultToken:"invalid",ignoreCase:!0,tokenPostfix:".abap",keywords:["abap-source","abbreviated","abstract","accept","accepting","according","activation","actual","add","add-corresponding","adjacent","after","alias","aliases","align","all","allocate","alpha","analysis","analyzer","and","append","appendage","appending","application","archive","area","arithmetic","as","ascending","aspect","assert","assign","assigned","assigning","association","asynchronous","at","attributes","authority","authority-check","avg","back","background","backup","backward","badi","base","before","begin","between","big","binary","bintohex","bit","black","blank","blanks","blob","block","blocks","blue","bound","boundaries","bounds","boxed","break-point","buffer","by","bypassing","byte","byte-order","call","calling","case","cast","casting","catch","center","centered","chain","chain-input","chain-request","change","changing","channels","character","char-to-hex","check","checkbox","ci_","circular","class","class-coding","class-data","class-events","class-methods","class-pool","cleanup","clear","client","clob","clock","close","coalesce","code","coding","col_background","col_group","col_heading","col_key","col_negative","col_normal","col_positive","col_total","collect","color","column","columns","comment","comments","commit","common","communication","comparing","component","components","compression","compute","concat","concat_with_space","concatenate","cond","condense","condition","connect","connection","constants","context","contexts","continue","control","controls","conv","conversion","convert","copies","copy","corresponding","country","cover","cpi","create","creating","critical","currency","currency_conversion","current","cursor","cursor-selection","customer","customer-function","dangerous","data","database","datainfo","dataset","date","dats_add_days","dats_add_months","dats_days_between","dats_is_valid","daylight","dd/mm/yy","dd/mm/yyyy","ddmmyy","deallocate","decimal_shift","decimals","declarations","deep","default","deferred","define","defining","definition","delete","deleting","demand","department","descending","describe","destination","detail","dialog","directory","disconnect","display","display-mode","distinct","divide","divide-corresponding","division","do","dummy","duplicate","duplicates","duration","during","dynamic","dynpro","edit","editor-call","else","elseif","empty","enabled","enabling","encoding","end","endat","endcase","endcatch","endchain","endclass","enddo","endenhancement","end-enhancement-section","endexec","endform","endfunction","endian","endif","ending","endinterface","end-lines","endloop","endmethod","endmodule","end-of-definition","end-of-editing","end-of-file","end-of-page","end-of-selection","endon","endprovide","endselect","end-test-injection","end-test-seam","endtry","endwhile","endwith","engineering","enhancement","enhancement-point","enhancements","enhancement-section","entries","entry","enum","environment","equiv","errormessage","errors","escaping","event","events","exact","except","exception","exceptions","exception-table","exclude","excluding","exec","execute","exists","exit","exit-command","expand","expanding","expiration","explicit","exponent","export","exporting","extend","extended","extension","extract","fail","fetch","field","field-groups","fields","field-symbol","field-symbols","file","filter","filters","filter-table","final","find","first","first-line","fixed-point","fkeq","fkge","flush","font","for","form","format","forward","found","frame","frames","free","friends","from","function","functionality","function-pool","further","gaps","generate","get","giving","gkeq","gkge","global","grant","green","group","groups","handle","handler","harmless","hashed","having","hdb","header","headers","heading","head-lines","help-id","help-request","hextobin","hide","high","hint","hold","hotspot","icon","id","identification","identifier","ids","if","ignore","ignoring","immediately","implementation","implementations","implemented","implicit","import","importing","in","inactive","incl","include","includes","including","increment","index","index-line","infotypes","inheriting","init","initial","initialization","inner","inout","input","insert","instance","instances","instr","intensified","interface","interface-pool","interfaces","internal","intervals","into","inverse","inverted-date","is","iso","job","join","keep","keeping","kernel","key","keys","keywords","kind","language","last","late","layout","leading","leave","left","left-justified","leftplus","leftspace","legacy","length","let","level","levels","like","line","lines","line-count","linefeed","line-selection","line-size","list","listbox","list-processing","little","llang","load","load-of-program","lob","local","locale","locator","logfile","logical","log-point","long","loop","low","lower","lpad","lpi","ltrim","mail","main","major-id","mapping","margin","mark","mask","match","matchcode","max","maximum","medium","members","memory","mesh","message","message-id","messages","messaging","method","methods","min","minimum","minor-id","mm/dd/yy","mm/dd/yyyy","mmddyy","mode","modif","modifier","modify","module","move","move-corresponding","multiply","multiply-corresponding","name","nametab","native","nested","nesting","new","new-line","new-page","new-section","next","no","no-display","no-extension","no-gap","no-gaps","no-grouping","no-heading","no-scrolling","no-sign","no-title","no-topofpage","no-zero","node","nodes","non-unicode","non-unique","not","null","number","object","objects","obligatory","occurrence","occurrences","occurs","of","off","offset","ole","on","only","open","option","optional","options","or","order","other","others","out","outer","output","output-length","overflow","overlay","pack","package","pad","padding","page","pages","parameter","parameters","parameter-table","part","partially","pattern","percentage","perform","performing","person","pf1","pf10","pf11","pf12","pf13","pf14","pf15","pf2","pf3","pf4","pf5","pf6","pf7","pf8","pf9","pf-status","pink","places","pool","pos_high","pos_low","position","pragmas","precompiled","preferred","preserving","primary","print","print-control","priority","private","procedure","process","program","property","protected","provide","public","push","pushbutton","put","queue-only","quickinfo","radiobutton","raise","raising","range","ranges","read","reader","read-only","receive","received","receiver","receiving","red","redefinition","reduce","reduced","ref","reference","refresh","regex","reject","remote","renaming","replace","replacement","replacing","report","request","requested","reserve","reset","resolution","respecting","responsible","result","results","resumable","resume","retry","return","returncode","returning","returns","right","right-justified","rightplus","rightspace","risk","rmc_communication_failure","rmc_invalid_status","rmc_system_failure","role","rollback","rows","rpad","rtrim","run","sap","sap-spool","saving","scale_preserving","scale_preserving_scientific","scan","scientific","scientific_with_leading_zero","scroll","scroll-boundary","scrolling","search","secondary","seconds","section","select","selection","selections","selection-screen","selection-set","selection-sets","selection-table","select-options","send","separate","separated","set","shared","shift","short","shortdump-id","sign_as_postfix","single","size","skip","skipping","smart","some","sort","sortable","sorted","source","specified","split","spool","spots","sql","sqlscript","stable","stamp","standard","starting","start-of-editing","start-of-selection","state","statement","statements","static","statics","statusinfo","step-loop","stop","structure","structures","style","subkey","submatches","submit","subroutine","subscreen","subtract","subtract-corresponding","suffix","sum","summary","summing","supplied","supply","suppress","switch","switchstates","symbol","syncpoints","syntax","syntax-check","syntax-trace","system-call","system-exceptions","system-exit","tab","tabbed","table","tables","tableview","tabstrip","target","task","tasks","test","testing","test-injection","test-seam","text","textpool","then","throw","time","times","timestamp","timezone","tims_is_valid","title","titlebar","title-lines","to","tokenization","tokens","top-lines","top-of-page","trace-file","trace-table","trailing","transaction","transfer","transformation","translate","transporting","trmac","truncate","truncation","try","tstmp_add_seconds","tstmp_current_utctimestamp","tstmp_is_valid","tstmp_seconds_between","type","type-pool","type-pools","types","uline","unassign","under","unicode","union","unique","unit_conversion","unix","unpack","until","unwind","up","update","upper","user","user-command","using","utf-8","valid","value","value-request","values","vary","varying","verification-message","version","via","view","visible","wait","warning","when","whenever","where","while","width","window","windows","with","with-heading","without","with-title","word","work","write","writer","xml","xsd","yellow","yes","yymmdd","zero","zone","abap_system_timezone","abap_user_timezone","access","action","adabas","adjust_numbers","allow_precision_loss","allowed","amdp","applicationuser","as_geo_json","as400","associations","balance","behavior","breakup","bulk","cds","cds_client","check_before_save","child","clients","corr","corr_spearman","cross","cycles","datn_add_days","datn_add_months","datn_days_between","dats_from_datn","dats_tims_to_tstmp","dats_to_datn","db2","db6","ddl","dense_rank","depth","deterministic","discarding","entities","entity","error","failed","finalize","first_value","fltp_to_dec","following","fractional","full","graph","grouping","hierarchy","hierarchy_ancestors","hierarchy_ancestors_aggregate","hierarchy_descendants","hierarchy_descendants_aggregate","hierarchy_siblings","incremental","indicators","lag","last_value","lead","leaves","like_regexpr","link","locale_sap","lock","locks","many","mapped","matched","measures","median","mssqlnt","multiple","nodetype","ntile","nulls","occurrences_regexpr","one","operations","oracle","orphans","over","parent","parents","partition","pcre","period","pfcg_mapping","preceding","privileged","product","projection","rank","redirected","replace_regexpr","reported","response","responses","root","row","row_number","sap_system_date","save","schema","session","sets","shortdump","siblings","spantree","start","stddev","string_agg","subtotal","sybase","tims_from_timn","tims_to_timn","to_blob","to_clob","total","trace-entry","tstmp_to_dats","tstmp_to_dst","tstmp_to_tims","tstmpl_from_utcl","tstmpl_to_utcl","unbounded","utcl_add_seconds","utcl_current","utcl_seconds_between","uuid","var","verbatim"],builtinFunctions:["abs","acos","asin","atan","bit-set","boolc","boolx","ceil","char_off","charlen","cmax","cmin","concat_lines_of","contains","contains_any_not_of","contains_any_of","cos","cosh","count","count_any_not_of","count_any_of","dbmaxlen","distance","escape","exp","find_any_not_of","find_any_of","find_end","floor","frac","from_mixed","ipow","line_exists","line_index","log","log10","matches","nmax","nmin","numofchar","repeat","rescale","reverse","round","segment","shift_left","shift_right","sign","sin","sinh","sqrt","strlen","substring","substring_after","substring_before","substring_from","substring_to","tan","tanh","to_lower","to_mixed","to_upper","trunc","utclong_add","utclong_current","utclong_diff","xsdbool","xstrlen"],typeKeywords:["b","c","d","decfloat16","decfloat34","f","i","int8","n","p","s","string","t","utclong","x","xstring","any","clike","csequence","decfloat","numeric","simple","xsequence","accp","char","clnt","cuky","curr","datn","dats","d16d","d16n","d16r","d34d","d34n","d34r","dec","df16_dec","df16_raw","df34_dec","df34_raw","fltp","geom_ewkb","int1","int2","int4","lang","lchr","lraw","numc","quan","raw","rawstring","sstring","timn","tims","unit","utcl","df16_scl","df34_scl","prec","varc","abap_bool","abap_false","abap_true","abap_undefined","me","screen","space","super","sy","syst","table_line","*sys*"],builtinMethods:["class_constructor","constructor"],derivedTypes:["%CID","%CID_REF","%CONTROL","%DATA","%ELEMENT","%FAIL","%KEY","%MSG","%PARAM","%PID","%PID_ASSOC","%PID_PARENT","%_HINTS"],cdsLanguage:["@AbapAnnotation","@AbapCatalog","@AccessControl","@API","@ClientDependent","@ClientHandling","@CompatibilityContract","@DataAging","@EndUserText","@Environment","@LanguageDependency","@MappingRole","@Metadata","@MetadataExtension","@ObjectModel","@Scope","@Semantics","$EXTENSION","$SELF"],selectors:["->","->*","=>","~","~*"],operators:[" +"," -","/","*","**","div","mod","=","#","@","+=","-=","*=","/=","**=","&&=","?=","&","&&","bit-and","bit-not","bit-or","bit-xor","m","o","z","<"," >","<=",">=","<>","><","=<","=>","bt","byte-ca","byte-cn","byte-co","byte-cs","byte-na","byte-ns","ca","cn","co","cp","cs","eq","ge","gt","le","lt","na","nb","ne","np","ns","*/","*:","--","/*","//"],symbols:/[=><!~?&+\-*\/\^%#@]+/,tokenizer:{root:[[/[a-z_\/$%@]([\w\/$%]|-(?!>))*/,{cases:{"@typeKeywords":"type","@keywords":"keyword","@cdsLanguage":"annotation","@derivedTypes":"type","@builtinFunctions":"type","@builtinMethods":"type","@operators":"key","@default":"identifier"}}],[/<[\w]+>/,"identifier"],[/##[\w|_]+/,"comment"],{include:"@whitespace"},[/[:,.]/,"delimiter"],[/[{}()\[\]]/,"@brackets"],[/@symbols/,{cases:{"@selectors":"tag","@operators":"key","@default":""}}],[/'/,{token:"string",bracket:"@open",next:"@stringquote"}],[/`/,{token:"string",bracket:"@open",next:"@stringping"}],[/\|/,{token:"string",bracket:"@open",next:"@stringtemplate"}],[/\d+/,"number"]],stringtemplate:[[/[^\\\|]+/,"string"],[/\\\|/,"string"],[/\|/,{token:"string",bracket:"@close",next:"@pop"}]],stringping:[[/[^\\`]+/,"string"],[/`/,{token:"string",bracket:"@close",next:"@pop"}]],stringquote:[[/[^\\']+/,"string"],[/'/,{token:"string",bracket:"@close",next:"@pop"}]],whitespace:[[/[ \t\r\n]+/,""],[/^\*.*$/,"comment"],[/\".*$/,"comment"]]}}},1471:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>r});var i={comments:{lineComment:"#"}},r={defaultToken:"keyword",ignoreCase:!0,tokenPostfix:".azcli",str:/[^#\s]/,tokenizer:{root:[{include:"@comment"},[/\s-+@str*\s*/,{cases:{"@eos":{token:"key.identifier",next:"@popall"},"@default":{token:"key.identifier",next:"@type"}}}],[/^-+@str*\s*/,{cases:{"@eos":{token:"key.identifier",next:"@popall"},"@default":{token:"key.identifier",next:"@type"}}}]],type:[{include:"@comment"},[/-+@str*\s*/,{cases:{"@eos":{token:"key.identifier",next:"@popall"},"@default":"key.identifier"}}],[/@str+\s*/,{cases:{"@eos":{token:"string",next:"@popall"},"@default":"string"}}]],comment:[[/#.*$/,{cases:{"@eos":{token:"comment",next:"@popall"}}}]]}}},4129:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>r});var i={comments:{lineComment:"REM"},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'}],surroundingPairs:[{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'}],folding:{markers:{start:new RegExp("^\\s*(::\\s*|REM\\s+)#region"),end:new RegExp("^\\s*(::\\s*|REM\\s+)#endregion")}}},r={defaultToken:"",ignoreCase:!0,tokenPostfix:".bat",brackets:[{token:"delimiter.bracket",open:"{",close:"}"},{token:"delimiter.parenthesis",open:"(",close:")"},{token:"delimiter.square",open:"[",close:"]"}],keywords:/call|defined|echo|errorlevel|exist|for|goto|if|pause|set|shift|start|title|not|pushd|popd/,symbols:/[=><!~?&|+\-*\/\^;\.,]+/,escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,tokenizer:{root:[[/^(\s*)(rem(?:\s.*|))$/,["","comment"]],[/(\@?)(@keywords)(?!\w)/,[{token:"keyword"},{token:"keyword.$2"}]],[/[ \t\r\n]+/,""],[/setlocal(?!\w)/,"keyword.tag-setlocal"],[/endlocal(?!\w)/,"keyword.tag-setlocal"],[/[a-zA-Z_]\w*/,""],[/:\w*/,"metatag"],[/%[^%]+%/,"variable"],[/%%[\w]+(?!\w)/,"variable"],[/[{}()\[\]]/,"@brackets"],[/@symbols/,"delimiter"],[/\d*\.\d+([eE][\-+]?\d+)?/,"number.float"],[/0[xX][0-9a-fA-F_]*[0-9a-fA-F]/,"number.hex"],[/\d+/,"number"],[/[;,.]/,"delimiter"],[/"/,"string",'@string."'],[/'/,"string","@string.'"]],string:[[/[^\\"'%]+/,{cases:{"@eos":{token:"string",next:"@popall"},"@default":"string"}}],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/%[\w ]+%/,"variable"],[/%%[\w]+(?!\w)/,"variable"],[/["']/,{cases:{"$#==$S2":{token:"string",next:"@pop"},"@default":"string"}}],[/$/,"string","@popall"]]}}},7131:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>r});var i={comments:{lineComment:"//",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"]],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:"'",close:"'"},{open:"'''",close:"'''"}],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:"'",close:"'",notIn:["string","comment"]},{open:"'''",close:"'''",notIn:["string","comment"]}],autoCloseBefore:":.,=}])' \n\t",indentationRules:{increaseIndentPattern:new RegExp("^((?!\\/\\/).)*(\\{[^}\"'`]*|\\([^)\"'`]*|\\[[^\\]\"'`]*)$"),decreaseIndentPattern:new RegExp("^((?!.*?\\/\\*).*\\*/)?\\s*[\\}\\]].*$")}},r={defaultToken:"",tokenPostfix:".bicep",brackets:[{open:"{",close:"}",token:"delimiter.curly"},{open:"[",close:"]",token:"delimiter.square"},{open:"(",close:")",token:"delimiter.parenthesis"}],symbols:/[=><!~?:&|+\-*/^%]+/,keywords:["targetScope","resource","module","param","var","output","for","in","if","existing"],namedLiterals:["true","false","null"],escapes:"\\\\(u{[0-9A-Fa-f]+}|n|r|t|\\\\|'|\\${)",tokenizer:{root:[{include:"@expression"},{include:"@whitespace"}],stringVerbatim:[{regex:"(|'|'')[^']",action:{token:"string"}},{regex:"'''",action:{token:"string.quote",next:"@pop"}}],stringLiteral:[{regex:"\\${",action:{token:"delimiter.bracket",next:"@bracketCounting"}},{regex:"[^\\\\'$]+",action:{token:"string"}},{regex:"@escapes",action:{token:"string.escape"}},{regex:"\\\\.",action:{token:"string.escape.invalid"}},{regex:"'",action:{token:"string",next:"@pop"}}],bracketCounting:[{regex:"{",action:{token:"delimiter.bracket",next:"@bracketCounting"}},{regex:"}",action:{token:"delimiter.bracket",next:"@pop"}},{include:"expression"}],comment:[{regex:"[^\\*]+",action:{token:"comment"}},{regex:"\\*\\/",action:{token:"comment",next:"@pop"}},{regex:"[\\/*]",action:{token:"comment"}}],whitespace:[{regex:"[ \\t\\r\\n]"},{regex:"\\/\\*",action:{token:"comment",next:"@comment"}},{regex:"\\/\\/.*$",action:{token:"comment"}}],expression:[{regex:"'''",action:{token:"string.quote",next:"@stringVerbatim"}},{regex:"'",action:{token:"string.quote",next:"@stringLiteral"}},{regex:"[0-9]+",action:{token:"number"}},{regex:"\\b[_a-zA-Z][_a-zA-Z0-9]*\\b",action:{cases:{"@keywords":{token:"keyword"},"@namedLiterals":{token:"keyword"},"@default":{token:"identifier"}}}}]}}},1147:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>r});var i={wordPattern:/(-?\d*\.\d\w*)|([^\`\~\!\@\#%\^\&\*\(\)\=\$\-\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g,comments:{blockComment:["###","###"],lineComment:"#"},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],folding:{markers:{start:new RegExp("^\\s*#region\\b"),end:new RegExp("^\\s*#endregion\\b")}}},r={defaultToken:"",ignoreCase:!0,tokenPostfix:".coffee",brackets:[{open:"{",close:"}",token:"delimiter.curly"},{open:"[",close:"]",token:"delimiter.square"},{open:"(",close:")",token:"delimiter.parenthesis"}],regEx:/\/(?!\/\/)(?:[^\/\\]|\\.)*\/[igm]*/,keywords:["and","or","is","isnt","not","on","yes","@","no","off","true","false","null","this","new","delete","typeof","in","instanceof","return","throw","break","continue","debugger","if","else","switch","for","while","do","try","catch","finally","class","extends","super","undefined","then","unless","until","loop","of","by","when"],symbols:/[=><!~?&%|+\-*\/\^\.,\:]+/,escapes:/\\(?:[abfnrtv\\"'$]|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,tokenizer:{root:[[/\@[a-zA-Z_]\w*/,"variable.predefined"],[/[a-zA-Z_]\w*/,{cases:{this:"variable.predefined","@keywords":{token:"keyword.$0"},"@default":""}}],[/[ \t\r\n]+/,""],[/###/,"comment","@comment"],[/#.*$/,"comment"],["///",{token:"regexp",next:"@hereregexp"}],[/^(\s*)(@regEx)/,["","regexp"]],[/(\()(\s*)(@regEx)/,["@brackets","","regexp"]],[/(\,)(\s*)(@regEx)/,["delimiter","","regexp"]],[/(\=)(\s*)(@regEx)/,["delimiter","","regexp"]],[/(\:)(\s*)(@regEx)/,["delimiter","","regexp"]],[/(\[)(\s*)(@regEx)/,["@brackets","","regexp"]],[/(\!)(\s*)(@regEx)/,["delimiter","","regexp"]],[/(\&)(\s*)(@regEx)/,["delimiter","","regexp"]],[/(\|)(\s*)(@regEx)/,["delimiter","","regexp"]],[/(\?)(\s*)(@regEx)/,["delimiter","","regexp"]],[/(\{)(\s*)(@regEx)/,["@brackets","","regexp"]],[/(\;)(\s*)(@regEx)/,["","","regexp"]],[/}/,{cases:{"$S2==interpolatedstring":{token:"string",next:"@pop"},"@default":"@brackets"}}],[/[{}()\[\]]/,"@brackets"],[/@symbols/,"delimiter"],[/\d+[eE]([\-+]?\d+)?/,"number.float"],[/\d+\.\d+([eE][\-+]?\d+)?/,"number.float"],[/0[xX][0-9a-fA-F]+/,"number.hex"],[/0[0-7]+(?!\d)/,"number.octal"],[/\d+/,"number"],[/[,.]/,"delimiter"],[/"""/,"string",'@herestring."""'],[/'''/,"string","@herestring.'''"],[/"/,{cases:{"@eos":"string","@default":{token:"string",next:'@string."'}}}],[/'/,{cases:{"@eos":"string","@default":{token:"string",next:"@string.'"}}}]],string:[[/[^"'\#\\]+/,"string"],[/@escapes/,"string.escape"],[/\./,"string.escape.invalid"],[/\./,"string.escape.invalid"],[/#{/,{cases:{'$S2=="':{token:"string",next:"root.interpolatedstring"},"@default":"string"}}],[/["']/,{cases:{"$#==$S2":{token:"string",next:"@pop"},"@default":"string"}}],[/#/,"string"]],herestring:[[/("""|''')/,{cases:{"$1==$S2":{token:"string",next:"@pop"},"@default":"string"}}],[/[^#\\'"]+/,"string"],[/['"]+/,"string"],[/@escapes/,"string.escape"],[/\./,"string.escape.invalid"],[/#{/,{token:"string.quote",next:"root.interpolatedstring"}],[/#/,"string"]],comment:[[/[^#]+/,"comment"],[/###/,"comment","@pop"],[/#/,"comment"]],hereregexp:[[/[^\\\/#]+/,"regexp"],[/\\./,"regexp"],[/#.*$/,"comment"],["///[igm]*",{token:"regexp",next:"@pop"}],[/\//,"regexp"]]}}},2075:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>r});var i={wordPattern:/(#?-?\d*\.\d\w*%?)|((::|[@#.!:])?[\w-?]+%?)|::|[@#.!:]/g,comments:{blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}",notIn:["string","comment"]},{open:"[",close:"]",notIn:["string","comment"]},{open:"(",close:")",notIn:["string","comment"]},{open:'"',close:'"',notIn:["string","comment"]},{open:"'",close:"'",notIn:["string","comment"]}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],folding:{markers:{start:new RegExp("^\\s*\\/\\*\\s*#region\\b\\s*(.*?)\\s*\\*\\/"),end:new RegExp("^\\s*\\/\\*\\s*#endregion\\b.*\\*\\/")}}},r={defaultToken:"",tokenPostfix:".css",ws:"[ \t\n\r\f]*",identifier:"-?-?([a-zA-Z]|(\\\\(([0-9a-fA-F]{1,6}\\s?)|[^[0-9a-fA-F])))([\\w\\-]|(\\\\(([0-9a-fA-F]{1,6}\\s?)|[^[0-9a-fA-F])))*",brackets:[{open:"{",close:"}",token:"delimiter.bracket"},{open:"[",close:"]",token:"delimiter.bracket"},{open:"(",close:")",token:"delimiter.parenthesis"},{open:"<",close:">",token:"delimiter.angle"}],tokenizer:{root:[{include:"@selector"}],selector:[{include:"@comments"},{include:"@import"},{include:"@strings"},["[@](keyframes|-webkit-keyframes|-moz-keyframes|-o-keyframes)",{token:"keyword",next:"@keyframedeclaration"}],["[@](page|content|font-face|-moz-document)",{token:"keyword"}],["[@](charset|namespace)",{token:"keyword",next:"@declarationbody"}],["(url-prefix)(\\()",["attribute.value",{token:"delimiter.parenthesis",next:"@urldeclaration"}]],["(url)(\\()",["attribute.value",{token:"delimiter.parenthesis",next:"@urldeclaration"}]],{include:"@selectorname"},["[\\*]","tag"],["[>\\+,]","delimiter"],["\\[",{token:"delimiter.bracket",next:"@selectorattribute"}],["{",{token:"delimiter.bracket",next:"@selectorbody"}]],selectorbody:[{include:"@comments"},["[*_]?@identifier@ws:(?=(\\s|\\d|[^{;}]*[;}]))","attribute.name","@rulevalue"],["}",{token:"delimiter.bracket",next:"@pop"}]],selectorname:[["(\\.|#(?=[^{])|%|(@identifier)|:)+","tag"]],selectorattribute:[{include:"@term"},["]",{token:"delimiter.bracket",next:"@pop"}]],term:[{include:"@comments"},["(url-prefix)(\\()",["attribute.value",{token:"delimiter.parenthesis",next:"@urldeclaration"}]],["(url)(\\()",["attribute.value",{token:"delimiter.parenthesis",next:"@urldeclaration"}]],{include:"@functioninvocation"},{include:"@numbers"},{include:"@name"},{include:"@strings"},["([<>=\\+\\-\\*\\/\\^\\|\\~,])","delimiter"],[",","delimiter"]],rulevalue:[{include:"@comments"},{include:"@strings"},{include:"@term"},["!important","keyword"],[";","delimiter","@pop"],["(?=})",{token:"",next:"@pop"}]],warndebug:[["[@](warn|debug)",{token:"keyword",next:"@declarationbody"}]],import:[["[@](import)",{token:"keyword",next:"@declarationbody"}]],urldeclaration:[{include:"@strings"},["[^)\r\n]+","string"],["\\)",{token:"delimiter.parenthesis",next:"@pop"}]],parenthizedterm:[{include:"@term"},["\\)",{token:"delimiter.parenthesis",next:"@pop"}]],declarationbody:[{include:"@term"},[";","delimiter","@pop"],["(?=})",{token:"",next:"@pop"}]],comments:[["\\/\\*","comment","@comment"],["\\/\\/+.*","comment"]],comment:[["\\*\\/","comment","@pop"],[/[^*/]+/,"comment"],[/./,"comment"]],name:[["@identifier","attribute.value"]],numbers:[["-?(\\d*\\.)?\\d+([eE][\\-+]?\\d+)?",{token:"attribute.value.number",next:"@units"}],["#[0-9a-fA-F_]+(?!\\w)","attribute.value.hex"]],units:[["(em|ex|ch|rem|vmin|vmax|vw|vh|vm|cm|mm|in|px|pt|pc|deg|grad|rad|turn|s|ms|Hz|kHz|%)?","attribute.value.unit","@pop"]],keyframedeclaration:[["@identifier","attribute.value"],["{",{token:"delimiter.bracket",switchTo:"@keyframebody"}]],keyframebody:[{include:"@term"},["{",{token:"delimiter.bracket",next:"@selectorbody"}],["}",{token:"delimiter.bracket",next:"@pop"}]],functioninvocation:[["@identifier\\(",{token:"attribute.value",next:"@functionarguments"}]],functionarguments:[["\\$@identifier@ws:","attribute.name"],["[,]","delimiter"],{include:"@term"},["\\)",{token:"attribute.value",next:"@pop"}]],strings:[['~?"',{token:"string",next:"@stringenddoublequote"}],["~?'",{token:"string",next:"@stringendquote"}]],stringenddoublequote:[["\\\\.","string"],['"',{token:"string",next:"@pop"}],[/[^\\"]+/,"string"],[".","string"]],stringendquote:[["\\\\.","string"],["'",{token:"string",next:"@pop"}],[/[^\\']+/,"string"],[".","string"]]}}},4188:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>r});var i={comments:{blockComment:["/*","*/"],lineComment:"//"},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}",notIn:["string"]},{open:"[",close:"]",notIn:["string"]},{open:"(",close:")",notIn:["string"]},{open:'"',close:'"',notIn:["string"]},{open:"'",close:"'",notIn:["string"]}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"},{open:"<",close:">"}]},r={defaultToken:"",tokenPostfix:".flow",keywords:["import","require","export","forbid","native","if","else","cast","unsafe","switch","default"],types:["io","mutable","bool","int","double","string","flow","void","ref","true","false","with"],operators:["=",">","<","<=",">=","==","!","!=",":=","::=","&&","||","+","-","*","/","@","&","%",":","->","\\","$","??","^"],symbols:/[@$=><!~?:&|+\-*\\\/\^%]+/,escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,tokenizer:{root:[[/[a-zA-Z_]\w*/,{cases:{"@keywords":"keyword","@types":"type","@default":"identifier"}}],{include:"@whitespace"},[/[{}()\[\]]/,"delimiter"],[/[<>](?!@symbols)/,"delimiter"],[/@symbols/,{cases:{"@operators":"delimiter","@default":""}}],[/((0(x|X)[0-9a-fA-F]*)|(([0-9]+\.?[0-9]*)|(\.[0-9]+))((e|E)(\+|-)?[0-9]+)?)/,"number"],[/[;,.]/,"delimiter"],[/"([^"\\]|\\.)*$/,"string.invalid"],[/"/,"string","@string"]],whitespace:[[/[ \t\r\n]+/,""],[/\/\*/,"comment","@comment"],[/\/\/.*$/,"comment"]],comment:[[/[^\/*]+/,"comment"],[/\*\//,"comment","@pop"],[/[\/*]/,"comment"]],string:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,"string","@pop"]]}}},4946:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>r});var i={brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}]},r={tokenPostfix:".julia",keywords:["begin","while","if","for","try","return","break","continue","function","macro","quote","let","local","global","const","do","struct","module","baremodule","using","import","export","end","else","elseif","catch","finally","mutable","primitive","abstract","type","in","isa","where","new"],types:["LinRange","LineNumberNode","LinearIndices","LoadError","MIME","Matrix","Method","MethodError","Missing","MissingException","Module","NTuple","NamedTuple","Nothing","Number","OrdinalRange","OutOfMemoryError","OverflowError","Pair","PartialQuickSort","PermutedDimsArray","Pipe","Ptr","QuoteNode","Rational","RawFD","ReadOnlyMemoryError","Real","ReentrantLock","Ref","Regex","RegexMatch","RoundingMode","SegmentationFault","Set","Signed","Some","StackOverflowError","StepRange","StepRangeLen","StridedArray","StridedMatrix","StridedVecOrMat","StridedVector","String","StringIndexError","SubArray","SubString","SubstitutionString","Symbol","SystemError","Task","Text","TextDisplay","Timer","Tuple","Type","TypeError","TypeVar","UInt","UInt128","UInt16","UInt32","UInt64","UInt8","UndefInitializer","AbstractArray","UndefKeywordError","AbstractChannel","UndefRefError","AbstractChar","UndefVarError","AbstractDict","Union","AbstractDisplay","UnionAll","AbstractFloat","UnitRange","AbstractIrrational","Unsigned","AbstractMatrix","AbstractRange","Val","AbstractSet","Vararg","AbstractString","VecElement","AbstractUnitRange","VecOrMat","AbstractVecOrMat","Vector","AbstractVector","VersionNumber","Any","WeakKeyDict","ArgumentError","WeakRef","Array","AssertionError","BigFloat","BigInt","BitArray","BitMatrix","BitSet","BitVector","Bool","BoundsError","CapturedException","CartesianIndex","CartesianIndices","Cchar","Cdouble","Cfloat","Channel","Char","Cint","Cintmax_t","Clong","Clonglong","Cmd","Colon","Complex","ComplexF16","ComplexF32","ComplexF64","CompositeException","Condition","Cptrdiff_t","Cshort","Csize_t","Cssize_t","Cstring","Cuchar","Cuint","Cuintmax_t","Culong","Culonglong","Cushort","Cvoid","Cwchar_t","Cwstring","DataType","DenseArray","DenseMatrix","DenseVecOrMat","DenseVector","Dict","DimensionMismatch","Dims","DivideError","DomainError","EOFError","Enum","ErrorException","Exception","ExponentialBackOff","Expr","Float16","Float32","Float64","Function","GlobalRef","HTML","IO","IOBuffer","IOContext","IOStream","IdDict","IndexCartesian","IndexLinear","IndexStyle","InexactError","InitError","Int","Int128","Int16","Int32","Int64","Int8","Integer","InterruptException","InvalidStateException","Irrational","KeyError"],keywordops:["<:",">:",":","=>","...",".","->","?"],allops:/[^\w\d\s()\[\]{}"'#]+/,constants:["true","false","nothing","missing","undef","Inf","pi","NaN","π","ℯ","ans","PROGRAM_FILE","ARGS","C_NULL","VERSION","DEPOT_PATH","LOAD_PATH"],operators:["!","!=","!==","%","&","*","+","-","/","//","<","<<","<=","==","===","=>",">",">=",">>",">>>","\\","^","|","|>","~","÷","∈","∉","∋","∌","∘","√","∛","∩","∪","≈","≉","≠","≡","≢","≤","≥","⊆","⊇","⊈","⊉","⊊","⊋","⊻"],brackets:[{open:"(",close:")",token:"delimiter.parenthesis"},{open:"{",close:"}",token:"delimiter.curly"},{open:"[",close:"]",token:"delimiter.square"}],ident:/π|ℯ|\b(?!\d)\w+\b/,escape:/(?:[abefnrstv\\"'\n\r]|[0-7]{1,3}|x[0-9A-Fa-f]{1,2}|u[0-9A-Fa-f]{4})/,escapes:/\\(?:C\-(@escape|.)|c(@escape|.)|@escape)/,tokenizer:{root:[[/(::)\s*|\b(isa)\s+/,"keyword","@typeanno"],[/\b(isa)(\s*\(@ident\s*,\s*)/,["keyword",{token:"",next:"@typeanno"}]],[/\b(type|struct)[ \t]+/,"keyword","@typeanno"],[/^\s*:@ident[!?]?/,"metatag"],[/(return)(\s*:@ident[!?]?)/,["keyword","metatag"]],[/(\(|\[|\{|@allops)(\s*:@ident[!?]?)/,["","metatag"]],[/:\(/,"metatag","@quote"],[/r"""/,"regexp.delim","@tregexp"],[/r"/,"regexp.delim","@sregexp"],[/raw"""/,"string.delim","@rtstring"],[/[bv]?"""/,"string.delim","@dtstring"],[/raw"/,"string.delim","@rsstring"],[/[bv]?"/,"string.delim","@dsstring"],[/(@ident)\{/,{cases:{"$1@types":{token:"type",next:"@gen"},"@default":{token:"type",next:"@gen"}}}],[/@ident[!?'']?(?=\.?\()/,{cases:{"@types":"type","@keywords":"keyword","@constants":"variable","@default":"keyword.flow"}}],[/@ident[!?']?/,{cases:{"@types":"type","@keywords":"keyword","@constants":"variable","@default":"identifier"}}],[/\$\w+/,"key"],[/\$\(/,"key","@paste"],[/@@@ident/,"annotation"],{include:"@whitespace"},[/'(?:@escapes|.)'/,"string.character"],[/[()\[\]{}]/,"@brackets"],[/@allops/,{cases:{"@keywordops":"keyword","@operators":"operator"}}],[/[;,]/,"delimiter"],[/0[xX][0-9a-fA-F](_?[0-9a-fA-F])*/,"number.hex"],[/0[_oO][0-7](_?[0-7])*/,"number.octal"],[/0[bB][01](_?[01])*/,"number.binary"],[/[+\-]?\d+(\.\d+)?(im?|[eE][+\-]?\d+(\.\d+)?)?/,"number"]],typeanno:[[/[a-zA-Z_]\w*(?:\.[a-zA-Z_]\w*)*\{/,"type","@gen"],[/([a-zA-Z_]\w*(?:\.[a-zA-Z_]\w*)*)(\s*<:\s*)/,["type","keyword"]],[/[a-zA-Z_]\w*(?:\.[a-zA-Z_]\w*)*/,"type","@pop"],["","","@pop"]],gen:[[/[a-zA-Z_]\w*(?:\.[a-zA-Z_]\w*)*\{/,"type","@push"],[/[a-zA-Z_]\w*(?:\.[a-zA-Z_]\w*)*/,"type"],[/<:/,"keyword"],[/(\})(\s*<:\s*)/,["type",{token:"keyword",next:"@pop"}]],[/\}/,"type","@pop"],{include:"@root"}],quote:[[/\$\(/,"key","@paste"],[/\(/,"@brackets","@paren"],[/\)/,"metatag","@pop"],{include:"@root"}],paste:[[/:\(/,"metatag","@quote"],[/\(/,"@brackets","@paren"],[/\)/,"key","@pop"],{include:"@root"}],paren:[[/\$\(/,"key","@paste"],[/:\(/,"metatag","@quote"],[/\(/,"@brackets","@push"],[/\)/,"@brackets","@pop"],{include:"@root"}],sregexp:[[/^.*/,"invalid"],[/[^\\"()\[\]{}]/,"regexp"],[/[()\[\]{}]/,"@brackets"],[/\\./,"operator.scss"],[/"[imsx]*/,"regexp.delim","@pop"]],tregexp:[[/[^\\"()\[\]{}]/,"regexp"],[/[()\[\]{}]/,"@brackets"],[/\\./,"operator.scss"],[/"(?!"")/,"string"],[/"""[imsx]*/,"regexp.delim","@pop"]],rsstring:[[/^.*/,"invalid"],[/[^\\"]/,"string"],[/\\./,"string.escape"],[/"/,"string.delim","@pop"]],rtstring:[[/[^\\"]/,"string"],[/\\./,"string.escape"],[/"(?!"")/,"string"],[/"""/,"string.delim","@pop"]],dsstring:[[/^.*/,"invalid"],[/[^\\"\$]/,"string"],[/\$/,"","@interpolated"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,"string.delim","@pop"]],dtstring:[[/[^\\"\$]/,"string"],[/\$/,"","@interpolated"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"(?!"")/,"string"],[/"""/,"string.delim","@pop"]],interpolated:[[/\(/,{token:"",switchTo:"@interpolated_compound"}],[/[a-zA-Z_]\w*/,"identifier"],["","","@pop"]],interpolated_compound:[[/\)/,"","@pop"],{include:"@root"}],whitespace:[[/[ \t\r\n]+/,""],[/#=/,"comment","@multi_comment"],[/#.*$/,"comment"]],multi_comment:[[/#=/,"comment","@push"],[/=#/,"comment","@pop"],[/=(?!#)|#(?!=)/,"comment"],[/[^#=]+/,"comment"]]}}},4368:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>r});var i={wordPattern:/(-?\d*\.\d\w*)|([^\`\~\!\#\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g,comments:{lineComment:"//",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"},{open:"<",close:">"}],folding:{markers:{start:new RegExp("^\\s*//\\s*(?:(?:#?region\\b)|(?:<editor-fold\\b))"),end:new RegExp("^\\s*//\\s*(?:(?:#?endregion\\b)|(?:</editor-fold>))")}}},r={defaultToken:"",tokenPostfix:".kt",keywords:["as","as?","break","class","continue","do","else","false","for","fun","if","in","!in","interface","is","!is","null","object","package","return","super","this","throw","true","try","typealias","val","var","when","while","by","catch","constructor","delegate","dynamic","field","file","finally","get","import","init","param","property","receiver","set","setparam","where","actual","abstract","annotation","companion","const","crossinline","data","enum","expect","external","final","infix","inline","inner","internal","lateinit","noinline","open","operator","out","override","private","protected","public","reified","sealed","suspend","tailrec","vararg","field","it"],operators:["+","-","*","/","%","=","+=","-=","*=","/=","%=","++","--","&&","||","!","==","!=","===","!==",">","<","<=",">=","[","]","!!","?.","?:","::","..",":","?","->","@",";","$","_"],symbols:/[=><!~?:&|+\-*\/\^%]+/,escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,digits:/\d+(_+\d+)*/,octaldigits:/[0-7]+(_+[0-7]+)*/,binarydigits:/[0-1]+(_+[0-1]+)*/,hexdigits:/[[0-9a-fA-F]+(_+[0-9a-fA-F]+)*/,tokenizer:{root:[[/[A-Z][\w\$]*/,"type.identifier"],[/[a-zA-Z_$][\w$]*/,{cases:{"@keywords":{token:"keyword.$0"},"@default":"identifier"}}],{include:"@whitespace"},[/[{}()\[\]]/,"@brackets"],[/[<>](?!@symbols)/,"@brackets"],[/@symbols/,{cases:{"@operators":"delimiter","@default":""}}],[/@\s*[a-zA-Z_\$][\w\$]*/,"annotation"],[/(@digits)[eE]([\-+]?(@digits))?[fFdD]?/,"number.float"],[/(@digits)\.(@digits)([eE][\-+]?(@digits))?[fFdD]?/,"number.float"],[/0[xX](@hexdigits)[Ll]?/,"number.hex"],[/0(@octaldigits)[Ll]?/,"number.octal"],[/0[bB](@binarydigits)[Ll]?/,"number.binary"],[/(@digits)[fFdD]/,"number.float"],[/(@digits)[lL]?/,"number"],[/[;,.]/,"delimiter"],[/"([^"\\]|\\.)*$/,"string.invalid"],[/"""/,"string","@multistring"],[/"/,"string","@string"],[/'[^\\']'/,"string"],[/(')(@escapes)(')/,["string","string.escape","string"]],[/'/,"string.invalid"]],whitespace:[[/[ \t\r\n]+/,""],[/\/\*\*(?!\/)/,"comment.doc","@javadoc"],[/\/\*/,"comment","@comment"],[/\/\/.*$/,"comment"]],comment:[[/[^\/*]+/,"comment"],[/\/\*/,"comment","@comment"],[/\*\//,"comment","@pop"],[/[\/*]/,"comment"]],javadoc:[[/[^\/*]+/,"comment.doc"],[/\/\*/,"comment.doc","@push"],[/\/\*/,"comment.doc.invalid"],[/\*\//,"comment.doc","@pop"],[/[\/*]/,"comment.doc"]],string:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,"string","@pop"]],multistring:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"""/,"string","@pop"],[/./,"string"]]}}},8070:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>r});var i={comments:{lineComment:"#"},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"},{open:"`",close:"`"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"},{open:"`",close:"`"}]},r={defaultToken:"",tokenPostfix:".perl",brackets:[{token:"delimiter.bracket",open:"{",close:"}"},{token:"delimiter.parenthesis",open:"(",close:")"},{token:"delimiter.square",open:"[",close:"]"}],keywords:["__DATA__","else","lock","__END__","elsif","lt","__FILE__","eq","__LINE__","exp","ne","sub","__PACKAGE__","for","no","and","foreach","or","unless","cmp","ge","package","until","continue","gt","while","CORE","if","xor","do","le","__DIE__","__WARN__"],builtinFunctions:["-A","END","length","setpgrp","-B","endgrent","link","setpriority","-b","endhostent","listen","setprotoent","-C","endnetent","local","setpwent","-c","endprotoent","localtime","setservent","-d","endpwent","log","setsockopt","-e","endservent","lstat","shift","-f","eof","map","shmctl","-g","eval","mkdir","shmget","-k","exec","msgctl","shmread","-l","exists","msgget","shmwrite","-M","exit","msgrcv","shutdown","-O","fcntl","msgsnd","sin","-o","fileno","my","sleep","-p","flock","next","socket","-r","fork","not","socketpair","-R","format","oct","sort","-S","formline","open","splice","-s","getc","opendir","split","-T","getgrent","ord","sprintf","-t","getgrgid","our","sqrt","-u","getgrnam","pack","srand","-w","gethostbyaddr","pipe","stat","-W","gethostbyname","pop","state","-X","gethostent","pos","study","-x","getlogin","print","substr","-z","getnetbyaddr","printf","symlink","abs","getnetbyname","prototype","syscall","accept","getnetent","push","sysopen","alarm","getpeername","quotemeta","sysread","atan2","getpgrp","rand","sysseek","AUTOLOAD","getppid","read","system","BEGIN","getpriority","readdir","syswrite","bind","getprotobyname","readline","tell","binmode","getprotobynumber","readlink","telldir","bless","getprotoent","readpipe","tie","break","getpwent","recv","tied","caller","getpwnam","redo","time","chdir","getpwuid","ref","times","CHECK","getservbyname","rename","truncate","chmod","getservbyport","require","uc","chomp","getservent","reset","ucfirst","chop","getsockname","return","umask","chown","getsockopt","reverse","undef","chr","glob","rewinddir","UNITCHECK","chroot","gmtime","rindex","unlink","close","goto","rmdir","unpack","closedir","grep","say","unshift","connect","hex","scalar","untie","cos","index","seek","use","crypt","INIT","seekdir","utime","dbmclose","int","select","values","dbmopen","ioctl","semctl","vec","defined","join","semget","wait","delete","keys","semop","waitpid","DESTROY","kill","send","wantarray","die","last","setgrent","warn","dump","lc","sethostent","write","each","lcfirst","setnetent"],builtinFileHandlers:["ARGV","STDERR","STDOUT","ARGVOUT","STDIN","ENV"],builtinVariables:["$!","$^RE_TRIE_MAXBUF","$LAST_REGEXP_CODE_RESULT",'$"',"$^S","$LIST_SEPARATOR","$#","$^T","$MATCH","$$","$^TAINT","$MULTILINE_MATCHING","$%","$^UNICODE","$NR","$&","$^UTF8LOCALE","$OFMT","$'","$^V","$OFS","$(","$^W","$ORS","$)","$^WARNING_BITS","$OS_ERROR","$*","$^WIDE_SYSTEM_CALLS","$OSNAME","$+","$^X","$OUTPUT_AUTO_FLUSH","$,","$_","$OUTPUT_FIELD_SEPARATOR","$-","$`","$OUTPUT_RECORD_SEPARATOR","$.","$a","$PERL_VERSION","$/","$ACCUMULATOR","$PERLDB","$0","$ARG","$PID","$:","$ARGV","$POSTMATCH","$;","$b","$PREMATCH","$<","$BASETIME","$PROCESS_ID","$=","$CHILD_ERROR","$PROGRAM_NAME","$>","$COMPILING","$REAL_GROUP_ID","$?","$DEBUGGING","$REAL_USER_ID","$@","$EFFECTIVE_GROUP_ID","$RS","$[","$EFFECTIVE_USER_ID","$SUBSCRIPT_SEPARATOR","$\\","$EGID","$SUBSEP","$]","$ERRNO","$SYSTEM_FD_MAX","$^","$EUID","$UID","$^A","$EVAL_ERROR","$WARNING","$^C","$EXCEPTIONS_BEING_CAUGHT","$|","$^CHILD_ERROR_NATIVE","$EXECUTABLE_NAME","$~","$^D","$EXTENDED_OS_ERROR","%!","$^E","$FORMAT_FORMFEED","%^H","$^ENCODING","$FORMAT_LINE_BREAK_CHARACTERS","%ENV","$^F","$FORMAT_LINES_LEFT","%INC","$^H","$FORMAT_LINES_PER_PAGE","%OVERLOAD","$^I","$FORMAT_NAME","%SIG","$^L","$FORMAT_PAGE_NUMBER","@+","$^M","$FORMAT_TOP_NAME","@-","$^N","$GID","@_","$^O","$INPLACE_EDIT","@ARGV","$^OPEN","$INPUT_LINE_NUMBER","@INC","$^P","$INPUT_RECORD_SEPARATOR","@LAST_MATCH_START","$^R","$LAST_MATCH_END","$^RE_DEBUG_FLAGS","$LAST_PAREN_MATCH"],symbols:/[:+\-\^*$&%@=<>!?|\/~\.]/,quoteLikeOps:["qr","m","s","q","qq","qx","qw","tr","y"],escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,tokenizer:{root:[{include:"@whitespace"},[/[a-zA-Z\-_][\w\-_]*/,{cases:{"@keywords":"keyword","@builtinFunctions":"type.identifier","@builtinFileHandlers":"variable.predefined","@quoteLikeOps":{token:"@rematch",next:"quotedConstructs"},"@default":""}}],[/[\$@%][*@#?\+\-\$!\w\\\^><~:;\.]+/,{cases:{"@builtinVariables":"variable.predefined","@default":"variable"}}],{include:"@strings"},{include:"@dblStrings"},{include:"@perldoc"},{include:"@heredoc"},[/[{}\[\]()]/,"@brackets"],[/[\/](?:(?:\[(?:\\]|[^\]])+\])|(?:\\\/|[^\]\/]))*[\/]\w*\s*(?=[).,;]|$)/,"regexp"],[/@symbols/,"operators"],{include:"@numbers"},[/[,;]/,"delimiter"]],whitespace:[[/\s+/,"white"],[/(^#!.*$)/,"metatag"],[/(^#.*$)/,"comment"]],numbers:[[/\d*\.\d+([eE][\-+]?\d+)?/,"number.float"],[/0[xX][0-9a-fA-F_]*[0-9a-fA-F]/,"number.hex"],[/\d+/,"number"]],strings:[[/'/,"string","@stringBody"]],stringBody:[[/'/,"string","@popall"],[/\\'/,"string.escape"],[/./,"string"]],dblStrings:[[/"/,"string","@dblStringBody"]],dblStringBody:[[/"/,"string","@popall"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],{include:"@variables"},[/./,"string"]],quotedConstructs:[[/(q|qw|tr|y)\s*\(/,{token:"string.delim",switchTo:"@qstring.(.)"}],[/(q|qw|tr|y)\s*\[/,{token:"string.delim",switchTo:"@qstring.[.]"}],[/(q|qw|tr|y)\s*\{/,{token:"string.delim",switchTo:"@qstring.{.}"}],[/(q|qw|tr|y)\s*</,{token:"string.delim",switchTo:"@qstring.<.>"}],[/(q|qw|tr|y)#/,{token:"string.delim",switchTo:"@qstring.#.#"}],[/(q|qw|tr|y)\s*([^A-Za-z0-9#\s])/,{token:"string.delim",switchTo:"@qstring.$2.$2"}],[/(q|qw|tr|y)\s+(\w)/,{token:"string.delim",switchTo:"@qstring.$2.$2"}],[/(qr|m|s)\s*\(/,{token:"regexp.delim",switchTo:"@qregexp.(.)"}],[/(qr|m|s)\s*\[/,{token:"regexp.delim",switchTo:"@qregexp.[.]"}],[/(qr|m|s)\s*\{/,{token:"regexp.delim",switchTo:"@qregexp.{.}"}],[/(qr|m|s)\s*</,{token:"regexp.delim",switchTo:"@qregexp.<.>"}],[/(qr|m|s)#/,{token:"regexp.delim",switchTo:"@qregexp.#.#"}],[/(qr|m|s)\s*([^A-Za-z0-9_#\s])/,{token:"regexp.delim",switchTo:"@qregexp.$2.$2"}],[/(qr|m|s)\s+(\w)/,{token:"regexp.delim",switchTo:"@qregexp.$2.$2"}],[/(qq|qx)\s*\(/,{token:"string.delim",switchTo:"@qqstring.(.)"}],[/(qq|qx)\s*\[/,{token:"string.delim",switchTo:"@qqstring.[.]"}],[/(qq|qx)\s*\{/,{token:"string.delim",switchTo:"@qqstring.{.}"}],[/(qq|qx)\s*</,{token:"string.delim",switchTo:"@qqstring.<.>"}],[/(qq|qx)#/,{token:"string.delim",switchTo:"@qqstring.#.#"}],[/(qq|qx)\s*([^A-Za-z0-9#\s])/,{token:"string.delim",switchTo:"@qqstring.$2.$2"}],[/(qq|qx)\s+(\w)/,{token:"string.delim",switchTo:"@qqstring.$2.$2"}]],qstring:[[/\\./,"string.escape"],[/./,{cases:{"$#==$S3":{token:"string.delim",next:"@pop"},"$#==$S2":{token:"string.delim",next:"@push"},"@default":"string"}}]],qregexp:[{include:"@variables"},[/\\./,"regexp.escape"],[/./,{cases:{"$#==$S3":{token:"regexp.delim",next:"@regexpModifiers"},"$#==$S2":{token:"regexp.delim",next:"@push"},"@default":"regexp"}}]],regexpModifiers:[[/[msixpodualngcer]+/,{token:"regexp.modifier",next:"@popall"}]],qqstring:[{include:"@variables"},{include:"@qstring"}],heredoc:[[/<<\s*['"`]?([\w\-]+)['"`]?/,{token:"string.heredoc.delimiter",next:"@heredocBody.$1"}]],heredocBody:[[/^([\w\-]+)$/,{cases:{"$1==$S2":[{token:"string.heredoc.delimiter",next:"@popall"}],"@default":"string.heredoc"}}],[/./,"string.heredoc"]],perldoc:[[/^=\w/,"comment.doc","@perldocBody"]],perldocBody:[[/^=cut\b/,"type.identifier","@popall"],[/./,"comment.doc"]],variables:[[/\$\w+/,"variable"],[/@\w+/,"variable"],[/%\w+/,"variable"]]}}},3682:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>r});var i={comments:{lineComment:"#"},brackets:[["[","]"],["<",">"],["(",")"]],autoClosingPairs:[{open:"[",close:"]"},{open:"<",close:">"},{open:"(",close:")"}],surroundingPairs:[{open:"[",close:"]"},{open:"<",close:">"},{open:"(",close:")"}]},r={defaultToken:"",tokenPostfix:".pla",brackets:[{open:"[",close:"]",token:"delimiter.square"},{open:"<",close:">",token:"delimiter.angle"},{open:"(",close:")",token:"delimiter.parenthesis"}],keywords:[".i",".o",".mv",".ilb",".ob",".label",".type",".phase",".pair",".symbolic",".symbolic-output",".kiss",".p",".e",".end"],comment:/#.*$/,identifier:/[a-zA-Z]+[a-zA-Z0-9_\-]*/,plaContent:/[01\-~\|]+/,tokenizer:{root:[{include:"@whitespace"},[/@comment/,"comment"],[/\.([a-zA-Z_\-]+)/,{cases:{"@eos":{token:"keyword.$1"},"@keywords":{cases:{".type":{token:"keyword.$1",next:"@type"},"@default":{token:"keyword.$1",next:"@keywordArg"}}},"@default":{token:"keyword.$1"}}}],[/@identifier/,"identifier"],[/@plaContent/,"string"]],whitespace:[[/[ \t\r\n]+/,""]],type:[{include:"@whitespace"},[/\w+/,{token:"type",next:"@pop"}]],keywordArg:[[/[ \t\r\n]+/,{cases:{"@eos":{token:"",next:"@pop"},"@default":""}}],[/@comment/,"comment","@pop"],[/[<>()\[\]]/,{cases:{"@eos":{token:"@brackets",next:"@pop"},"@default":"@brackets"}}],[/\-?\d+/,{cases:{"@eos":{token:"number",next:"@pop"},"@default":"number"}}],[/@identifier/,{cases:{"@eos":{token:"identifier",next:"@pop"},"@default":"identifier"}}],[/[;=]/,{cases:{"@eos":{token:"delimiter",next:"@pop"},"@default":"delimiter"}}]]}}},7562:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>r});var i={wordPattern:/(-?\d*\.\d\w*)|([^\`\~\!\@\#%\^\&\*\(\)\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g,comments:{lineComment:"#",blockComment:["<#","#>"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"',notIn:["string"]},{open:"'",close:"'",notIn:["string","comment"]}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],folding:{markers:{start:new RegExp("^\\s*#region\\b"),end:new RegExp("^\\s*#endregion\\b")}}},r={defaultToken:"",ignoreCase:!0,tokenPostfix:".ps1",brackets:[{token:"delimiter.curly",open:"{",close:"}"},{token:"delimiter.square",open:"[",close:"]"},{token:"delimiter.parenthesis",open:"(",close:")"}],keywords:["begin","break","catch","class","continue","data","define","do","dynamicparam","else","elseif","end","exit","filter","finally","for","foreach","from","function","if","in","param","process","return","switch","throw","trap","try","until","using","var","while","workflow","parallel","sequence","inlinescript","configuration"],helpKeywords:/SYNOPSIS|DESCRIPTION|PARAMETER|EXAMPLE|INPUTS|OUTPUTS|NOTES|LINK|COMPONENT|ROLE|FUNCTIONALITY|FORWARDHELPTARGETNAME|FORWARDHELPCATEGORY|REMOTEHELPRUNSPACE|EXTERNALHELP/,symbols:/[=><!~?&%|+\-*\/\^;\.,]+/,escapes:/`(?:[abfnrtv\\"'$]|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,tokenizer:{root:[[/[a-zA-Z_][\w-]*/,{cases:{"@keywords":{token:"keyword.$0"},"@default":""}}],[/[ \t\r\n]+/,""],[/^:\w*/,"metatag"],[/\$(\{((global|local|private|script|using):)?[\w]+\}|((global|local|private|script|using):)?[\w]+)/,"variable"],[/<#/,"comment","@comment"],[/#.*$/,"comment"],[/[{}()\[\]]/,"@brackets"],[/@symbols/,"delimiter"],[/\d*\.\d+([eE][\-+]?\d+)?/,"number.float"],[/0[xX][0-9a-fA-F_]*[0-9a-fA-F]/,"number.hex"],[/\d+?/,"number"],[/[;,.]/,"delimiter"],[/\@"/,"string",'@herestring."'],[/\@'/,"string","@herestring.'"],[/"/,{cases:{"@eos":"string","@default":{token:"string",next:'@string."'}}}],[/'/,{cases:{"@eos":"string","@default":{token:"string",next:"@string.'"}}}]],string:[[/[^"'\$`]+/,{cases:{"@eos":{token:"string",next:"@popall"},"@default":"string"}}],[/@escapes/,{cases:{"@eos":{token:"string.escape",next:"@popall"},"@default":"string.escape"}}],[/`./,{cases:{"@eos":{token:"string.escape.invalid",next:"@popall"},"@default":"string.escape.invalid"}}],[/\$[\w]+$/,{cases:{'$S2=="':{token:"variable",next:"@popall"},"@default":{token:"string",next:"@popall"}}}],[/\$[\w]+/,{cases:{'$S2=="':"variable","@default":"string"}}],[/["']/,{cases:{"$#==$S2":{token:"string",next:"@pop"},"@default":{cases:{"@eos":{token:"string",next:"@popall"},"@default":"string"}}}}]],herestring:[[/^\s*(["'])@/,{cases:{"$1==$S2":{token:"string",next:"@pop"},"@default":"string"}}],[/[^\$`]+/,"string"],[/@escapes/,"string.escape"],[/`./,"string.escape.invalid"],[/\$[\w]+/,{cases:{'$S2=="':"variable","@default":"string"}}]],comment:[[/[^#\.]+/,"comment"],[/#>/,"comment","@pop"],[/(\.)(@helpKeywords)(?!\w)/,{token:"comment.keyword.$2"}],[/[\.#]/,"comment"]]}}},3760:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>r});var i={comments:{lineComment:"//",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"],["<",">"]],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:"<",close:">"},{open:'"',close:'"'},{open:"'",close:"'"}],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:"<",close:">"},{open:'"',close:'"',notIn:["string"]},{open:"'",close:"'",notIn:["string"]}],autoCloseBefore:".,=}])>' \n\t",indentationRules:{increaseIndentPattern:new RegExp("^((?!\\/\\/).)*(\\{[^}\"'`]*|\\([^)\"'`]*|\\[[^\\]\"'`]*)$"),decreaseIndentPattern:new RegExp("^((?!.*?\\/\\*).*\\*/)?\\s*[\\}\\]].*$")}},r={defaultToken:"",tokenPostfix:".proto",brackets:[{open:"{",close:"}",token:"delimiter.curly"},{open:"[",close:"]",token:"delimiter.square"},{open:"(",close:")",token:"delimiter.parenthesis"},{open:"<",close:">",token:"delimiter.angle"}],symbols:/[=><!~?:&|+\-*/^%]+/,keywords:["syntax","import","weak","public","package","option","repeated","oneof","map","reserved","to","max","enum","message","service","rpc","stream","returns","package","optional","true","false"],builtinTypes:["double","float","int32","int64","uint32","uint64","sint32","sint64","fixed32","fixed64","sfixed32","sfixed64","bool","string","bytes"],operators:["=","+","-"],namedLiterals:["true","false"],escapes:"\\\\(u{[0-9A-Fa-f]+}|n|r|t|\\\\|'|\\${)",identifier:/[a-zA-Z]\w*/,fullIdentifier:/@identifier(?:\s*\.\s*@identifier)*/,optionName:/(?:@identifier|\(\s*@fullIdentifier\s*\))(?:\s*\.\s*@identifier)*/,messageName:/@identifier/,enumName:/@identifier/,messageType:/\.?\s*(?:@identifier\s*\.\s*)*@messageName/,enumType:/\.?\s*(?:@identifier\s*\.\s*)*@enumName/,floatLit:/[0-9]+\s*\.\s*[0-9]*(?:@exponent)?|[0-9]+@exponent|\.[0-9]+(?:@exponent)?/,exponent:/[eE]\s*[+-]?\s*[0-9]+/,boolLit:/true\b|false\b/,decimalLit:/[1-9][0-9]*/,octalLit:/0[0-7]*/,hexLit:/0[xX][0-9a-fA-F]+/,type:/double|float|int32|int64|uint32|uint64|sint32|sint64|fixed32|fixed64|sfixed32|sfixed64|bool|string|bytes|@messageType|@enumType/,keyType:/int32|int64|uint32|uint64|sint32|sint64|fixed32|fixed64|sfixed32|sfixed64|bool|string/,tokenizer:{root:[{include:"@whitespace"},[/syntax/,"keyword"],[/=/,"operators"],[/;/,"delimiter"],[/(")(proto3)(")/,["string.quote","string",{token:"string.quote",switchTo:"@topLevel.proto3"}]],[/(")(proto2)(")/,["string.quote","string",{token:"string.quote",switchTo:"@topLevel.proto2"}]]],topLevel:[{include:"@whitespace"},{include:"@constant"},[/=/,"operators"],[/[;.]/,"delimiter"],[/@fullIdentifier/,{cases:{option:{token:"keyword",next:"@option.$S2"},enum:{token:"keyword",next:"@enumDecl.$S2"},message:{token:"keyword",next:"@messageDecl.$S2"},service:{token:"keyword",next:"@serviceDecl.$S2"},extend:{cases:{"$S2==proto2":{token:"keyword",next:"@extendDecl.$S2"}}},"@keywords":"keyword","@default":"identifier"}}]],enumDecl:[{include:"@whitespace"},[/@identifier/,"type.identifier"],[/{/,{token:"@brackets",bracket:"@open",switchTo:"@enumBody.$S2"}]],enumBody:[{include:"@whitespace"},{include:"@constant"},[/=/,"operators"],[/;/,"delimiter"],[/option\b/,"keyword","@option.$S2"],[/@identifier/,"identifier"],[/\[/,{token:"@brackets",bracket:"@open",next:"@options.$S2"}],[/}/,{token:"@brackets",bracket:"@close",next:"@pop"}]],messageDecl:[{include:"@whitespace"},[/@identifier/,"type.identifier"],[/{/,{token:"@brackets",bracket:"@open",switchTo:"@messageBody.$S2"}]],messageBody:[{include:"@whitespace"},{include:"@constant"},[/=/,"operators"],[/;/,"delimiter"],["(map)(s*)(<)",["keyword","white",{token:"@brackets",bracket:"@open",next:"@map.$S2"}]],[/@identifier/,{cases:{option:{token:"keyword",next:"@option.$S2"},enum:{token:"keyword",next:"@enumDecl.$S2"},message:{token:"keyword",next:"@messageDecl.$S2"},oneof:{token:"keyword",next:"@oneofDecl.$S2"},extensions:{cases:{"$S2==proto2":{token:"keyword",next:"@reserved.$S2"}}},reserved:{token:"keyword",next:"@reserved.$S2"},"(?:repeated|optional)":{token:"keyword",next:"@field.$S2"},required:{cases:{"$S2==proto2":{token:"keyword",next:"@field.$S2"}}},"$S2==proto3":{token:"@rematch",next:"@field.$S2"}}}],[/\[/,{token:"@brackets",bracket:"@open",next:"@options.$S2"}],[/}/,{token:"@brackets",bracket:"@close",next:"@pop"}]],extendDecl:[{include:"@whitespace"},[/@identifier/,"type.identifier"],[/{/,{token:"@brackets",bracket:"@open",switchTo:"@extendBody.$S2"}]],extendBody:[{include:"@whitespace"},{include:"@constant"},[/;/,"delimiter"],[/(?:repeated|optional|required)/,"keyword","@field.$S2"],[/\[/,{token:"@brackets",bracket:"@open",next:"@options.$S2"}],[/}/,{token:"@brackets",bracket:"@close",next:"@pop"}]],options:[{include:"@whitespace"},{include:"@constant"},[/;/,"delimiter"],[/@optionName/,"annotation"],[/[()]/,"annotation.brackets"],[/=/,"operator"],[/\]/,{token:"@brackets",bracket:"@close",next:"@pop"}]],option:[{include:"@whitespace"},[/@optionName/,"annotation"],[/[()]/,"annotation.brackets"],[/=/,"operator","@pop"]],oneofDecl:[{include:"@whitespace"},[/@identifier/,"identifier"],[/{/,{token:"@brackets",bracket:"@open",switchTo:"@oneofBody.$S2"}]],oneofBody:[{include:"@whitespace"},{include:"@constant"},[/;/,"delimiter"],[/(@identifier)(\s*)(=)/,["identifier","white","delimiter"]],[/@fullIdentifier|\./,{cases:{"@builtinTypes":"keyword","@default":"type.identifier"}}],[/\[/,{token:"@brackets",bracket:"@open",next:"@options.$S2"}],[/}/,{token:"@brackets",bracket:"@close",next:"@pop"}]],reserved:[{include:"@whitespace"},[/,/,"delimiter"],[/;/,"delimiter","@pop"],{include:"@constant"},[/to\b|max\b/,"keyword"]],map:[{include:"@whitespace"},[/@fullIdentifier|\./,{cases:{"@builtinTypes":"keyword","@default":"type.identifier"}}],[/,/,"delimiter"],[/>/,{token:"@brackets",bracket:"@close",switchTo:"identifier"}]],field:[{include:"@whitespace"},["group",{cases:{"$S2==proto2":{token:"keyword",switchTo:"@groupDecl.$S2"}}}],[/(@identifier)(\s*)(=)/,["identifier","white",{token:"delimiter",next:"@pop"}]],[/@fullIdentifier|\./,{cases:{"@builtinTypes":"keyword","@default":"type.identifier"}}]],groupDecl:[{include:"@whitespace"},[/@identifier/,"identifier"],["=","operator"],[/{/,{token:"@brackets",bracket:"@open",switchTo:"@messageBody.$S2"}],{include:"@constant"}],type:[{include:"@whitespace"},[/@identifier/,"type.identifier","@pop"],[/./,"delimiter"]],identifier:[{include:"@whitespace"},[/@identifier/,"identifier","@pop"]],serviceDecl:[{include:"@whitespace"},[/@identifier/,"identifier"],[/{/,{token:"@brackets",bracket:"@open",switchTo:"@serviceBody.$S2"}]],serviceBody:[{include:"@whitespace"},{include:"@constant"},[/;/,"delimiter"],[/option\b/,"keyword","@option.$S2"],[/rpc\b/,"keyword","@rpc.$S2"],[/\[/,{token:"@brackets",bracket:"@open",next:"@options.$S2"}],[/}/,{token:"@brackets",bracket:"@close",next:"@pop"}]],rpc:[{include:"@whitespace"},[/@identifier/,"identifier"],[/\(/,{token:"@brackets",bracket:"@open",switchTo:"@request.$S2"}],[/{/,{token:"@brackets",bracket:"@open",next:"@methodOptions.$S2"}],[/;/,"delimiter","@pop"]],request:[{include:"@whitespace"},[/@messageType/,{cases:{stream:{token:"keyword",next:"@type.$S2"},"@default":"type.identifier"}}],[/\)/,{token:"@brackets",bracket:"@close",switchTo:"@returns.$S2"}]],returns:[{include:"@whitespace"},[/returns\b/,"keyword"],[/\(/,{token:"@brackets",bracket:"@open",switchTo:"@response.$S2"}]],response:[{include:"@whitespace"},[/@messageType/,{cases:{stream:{token:"keyword",next:"@type.$S2"},"@default":"type.identifier"}}],[/\)/,{token:"@brackets",bracket:"@close",switchTo:"@rpc.$S2"}]],methodOptions:[{include:"@whitespace"},{include:"@constant"},[/;/,"delimiter"],["option","keyword"],[/@optionName/,"annotation"],[/[()]/,"annotation.brackets"],[/=/,"operator"],[/}/,{token:"@brackets",bracket:"@close",next:"@pop"}]],comment:[[/[^\/*]+/,"comment"],[/\/\*/,"comment","@push"],["\\*/","comment","@pop"],[/[\/*]/,"comment"]],string:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,{token:"string.quote",bracket:"@close",next:"@pop"}]],stringSingle:[[/[^\\']+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/'/,{token:"string.quote",bracket:"@close",next:"@pop"}]],constant:[["@boolLit","keyword.constant"],["@hexLit","number.hex"],["@octalLit","number.octal"],["@decimalLit","number"],["@floatLit","number.float"],[/("([^"\\]|\\.)*|'([^'\\]|\\.)*)$/,"string.invalid"],[/"/,{token:"string.quote",bracket:"@open",next:"@string"}],[/'/,{token:"string.quote",bracket:"@open",next:"@stringSingle"}],[/{/,{token:"@brackets",bracket:"@open",next:"@prototext"}],[/identifier/,"identifier"]],whitespace:[[/[ \t\r\n]+/,"white"],[/\/\*/,"comment","@comment"],[/\/\/.*$/,"comment"]],prototext:[{include:"@whitespace"},{include:"@constant"},[/@identifier/,"identifier"],[/[:;]/,"delimiter"],[/}/,{token:"@brackets",bracket:"@close",next:"@pop"}]]}}},1259:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>r});var i={brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}]},r={defaultToken:"",tokenPostfix:".redis",ignoreCase:!0,brackets:[{open:"[",close:"]",token:"delimiter.square"},{open:"(",close:")",token:"delimiter.parenthesis"}],keywords:["APPEND","AUTH","BGREWRITEAOF","BGSAVE","BITCOUNT","BITFIELD","BITOP","BITPOS","BLPOP","BRPOP","BRPOPLPUSH","CLIENT","KILL","LIST","GETNAME","PAUSE","REPLY","SETNAME","CLUSTER","ADDSLOTS","COUNT-FAILURE-REPORTS","COUNTKEYSINSLOT","DELSLOTS","FAILOVER","FORGET","GETKEYSINSLOT","INFO","KEYSLOT","MEET","NODES","REPLICATE","RESET","SAVECONFIG","SET-CONFIG-EPOCH","SETSLOT","SLAVES","SLOTS","COMMAND","COUNT","GETKEYS","CONFIG","GET","REWRITE","SET","RESETSTAT","DBSIZE","DEBUG","OBJECT","SEGFAULT","DECR","DECRBY","DEL","DISCARD","DUMP","ECHO","EVAL","EVALSHA","EXEC","EXISTS","EXPIRE","EXPIREAT","FLUSHALL","FLUSHDB","GEOADD","GEOHASH","GEOPOS","GEODIST","GEORADIUS","GEORADIUSBYMEMBER","GETBIT","GETRANGE","GETSET","HDEL","HEXISTS","HGET","HGETALL","HINCRBY","HINCRBYFLOAT","HKEYS","HLEN","HMGET","HMSET","HSET","HSETNX","HSTRLEN","HVALS","INCR","INCRBY","INCRBYFLOAT","KEYS","LASTSAVE","LINDEX","LINSERT","LLEN","LPOP","LPUSH","LPUSHX","LRANGE","LREM","LSET","LTRIM","MGET","MIGRATE","MONITOR","MOVE","MSET","MSETNX","MULTI","PERSIST","PEXPIRE","PEXPIREAT","PFADD","PFCOUNT","PFMERGE","PING","PSETEX","PSUBSCRIBE","PUBSUB","PTTL","PUBLISH","PUNSUBSCRIBE","QUIT","RANDOMKEY","READONLY","READWRITE","RENAME","RENAMENX","RESTORE","ROLE","RPOP","RPOPLPUSH","RPUSH","RPUSHX","SADD","SAVE","SCARD","SCRIPT","FLUSH","LOAD","SDIFF","SDIFFSTORE","SELECT","SETBIT","SETEX","SETNX","SETRANGE","SHUTDOWN","SINTER","SINTERSTORE","SISMEMBER","SLAVEOF","SLOWLOG","SMEMBERS","SMOVE","SORT","SPOP","SRANDMEMBER","SREM","STRLEN","SUBSCRIBE","SUNION","SUNIONSTORE","SWAPDB","SYNC","TIME","TOUCH","TTL","TYPE","UNSUBSCRIBE","UNLINK","UNWATCH","WAIT","WATCH","ZADD","ZCARD","ZCOUNT","ZINCRBY","ZINTERSTORE","ZLEXCOUNT","ZRANGE","ZRANGEBYLEX","ZREVRANGEBYLEX","ZRANGEBYSCORE","ZRANK","ZREM","ZREMRANGEBYLEX","ZREMRANGEBYRANK","ZREMRANGEBYSCORE","ZREVRANGE","ZREVRANGEBYSCORE","ZREVRANK","ZSCORE","ZUNIONSTORE","SCAN","SSCAN","HSCAN","ZSCAN"],operators:[],builtinFunctions:[],builtinVariables:[],pseudoColumns:[],tokenizer:{root:[{include:"@whitespace"},{include:"@pseudoColumns"},{include:"@numbers"},{include:"@strings"},{include:"@scopes"},[/[;,.]/,"delimiter"],[/[()]/,"@brackets"],[/[\w@#$]+/,{cases:{"@keywords":"keyword","@operators":"operator","@builtinVariables":"predefined","@builtinFunctions":"predefined","@default":"identifier"}}],[/[<>=!%&+\-*/|~^]/,"operator"]],whitespace:[[/\s+/,"white"]],pseudoColumns:[[/[$][A-Za-z_][\w@#$]*/,{cases:{"@pseudoColumns":"predefined","@default":"identifier"}}]],numbers:[[/0[xX][0-9a-fA-F]*/,"number"],[/[$][+-]*\d*(\.\d*)?/,"number"],[/((\d+(\.\d*)?)|(\.\d+))([eE][\-+]?\d+)?/,"number"]],strings:[[/'/,{token:"string",next:"@string"}],[/"/,{token:"string.double",next:"@stringDouble"}]],string:[[/[^']+/,"string"],[/''/,"string"],[/'/,{token:"string",next:"@pop"}]],stringDouble:[[/[^"]+/,"string.double"],[/""/,"string.double"],[/"/,{token:"string.double",next:"@pop"}]],scopes:[]}}},5062:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>r});var i={comments:{lineComment:"'"},brackets:[["(",")"],["[","]"],["If","EndIf"],["While","EndWhile"],["For","EndFor"],["Sub","EndSub"]],autoClosingPairs:[{open:'"',close:'"',notIn:["string","comment"]},{open:"(",close:")",notIn:["string","comment"]},{open:"[",close:"]",notIn:["string","comment"]}]},r={defaultToken:"",tokenPostfix:".sb",ignoreCase:!0,brackets:[{token:"delimiter.array",open:"[",close:"]"},{token:"delimiter.parenthesis",open:"(",close:")"},{token:"keyword.tag-if",open:"If",close:"EndIf"},{token:"keyword.tag-while",open:"While",close:"EndWhile"},{token:"keyword.tag-for",open:"For",close:"EndFor"},{token:"keyword.tag-sub",open:"Sub",close:"EndSub"}],keywords:["Else","ElseIf","EndFor","EndIf","EndSub","EndWhile","For","Goto","If","Step","Sub","Then","To","While"],tagwords:["If","Sub","While","For"],operators:[">","<","<>","<=",">=","And","Or","+","-","*","/","="],identifier:/[a-zA-Z_][\w]*/,symbols:/[=><:+\-*\/%\.,]+/,escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,tokenizer:{root:[{include:"@whitespace"},[/(@identifier)(?=[.])/,"type"],[/@identifier/,{cases:{"@keywords":{token:"keyword.$0"},"@operators":"operator","@default":"variable.name"}}],[/([.])(@identifier)/,{cases:{$2:["delimiter","type.member"],"@default":""}}],[/\d*\.\d+/,"number.float"],[/\d+/,"number"],[/[()\[\]]/,"@brackets"],[/@symbols/,{cases:{"@operators":"operator","@default":"delimiter"}}],[/"([^"\\]|\\.)*$/,"string.invalid"],[/"/,"string","@string"]],whitespace:[[/[ \t\r\n]+/,""],[/(\').*$/,"comment"]],string:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"C?/,"string","@pop"]]}}},2911:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>r});var i={comments:{lineComment:"//",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"},{open:"`",close:"`"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"},{open:"`",close:"`"}]},r={defaultToken:"",tokenPostfix:".swift",identifier:/[a-zA-Z_][\w$]*/,attributes:["@autoclosure","@noescape","@noreturn","@NSApplicationMain","@NSCopying","@NSManaged","@objc","@UIApplicationMain","@noreturn","@availability","@IBAction","@IBDesignable","@IBInspectable","@IBOutlet"],accessmodifiers:["public","private","fileprivate","internal"],keywords:["__COLUMN__","__FILE__","__FUNCTION__","__LINE__","as","as!","as?","associativity","break","case","catch","class","continue","convenience","default","deinit","didSet","do","dynamic","dynamicType","else","enum","extension","fallthrough","fileprivate","final","for","func","get","guard","if","import","in","infix","init","inout","internal","is","lazy","left","let","mutating","nil","none","nonmutating","operator","optional","override","postfix","precedence","prefix","private","protocol","Protocol","public","repeat","required","return","right","self","Self","set","static","struct","subscript","super","switch","throw","throws","try","try!","Type","typealias","unowned","var","weak","where","while","willSet","FALSE","TRUE"],symbols:/[=(){}\[\].,:;@#\_&\-<>`?!+*\\\/]/,operatorstart:/[\/=\-+!*%<>&|^~?\u00A1-\u00A7\u00A9\u00AB\u00AC\u00AE\u00B0-\u00B1\u00B6\u00BB\u00BF\u00D7\u00F7\u2016-\u2017\u2020-\u2027\u2030-\u203E\u2041-\u2053\u2055-\u205E\u2190-\u23FF\u2500-\u2775\u2794-\u2BFF\u2E00-\u2E7F\u3001-\u3003\u3008-\u3030]/,operatorend:/[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE00-\uFE0F\uFE20-\uFE2F\uE0100-\uE01EF]/,operators:/(@operatorstart)((@operatorstart)|(@operatorend))*/,escapes:/\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,tokenizer:{root:[{include:"@whitespace"},{include:"@comment"},{include:"@attribute"},{include:"@literal"},{include:"@keyword"},{include:"@invokedmethod"},{include:"@symbol"}],whitespace:[[/\s+/,"white"],[/"""/,"string.quote","@endDblDocString"]],endDblDocString:[[/[^"]+/,"string"],[/\\"/,"string"],[/"""/,"string.quote","@popall"],[/"/,"string"]],symbol:[[/[{}()\[\]]/,"@brackets"],[/[<>](?!@symbols)/,"@brackets"],[/[.]/,"delimiter"],[/@operators/,"operator"],[/@symbols/,"operator"]],comment:[[/\/\/\/.*$/,"comment.doc"],[/\/\*\*/,"comment.doc","@commentdocbody"],[/\/\/.*$/,"comment"],[/\/\*/,"comment","@commentbody"]],commentdocbody:[[/\/\*/,"comment","@commentbody"],[/\*\//,"comment.doc","@pop"],[/\:[a-zA-Z]+\:/,"comment.doc.param"],[/./,"comment.doc"]],commentbody:[[/\/\*/,"comment","@commentbody"],[/\*\//,"comment","@pop"],[/./,"comment"]],attribute:[[/@@@identifier/,{cases:{"@attributes":"keyword.control","@default":""}}]],literal:[[/"/,{token:"string.quote",next:"@stringlit"}],[/0[b]([01]_?)+/,"number.binary"],[/0[o]([0-7]_?)+/,"number.octal"],[/0[x]([0-9a-fA-F]_?)+([pP][\-+](\d_?)+)?/,"number.hex"],[/(\d_?)*\.(\d_?)+([eE][\-+]?(\d_?)+)?/,"number.float"],[/(\d_?)+/,"number"]],stringlit:[[/\\\(/,{token:"operator",next:"@interpolatedexpression"}],[/@escapes/,"string"],[/\\./,"string.escape.invalid"],[/"/,{token:"string.quote",next:"@pop"}],[/./,"string"]],interpolatedexpression:[[/\(/,{token:"operator",next:"@interpolatedexpression"}],[/\)/,{token:"operator",next:"@pop"}],{include:"@literal"},{include:"@keyword"},{include:"@symbol"}],keyword:[[/`/,{token:"operator",next:"@escapedkeyword"}],[/@identifier/,{cases:{"@keywords":"keyword","[A-Z][a-zA-Z0-9$]*":"type.identifier","@default":"identifier"}}]],escapedkeyword:[[/`/,{token:"operator",next:"@pop"}],[/./,"identifier"]],invokedmethod:[[/([.])(@identifier)/,{cases:{$2:["delimeter","type.identifier"],"@default":""}}]]}}},1886:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>r});var i={comments:{lineComment:"//",blockComment:["/*","*/"]},brackets:[["{","}"],["[","]"],["(",")"],["begin","end"],["case","endcase"],["casex","endcase"],["casez","endcase"],["checker","endchecker"],["class","endclass"],["clocking","endclocking"],["config","endconfig"],["function","endfunction"],["generate","endgenerate"],["group","endgroup"],["interface","endinterface"],["module","endmodule"],["package","endpackage"],["primitive","endprimitive"],["program","endprogram"],["property","endproperty"],["specify","endspecify"],["sequence","endsequence"],["table","endtable"],["task","endtask"]],autoClosingPairs:[{open:"[",close:"]"},{open:"{",close:"}"},{open:"(",close:")"},{open:"'",close:"'",notIn:["string","comment"]},{open:'"',close:'"',notIn:["string"]}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],folding:{offSide:!1,markers:{start:new RegExp("^(?:\\s*|.*(?!\\/[\\/\\*])[^\\w])(?:begin|case(x|z)?|class|clocking|config|covergroup|function|generate|interface|module|package|primitive|property|program|sequence|specify|table|task)\\b"),end:new RegExp("^(?:\\s*|.*(?!\\/[\\/\\*])[^\\w])(?:end|endcase|endclass|endclocking|endconfig|endgroup|endfunction|endgenerate|endinterface|endmodule|endpackage|endprimitive|endproperty|endprogram|endsequence|endspecify|endtable|endtask)\\b")}}},r={defaultToken:"",tokenPostfix:".sv",brackets:[{token:"delimiter.curly",open:"{",close:"}"},{token:"delimiter.parenthesis",open:"(",close:")"},{token:"delimiter.square",open:"[",close:"]"},{token:"delimiter.angle",open:"<",close:">"}],keywords:["accept_on","alias","always","always_comb","always_ff","always_latch","and","assert","assign","assume","automatic","before","begin","bind","bins","binsof","bit","break","buf","bufif0","bufif1","byte","case","casex","casez","cell","chandle","checker","class","clocking","cmos","config","const","constraint","context","continue","cover","covergroup","coverpoint","cross","deassign","default","defparam","design","disable","dist","do","edge","else","end","endcase","endchecker","endclass","endclocking","endconfig","endfunction","endgenerate","endgroup","endinterface","endmodule","endpackage","endprimitive","endprogram","endproperty","endspecify","endsequence","endtable","endtask","enum","event","eventually","expect","export","extends","extern","final","first_match","for","force","foreach","forever","fork","forkjoin","function","generate","genvar","global","highz0","highz1","if","iff","ifnone","ignore_bins","illegal_bins","implements","implies","import","incdir","include","initial","inout","input","inside","instance","int","integer","interconnect","interface","intersect","join","join_any","join_none","large","let","liblist","library","local","localparam","logic","longint","macromodule","matches","medium","modport","module","nand","negedge","nettype","new","nexttime","nmos","nor","noshowcancelled","not","notif0","notif1","null","or","output","package","packed","parameter","pmos","posedge","primitive","priority","program","property","protected","pull0","pull1","pulldown","pullup","pulsestyle_ondetect","pulsestyle_onevent","pure","rand","randc","randcase","randsequence","rcmos","real","realtime","ref","reg","reject_on","release","repeat","restrict","return","rnmos","rpmos","rtran","rtranif0","rtranif1","s_always","s_eventually","s_nexttime","s_until","s_until_with","scalared","sequence","shortint","shortreal","showcancelled","signed","small","soft","solve","specify","specparam","static","string","strong","strong0","strong1","struct","super","supply0","supply1","sync_accept_on","sync_reject_on","table","tagged","task","this","throughout","time","timeprecision","timeunit","tran","tranif0","tranif1","tri","tri0","tri1","triand","trior","trireg","type","typedef","union","unique","unique0","unsigned","until","until_with","untyped","use","uwire","var","vectored","virtual","void","wait","wait_order","wand","weak","weak0","weak1","while","wildcard","wire","with","within","wor","xnor","xor"],builtin_gates:["and","nand","nor","or","xor","xnor","buf","not","bufif0","bufif1","notif1","notif0","cmos","nmos","pmos","rcmos","rnmos","rpmos","tran","tranif1","tranif0","rtran","rtranif1","rtranif0"],operators:["=","+=","-=","*=","/=","%=","&=","|=","^=","<<=",">>+","<<<=",">>>=","?",":","+","-","!","~","&","~&","|","~|","^","~^","^~","+","-","*","/","%","==","!=","===","!==","==?","!=?","&&","||","**","<","<=",">",">=","&","|","^",">>","<<",">>>","<<<","++","--","->","<->","inside","dist","::","+:","-:","*>","&&&","|->","|=>","#=#"],symbols:/[=><!~?:&|+\-*\/\^%#]+/,escapes:/%%|\\(?:[antvf\\"']|x[0-9A-Fa-f]{1,2}|[0-7]{1,3})/,identifier:/(?:[a-zA-Z_][a-zA-Z0-9_$\.]*|\\\S+ )/,systemcall:/[$][a-zA-Z0-9_]+/,timeunits:/s|ms|us|ns|ps|fs/,tokenizer:{root:[[/^(\s*)(@identifier)/,["",{cases:{"@builtin_gates":{token:"keyword.$2",next:"@module_instance"},table:{token:"keyword.$2",next:"@table"},"@keywords":{token:"keyword.$2"},"@default":{token:"identifier",next:"@module_instance"}}}]],[/^\s*`include/,{token:"keyword.directive.include",next:"@include"}],[/^\s*`\s*\w+/,"keyword"],{include:"@identifier_or_keyword"},{include:"@whitespace"},[/\(\*.*\*\)/,"annotation"],[/@systemcall/,"variable.predefined"],[/[{}()\[\]]/,"@brackets"],[/[<>](?!@symbols)/,"@brackets"],[/@symbols/,{cases:{"@operators":"delimiter","@default":""}}],{include:"@numbers"},[/[;,.]/,"delimiter"],{include:"@strings"}],identifier_or_keyword:[[/@identifier/,{cases:{"@keywords":{token:"keyword.$0"},"@default":"identifier"}}]],numbers:[[/\d+?[\d_]*(?:\.[\d_]+)?[eE][\-+]?\d+/,"number.float"],[/\d+?[\d_]*\.[\d_]+(?:\s*@timeunits)?/,"number.float"],[/(?:\d+?[\d_]*\s*)?'[sS]?[dD]\s*[0-9xXzZ?]+?[0-9xXzZ?_]*/,"number"],[/(?:\d+?[\d_]*\s*)?'[sS]?[bB]\s*[0-1xXzZ?]+?[0-1xXzZ?_]*/,"number.binary"],[/(?:\d+?[\d_]*\s*)?'[sS]?[oO]\s*[0-7xXzZ?]+?[0-7xXzZ?_]*/,"number.octal"],[/(?:\d+?[\d_]*\s*)?'[sS]?[hH]\s*[0-9a-fA-FxXzZ?]+?[0-9a-fA-FxXzZ?_]*/,"number.hex"],[/1step/,"number"],[/[\dxXzZ]+?[\dxXzZ_]*(?:\s*@timeunits)?/,"number"],[/'[01xXzZ]+/,"number"]],module_instance:[{include:"@whitespace"},[/(#?)(\()/,["",{token:"@brackets",next:"@port_connection"}]],[/@identifier\s*[;={}\[\],]/,{token:"@rematch",next:"@pop"}],[/@symbols|[;={}\[\],]/,{token:"@rematch",next:"@pop"}],[/@identifier/,"type"],[/;/,"delimiter","@pop"]],port_connection:[{include:"@identifier_or_keyword"},{include:"@whitespace"},[/@systemcall/,"variable.predefined"],{include:"@numbers"},{include:"@strings"},[/[,]/,"delimiter"],[/\(/,"@brackets","@port_connection"],[/\)/,"@brackets","@pop"]],whitespace:[[/[ \t\r\n]+/,""],[/\/\*/,"comment","@comment"],[/\/\/.*$/,"comment"]],comment:[[/[^\/*]+/,"comment"],[/\*\//,"comment","@pop"],[/[\/*]/,"comment"]],strings:[[/"([^"\\]|\\.)*$/,"string.invalid"],[/"/,"string","@string"]],string:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,"string","@pop"]],include:[[/(\s*)(")([\w*\/*]*)(.\w*)(")/,["","string.include.identifier","string.include.identifier","string.include.identifier",{token:"string.include.identifier",next:"@pop"}]],[/(\s*)(<)([\w*\/*]*)(.\w*)(>)/,["","string.include.identifier","string.include.identifier","string.include.identifier",{token:"string.include.identifier",next:"@pop"}]]],table:[{include:"@whitespace"},[/[()]/,"@brackets"],[/[:;]/,"delimiter"],[/[01\-*?xXbBrRfFpPnN]/,"variable.predefined"],["endtable","keyword.endtable","@pop"]]}}},4902:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>r,language:()=>o});var i=t(9587),r={comments:{blockComment:["\x3c!--","--\x3e"]},brackets:[["<",">"]],autoClosingPairs:[{open:"<",close:">"},{open:"'",close:"'"},{open:'"',close:'"'}],surroundingPairs:[{open:"<",close:">"},{open:"'",close:"'"},{open:'"',close:'"'}],onEnterRules:[{beforeText:new RegExp("<([_:\\w][_:\\w-.\\d]*)([^/>]*(?!/)>)[^<]*$","i"),afterText:/^<\/([_:\w][_:\w-.\d]*)\s*>$/i,action:{indentAction:i.Mj.IndentAction.IndentOutdent}},{beforeText:new RegExp("<(\\w[\\w\\d]*)([^/>]*(?!/)>)[^<]*$","i"),action:{indentAction:i.Mj.IndentAction.Indent}}]},o={defaultToken:"",tokenPostfix:".xml",ignoreCase:!0,qualifiedName:/(?:[\w\.\-]+:)?[\w\.\-]+/,tokenizer:{root:[[/[^<&]+/,""],{include:"@whitespace"},[/(<)(@qualifiedName)/,[{token:"delimiter"},{token:"tag",next:"@tag"}]],[/(<\/)(@qualifiedName)(\s*)(>)/,[{token:"delimiter"},{token:"tag"},"",{token:"delimiter"}]],[/(<\?)(@qualifiedName)/,[{token:"delimiter"},{token:"metatag",next:"@tag"}]],[/(<\!)(@qualifiedName)/,[{token:"delimiter"},{token:"metatag",next:"@tag"}]],[/<\!\[CDATA\[/,{token:"delimiter.cdata",next:"@cdata"}],[/&\w+;/,"string.escape"]],cdata:[[/[^\]]+/,""],[/\]\]>/,{token:"delimiter.cdata",next:"@pop"}],[/\]/,""]],tag:[[/[ \t\r\n]+/,""],[/(@qualifiedName)(\s*=\s*)("[^"]*"|'[^']*')/,["attribute.name","","attribute.value"]],[/(@qualifiedName)(\s*=\s*)("[^">?\/]*|'[^'>?\/]*)(?=[\?\/]\>)/,["attribute.name","","attribute.value"]],[/(@qualifiedName)(\s*=\s*)("[^">]*|'[^'>]*)/,["attribute.name","","attribute.value"]],[/@qualifiedName/,"attribute.name"],[/\?>/,{token:"delimiter",next:"@pop"}],[/(\/)(>)/,[{token:"tag"},{token:"delimiter",next:"@pop"}]],[/>/,{token:"delimiter",next:"@pop"}]],whitespace:[[/[ \t\r\n]+/,""],[/<!--/,{token:"comment",next:"@comment"}]],comment:[[/[^<\-]+/,"comment.content"],[/-->/,{token:"comment",next:"@pop"}],[/<!--/,"comment.content.invalid"],[/[<\-]/,"comment.content"]]}}},3585:(e,n,t)=>{t.r(n),t.d(n,{conf:()=>i,language:()=>r});var i={comments:{lineComment:"#"},brackets:[["{","}"],["[","]"],["(",")"]],autoClosingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],surroundingPairs:[{open:"{",close:"}"},{open:"[",close:"]"},{open:"(",close:")"},{open:'"',close:'"'},{open:"'",close:"'"}],folding:{offSide:!0}},r={tokenPostfix:".yaml",brackets:[{token:"delimiter.bracket",open:"{",close:"}"},{token:"delimiter.square",open:"[",close:"]"}],keywords:["true","True","TRUE","false","False","FALSE","null","Null","Null","~"],numberInteger:/(?:0|[+-]?[0-9]+)/,numberFloat:/(?:0|[+-]?[0-9]+)(?:\.[0-9]+)?(?:e[-+][1-9][0-9]*)?/,numberOctal:/0o[0-7]+/,numberHex:/0x[0-9a-fA-F]+/,numberInfinity:/[+-]?\.(?:inf|Inf|INF)/,numberNaN:/\.(?:nan|Nan|NAN)/,numberDate:/\d{4}-\d\d-\d\d([Tt ]\d\d:\d\d:\d\d(\.\d+)?(( ?[+-]\d\d?(:\d\d)?)|Z)?)?/,escapes:/\\(?:[btnfr\\"']|[0-7][0-7]?|[0-3][0-7]{2})/,tokenizer:{root:[{include:"@whitespace"},{include:"@comment"},[/%[^ ]+.*$/,"meta.directive"],[/---/,"operators.directivesEnd"],[/\.{3}/,"operators.documentEnd"],[/[-?:](?= )/,"operators"],{include:"@anchor"},{include:"@tagHandle"},{include:"@flowCollections"},{include:"@blockStyle"},[/@numberInteger(?![ \t]*\S+)/,"number"],[/@numberFloat(?![ \t]*\S+)/,"number.float"],[/@numberOctal(?![ \t]*\S+)/,"number.octal"],[/@numberHex(?![ \t]*\S+)/,"number.hex"],[/@numberInfinity(?![ \t]*\S+)/,"number.infinity"],[/@numberNaN(?![ \t]*\S+)/,"number.nan"],[/@numberDate(?![ \t]*\S+)/,"number.date"],[/(".*?"|'.*?'|.*?)([ \t]*)(:)( |$)/,["type","white","operators","white"]],{include:"@flowScalars"},[/[^#]+/,{cases:{"@keywords":"keyword","@default":"string"}}]],object:[{include:"@whitespace"},{include:"@comment"},[/\}/,"@brackets","@pop"],[/,/,"delimiter.comma"],[/:(?= )/,"operators"],[/(?:".*?"|'.*?'|[^,\{\[]+?)(?=: )/,"type"],{include:"@flowCollections"},{include:"@flowScalars"},{include:"@tagHandle"},{include:"@anchor"},{include:"@flowNumber"},[/[^\},]+/,{cases:{"@keywords":"keyword","@default":"string"}}]],array:[{include:"@whitespace"},{include:"@comment"},[/\]/,"@brackets","@pop"],[/,/,"delimiter.comma"],{include:"@flowCollections"},{include:"@flowScalars"},{include:"@tagHandle"},{include:"@anchor"},{include:"@flowNumber"},[/[^\],]+/,{cases:{"@keywords":"keyword","@default":"string"}}]],multiString:[[/^( +).+$/,"string","@multiStringContinued.$1"]],multiStringContinued:[[/^( *).+$/,{cases:{"$1==$S2":"string","@default":{token:"@rematch",next:"@popall"}}}]],whitespace:[[/[ \t\r\n]+/,"white"]],comment:[[/#.*$/,"comment"]],flowCollections:[[/\[/,"@brackets","@array"],[/\{/,"@brackets","@object"]],flowScalars:[[/"([^"\\]|\\.)*$/,"string.invalid"],[/'([^'\\]|\\.)*$/,"string.invalid"],[/'[^']*'/,"string"],[/"/,"string","@doubleQuotedString"]],doubleQuotedString:[[/[^\\"]+/,"string"],[/@escapes/,"string.escape"],[/\\./,"string.escape.invalid"],[/"/,"string","@pop"]],blockStyle:[[/[>|][0-9]*[+-]?$/,"operators","@multiString"]],flowNumber:[[/@numberInteger(?=[ \t]*[,\]\}])/,"number"],[/@numberFloat(?=[ \t]*[,\]\}])/,"number.float"],[/@numberOctal(?=[ \t]*[,\]\}])/,"number.octal"],[/@numberHex(?=[ \t]*[,\]\}])/,"number.hex"],[/@numberInfinity(?=[ \t]*[,\]\}])/,"number.infinity"],[/@numberNaN(?=[ \t]*[,\]\}])/,"number.nan"],[/@numberDate(?=[ \t]*[,\]\}])/,"number.date"]],tagHandle:[[/\![^ ]*/,"tag"]],anchor:[[/[&*][^ ]+/,"namespace"]]}}},5179:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});const i='import gleam/bit_string\nimport gleam/string\n\n/// Encodes a BitString into a base 64 encoded string.\n///\npub fn encode64(input: BitString, padding: Bool) -> String {\n  let encoded = do_encode64(input)\n  case padding {\n    True -> encoded\n    False -> string.replace(encoded, "=", "")\n  }\n}\n\nif erlang {\n  external fn do_encode64(BitString) -> String =\n    "base64" "encode"\n}\n\nif javascript {\n  external fn do_encode64(BitString) -> String =\n    "../gleam_stdlib.mjs" "encode64"\n}\n\n/// Decodes a base 64 encoded string into a `BitString`.\n///\npub fn decode64(encoded: String) -> Result(BitString, Nil) {\n  let padded = case bit_string.byte_size(bit_string.from_string(encoded)) % 4 {\n    0 -> encoded\n    n -> string.append(encoded, string.repeat("=", 4 - n))\n  }\n  do_decode64(padded)\n}\n\nif erlang {\n  external fn do_decode64(String) -> Result(BitString, Nil) =\n    "gleam_stdlib" "base_decode64"\n}\n\nif javascript {\n  external fn do_decode64(String) -> Result(BitString, Nil) =\n    "../gleam_stdlib.mjs" "decode64"\n}\n\n/// Encodes a `BitString` into a base 64 encoded string with URL and filename safe alphabet.\n///\npub fn url_encode64(input: BitString, padding: Bool) -> String {\n  encode64(input, padding)\n  |> string.replace("+", "-")\n  |> string.replace("/", "_")\n}\n\n/// Decodes a base 64 encoded string with URL and filename safe alphabet into a `BitString`.\n///\npub fn url_decode64(encoded: String) -> Result(BitString, Nil) {\n  encoded\n  |> string.replace("-", "+")\n  |> string.replace("_", "/")\n  |> decode64()\n}\n'},7202:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});const i='//// Working with raw bit string data.\n//// The `BitString` type should be used instead of a String type when not utf8\n//// encoded.\n\n/// Converts a UTF-8 `String` type into a raw `BitString` type.\n///\npub fn from_string(x: String) -> BitString {\n  do_from_string(x)\n}\n\nif erlang {\n  external fn do_from_string(String) -> BitString =\n    "gleam_stdlib" "identity"\n}\n\nif javascript {\n  external fn do_from_string(String) -> BitString =\n    "../gleam_stdlib.mjs" "bit_string_from_string"\n}\n\n/// Returns an integer which is the number of bytes in the bit string.\n///\npub fn byte_size(x: BitString) -> Int {\n  do_byte_size(x)\n}\n\nif erlang {\n  external fn do_byte_size(BitString) -> Int =\n    "erlang" "byte_size"\n}\n\nif javascript {\n  external fn do_byte_size(BitString) -> Int =\n    "../gleam_stdlib.mjs" "length"\n}\n\n/// Creates a new bit string by joining two binaries.\n///\n/// ## Examples\n///\n///    > append(to: from_string("butter"), suffix: from_string("fly"))\n///    from_string("butterfly")\n///\npub fn append(to first: BitString, suffix second: BitString) -> BitString {\n  concat([first, second])\n}\n\n/// Extracts a sub-section of a bit string.\n///\n/// The slice will start at given position and continue up to specified\n/// length.\n/// A negative length can be used to extract bytes at the end of a bit string.\n///\n/// This function runs in constant time.\n///\npub fn slice(\n  from string: BitString,\n  at position: Int,\n  take length: Int,\n) -> Result(BitString, Nil) {\n  do_slice(string, position, length)\n}\n\nif erlang {\n  external fn do_slice(\n    string: BitString,\n    position: Int,\n    length: Int,\n  ) -> Result(BitString, Nil) =\n    "gleam_stdlib" "bit_string_slice"\n}\n\nif javascript {\n  external fn do_slice(\n    string: BitString,\n    position: Int,\n    length: Int,\n  ) -> Result(BitString, Nil) =\n    "../gleam_stdlib.mjs" "bit_string_slice"\n}\n\n/// Tests to see whether a bit string is valid UTF-8.\n///\npub fn is_utf8(bits: BitString) -> Bool {\n  do_is_utf8(bits)\n}\n\nif erlang {\n  fn do_is_utf8(bits: BitString) -> Bool {\n    case bits {\n      <<>> -> True\n      <<_:utf8, rest:binary>> -> is_utf8(rest)\n      _ -> False\n    }\n  }\n}\n\nif javascript {\n  fn do_is_utf8(bits: BitString) -> Bool {\n    case to_string(bits) {\n      Ok(_) -> True\n      _ -> False\n    }\n  }\n}\n\n/// Converts a bit string to a string.\n///\n/// Returns an error if the bit string is invalid UTF-8 data.\n///\npub fn to_string(bits: BitString) -> Result(String, Nil) {\n  do_to_string(bits)\n}\n\nif erlang {\n  external fn unsafe_to_string(BitString) -> String =\n    "gleam_stdlib" "identity"\n\n  fn do_to_string(bits: BitString) -> Result(String, Nil) {\n    case is_utf8(bits) {\n      True -> Ok(unsafe_to_string(bits))\n      False -> Error(Nil)\n    }\n  }\n}\n\nif javascript {\n  external fn do_to_string(BitString) -> Result(String, Nil) =\n    "../gleam_stdlib.mjs" "bit_string_to_string"\n}\n\n/// Creates a new bit string by joining multiple binaries.\n///\n/// ## Examples\n///\n///    > concat([from_string("butter"), from_string("fly")])\n///    from_string("butterfly")\n///\npub fn concat(bit_strings: List(BitString)) -> BitString {\n  do_concat(bit_strings)\n}\n\nif erlang {\n  external fn do_concat(List(BitString)) -> BitString =\n    "gleam_stdlib" "bit_string_concat"\n}\n\nif javascript {\n  external fn do_concat(List(BitString)) -> BitString =\n    "../gleam_stdlib.mjs" "bit_string_concat"\n}\n'},9679:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});const i="//// A type with two possible values, `True` and `False`. Used to indicate whether\n//// things are... true or false!\n////\n//// Often is it clearer and offers more type safety to define a custom type\n//// than to use `Bool`. For example, rather than having a `is_teacher: Bool`\n//// field consider having a `role: SchoolRole` field where `SchoolRole` is a custom\n//// type that can be either `Student` or `Teacher`.\n\nimport gleam/order.{Order}\n\n/// Returns the opposite bool value.\n///\n/// This is the same as the `!` or `not` operators in some other languages.\n///\n/// ## Examples\n///\n///    > negate(True)\n///    False\n///\n///    > negate(False)\n///    True\n///\npub fn negate(bool: Bool) -> Bool {\n  case bool {\n    True -> False\n    False -> True\n  }\n}\n\n/// Returns the nor of two bools.\n///\n/// ## Examples\n///\n///    > nor(False, False)\n///    True\n///\n///    > nor(False, True)\n///    False\n///\n///    > nor(True, False)\n///    False\n///\n///    > nor(True, True)\n///    False\n///\npub fn nor(a: Bool, b: Bool) -> Bool {\n  case a, b {\n    False, False -> True\n    False, True -> False\n    True, False -> False\n    True, True -> False\n  }\n}\n\n/// Returns the nand of two bools.\n///\n/// ## Examples\n///\n///    > nand(False, False)\n///    True\n///\n///    > nand(False, True)\n///    True\n///\n///    > nand(True, False)\n///    True\n///\n///    > nand(True, True)\n///    False\n///\npub fn nand(a: Bool, b: Bool) -> Bool {\n  case a, b {\n    False, False -> True\n    False, True -> True\n    True, False -> True\n    True, True -> False\n  }\n}\n\n/// Returns the exclusive or of two bools.\n///\n/// ## Examples\n///\n///    > exclusive_or(False, False)\n///    False\n///\n///    > exclusive_or(False, True)\n///    True\n///\n///    > exclusive_or(True, False)\n///    True\n///\n///    > exclusive_or(True, True)\n///    False\n///\npub fn exclusive_or(a: Bool, b: Bool) -> Bool {\n  case a, b {\n    False, False -> False\n    False, True -> True\n    True, False -> True\n    True, True -> False\n  }\n}\n\n/// Returns the exclusive nor of two bools.\n///\n/// ## Examples\n///\n///    > exclusive_nor(False, False)\n///    True\n///\n///    > exclusive_nor(False, True)\n///    False\n///\n///    > exclusive_nor(True, False)\n///    False\n///\n///    > exclusive_nor(True, True)\n///    True\n///\npub fn exclusive_nor(a: Bool, b: Bool) -> Bool {\n  case a, b {\n    False, False -> True\n    False, True -> False\n    True, False -> False\n    True, True -> True\n  }\n}\n\n/// Compares two bools and returns the first value's `Order` to the second.\n///\n/// ## Examples\n///\n///    > import gleam/order\n///    > compare(True, False)\n///    order.Gt\n///\npub fn compare(a: Bool, with b: Bool) -> Order {\n  case a, b {\n    True, True -> order.Eq\n    True, False -> order.Gt\n    False, False -> order.Eq\n    False, True -> order.Lt\n  }\n}\n\n/// Returns `True` if either argument's value is `True`.\n///\n/// ## Examples\n///\n///    > max(True, False)\n///    True\n///\n///    > max(False, True)\n///    True\n///\n///    > max(False, False)\n///    False\n///\npub fn max(a: Bool, b: Bool) -> Bool {\n  case a {\n    True -> True\n    False -> b\n  }\n}\n\n/// Returns `False` if either bool value is `False`.\n///\n/// ## Examples\n///\n///    > min(True, False)\n///    False\n///\n///    > min(False, True)\n///    False\n///\n///    > min(False, False)\n///    False\n///\npub fn min(a: Bool, b: Bool) -> Bool {\n  case a {\n    False -> False\n    True -> b\n  }\n}\n\n/// Returns a numeric representation of the given bool.\n///\n/// ## Examples\n///\n///    > to_int(True)\n///    1\n///\n///    > to_int(False)\n///    0\n///\npub fn to_int(bool: Bool) -> Int {\n  case bool {\n    False -> 0\n    True -> 1\n  }\n}\n"},339:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});const i="/// Takes two functions and chains them together to form one function that takes\n/// the input from the first and returns the output of the second.\n///\npub fn compose(fun1: fn(a) -> b, fun2: fn(b) -> c) -> fn(a) -> c {\n  fn(a) { fun2(fun1(a)) }\n}\n\n/// Takes a function with arity two\n/// and returns a curried equivalent.\n/// `fn(a, b) -> c` becomes `fn(a) -> fn(b) -> c`.\npub fn curry2(fun: fn(a, b) -> value) {\n  fn(a) { fn(b) { fun(a, b) } }\n}\n\n/// Takes a function with arity three\n/// and returns a curried equivalent.\n/// `fn(a, b, c) -> d` becomes `fn(a) -> fn(b) -> fn(c) -> d`.\npub fn curry3(fun: fn(a, b, c) -> value) {\n  fn(a) { fn(b) { fn(c) { fun(a, b, c) } } }\n}\n\n/// Takes a function with arity four\n/// and returns a curried equivalent.\npub fn curry4(fun: fn(a, b, c, d) -> value) {\n  fn(a) { fn(b) { fn(c) { fn(d) { fun(a, b, c, d) } } } }\n}\n\n/// Takes a function with arity five\n/// and returns a curried equivalent.\npub fn curry5(fun: fn(a, b, c, d, e) -> value) {\n  fn(a) { fn(b) { fn(c) { fn(d) { fn(e) { fun(a, b, c, d, e) } } } } }\n}\n\n/// Takes a function with arity six\n/// and returns a curried equivalent.\npub fn curry6(fun: fn(a, b, c, d, e, f) -> value) {\n  fn(a) {\n    fn(b) { fn(c) { fn(d) { fn(e) { fn(f) { fun(a, b, c, d, e, f) } } } } }\n  }\n}\n\n/// Takes a function that takes two arguments and returns a new function that\n/// takes the same two arguments, but in reverse order.\n///\npub fn flip(fun: fn(a, b) -> c) -> fn(b, a) -> c {\n  fn(b, a) { fun(a, b) }\n}\n\n/// A function that always returns its input value.\n///\npub fn identity(x: a) -> a {\n  x\n}\n\n/// A function that takes a single argument and returns a new function that\n/// ignores its argument and always returns the input value.\n///\npub fn constant(value: a) -> fn(b) -> a {\n  fn(_) { value }\n}\n"},1018:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});const i='import gleam/order.{Order}\n\n/// Returns the absolute value of the input.\n///\n/// ## Examples\n///\n///    > absolute_value(-12)\n///    12\n///\n///    > absolute_value(10)\n///    10\n///\npub fn absolute_value(num: Int) -> Int {\n  case num >= 0 {\n    True -> num\n    False -> num * -1\n  }\n}\n\n/// Parses a given string as an int if possible.\n///\n/// ## Examples\n///\n///    > parse("2")\n///    Ok(2)\n///\n///    > parse("ABC")\n///    Error(Nil)\n///\npub fn parse(string) {\n  do_parse(string)\n}\n\nif erlang {\n  external fn do_parse(String) -> Result(Int, Nil) =\n    "gleam_stdlib" "parse_int"\n}\n\nif javascript {\n  external fn do_parse(String) -> Result(Int, Nil) =\n    "../gleam_stdlib.mjs" "parse_int"\n}\n\n/// Prints a given int to a string.\n///\n/// ## Examples\n///\n///    > to_string(2)\n///    "2"\n///\npub fn to_string(int) {\n  do_to_string(int)\n}\n\nif erlang {\n  external fn do_to_string(Int) -> String =\n    "erlang" "integer_to_binary"\n}\n\nif javascript {\n  external fn do_to_string(Int) -> String =\n    "../gleam_stdlib.mjs" "to_string"\n}\n\n/// Error value when trying to operate with a base out of the allowed range.\npub type InvalidBase {\n  InvalidBase\n}\n\n/// Prints a given int to a string using the base number provided.\n/// Supports only bases 2 to 36, for values outside of which this function returns an `Error(InvalidBase)`.\n/// For common bases (2, 8, 16, 36), use the `to_baseN` functions.\n///\n/// ## Examples\n///\n///    > to_base_string(2, 2)\n///    Ok("10")\n///\n///    > to_base_string(48, 16)\n///    Ok("30")\n///\n///    > to_base_string(48, 36)\n///    Ok("1C")\n///\n///    > to_base_string(48, 1)\n///    Error(InvalidBase)\n///\n///    > to_base_string(48, 37)\n///    Error(InvalidBase)\n///\npub fn to_base_string(int, base) -> Result(String, InvalidBase) {\n  case base >= 2 && base <= 36 {\n    True -> Ok(do_to_base_string(int, base))\n    False -> Error(InvalidBase)\n  }\n}\n\nif erlang {\n  external fn do_to_base_string(Int, Int) -> String =\n    "erlang" "integer_to_binary"\n}\n\nif javascript {\n  external fn do_to_base_string(Int, Int) -> String =\n    "../gleam_stdlib.mjs" "int_to_base_string"\n}\n\n/// Prints a given int to a string using base2.\n///\n/// ## Examples\n///\n///    > to_base2(2)\n///    "10"\n///\npub fn to_base2(int) {\n  do_to_base_string(int, 2)\n}\n\n/// Prints a given int to a string using base8.\n///\n/// ## Examples\n///\n///    > to_base8(15)\n///    "17"\n///\npub fn to_base8(int) {\n  do_to_base_string(int, 8)\n}\n\n/// Prints a given int to a string using base16.\n///\n/// ## Examples\n///\n///    > to_base16(48)\n///    "30"\n///\npub fn to_base16(int) {\n  do_to_base_string(int, 16)\n}\n\n/// Prints a given int to a string using base16.\n///\n/// ## Examples\n///\n///    > to_base36(48)\n///    "1C"\n///\npub fn to_base36(int) {\n  do_to_base_string(int, 36)\n}\n\n/// Takes an int and returns its value as a float.\n///\n/// ## Examples\n///\n/// ```\n/// > to_float(5)\n/// 5.\n///\n/// > to_float(0)\n/// 0.\n///\n/// > to_float(-3)\n/// -3.\n/// ```\n///\npub fn to_float(int) {\n  do_to_float(int)\n}\n\nif erlang {\n  external fn do_to_float(a: Int) -> Float =\n    "erlang" "float"\n}\n\nif javascript {\n  external fn do_to_float(a: Int) -> Float =\n    "../gleam_stdlib.mjs" "identity"\n}\n\n/// Restricts an int between a lower and upper bound.\n///\n/// ## Examples\n///\n/// ```\n/// > clamp(40, min: 50, max: 60)\n/// 50\n/// ```\n///\npub fn clamp(n: Int, min min_bound: Int, max max_bound: Int) -> Int {\n  n\n  |> min(max_bound)\n  |> max(min_bound)\n}\n\n/// Compares two ints, returning an order.\n///\n/// ## Examples\n///\n///    > compare(2, 3)\n///    Lt\n///\n///    > compare(4, 3)\n///    Gt\n///\n///    > compare(3, 3)\n///    Eq\n///\npub fn compare(a: Int, with b: Int) -> Order {\n  case a == b {\n    True -> order.Eq\n    False ->\n      case a < b {\n        True -> order.Lt\n        False -> order.Gt\n      }\n  }\n}\n\n/// Compares two ints, returning the smaller of the two.\n///\n/// ## Examples\n///\n///    > min(2, 3)\n///    2\n///\npub fn min(a: Int, b: Int) -> Int {\n  case a < b {\n    True -> a\n    False -> b\n  }\n}\n\n/// Compares two ints, returning the larger of the two.\n///\n/// ## Examples\n///\n///    > max(2, 3)\n///    3\n///\npub fn max(a: Int, b: Int) -> Int {\n  case a > b {\n    True -> a\n    False -> b\n  }\n}\n\n/// Returns whether the value provided is even.\n///\n/// ## Examples\n///\n///    > is_even(2)\n///    True\n///\n///    > is_even(3)\n///    False\n///\npub fn is_even(x: Int) -> Bool {\n  x % 2 == 0\n}\n\n/// Returns whether the value provided is odd.\n///\n/// ## Examples\n///\n///    > is_odd(3)\n///    True\n///\n///    > is_odd(2)\n///    False\n///\npub fn is_odd(x: Int) -> Bool {\n  x % 2 != 0\n}\n\n/// Returns the negative of the value provided.\n///\n/// ## Examples\n///\n///    > negate(1)\n///    -1\n///\npub fn negate(x: Int) -> Int {\n  -1 * x\n}\n\n/// Sums a list of ints.\n///\n/// ## Example\n///\n///    > sum([1, 2, 3])\n///    6\n///\npub fn sum(numbers: List(Int)) -> Int {\n  numbers\n  |> do_sum(0)\n}\n\nfn do_sum(numbers: List(Int), initial: Int) -> Int {\n  case numbers {\n    [] -> initial\n    [x, ..rest] -> do_sum(rest, x + initial)\n  }\n}\n\n/// Multiplies a list of ints and returns the product.\n///\n/// ## Example\n///\n///    > product([2, 3, 4])\n///    24\n///\npub fn product(numbers: List(Int)) -> Int {\n  case numbers {\n    [] -> 0\n    _ -> do_product(numbers, 1)\n  }\n}\n\nfn do_product(numbers: List(Int), initial: Int) -> Int {\n  case numbers {\n    [] -> initial\n    [x, ..rest] -> do_product(rest, x * initial)\n  }\n}\n\n/// Splits an integer into its digit representation in the specified base \n///\n/// ## Examples\n///\n///    > digits(234, 10)\n///    Ok([2,3,4])\n///\n///    > digits(234, 1)\n///    Error(InvalidBase)\n///\npub fn digits(number: Int, base: Int) -> Result(List(Int), InvalidBase) {\n  case base < 2 {\n    True -> Error(InvalidBase)\n    False -> Ok(do_digits(number, base, []))\n  }\n}\n\nfn do_digits(number: Int, base: Int, acc: List(Int)) -> List(Int) {\n  case absolute_value(number) < base {\n    True -> [number, ..acc]\n    False -> do_digits(number / base, base, [number % base, ..acc])\n  }\n}\n\n/// Joins a list of digits into a single value.\n/// Returns an error if the base is less than 2 or if the list contains a digit greater than or equal to the specified base.\n///\n/// ## Examples\n///\n///    > undigits([2,3,4], 10)\n///    Ok(234)\n///\n///    > undigits([2,3,4], 1)\n///    Error(InvalidBase)\n///\n///    > undigits([2,3,4], 2)\n///    Error(InvalidBase)\n///\npub fn undigits(numbers: List(Int), base: Int) -> Result(Int, InvalidBase) {\n  case base < 2 {\n    True -> Error(InvalidBase)\n    False -> do_undigits(numbers, base, 0)\n  }\n}\n\nfn do_undigits(\n  numbers: List(Int),\n  base: Int,\n  acc: Int,\n) -> Result(Int, InvalidBase) {\n  case numbers {\n    [] -> Ok(acc)\n    [digit, ..] if digit >= base -> Error(InvalidBase)\n    [digit, ..rest] -> do_undigits(rest, base, acc * base + digit)\n  }\n}\n'},6208:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});const i='/// Writes a string to standard output.\n///\n/// If you want your output to be printed on its own line see `println`.\n///\n/// ## Example\n///\n/// ```\n/// > io.print("Hi mum")\n/// // -> Hi mum\n/// Nil\n/// ```\n///\npub fn print(string: String) -> Nil {\n  do_print(string)\n}\n\nif erlang {\n  external fn do_print(string: String) -> Nil =\n    "gleam_stdlib" "print"\n}\n\nif javascript {\n  external fn do_print(String) -> Nil =\n    "../gleam_stdlib.mjs" "print"\n}\n\n/// Writes a string to standard output, appending a newline to the end.\n///\n/// ## Example\n///\n///    > io.println("Hi mum")\n///    // -> Hi mum\n///    Nil\n///\npub fn println(string: String) -> Nil {\n  do_println(string)\n}\n\nif erlang {\n  external fn do_println(string: String) -> Nil =\n    "gleam_stdlib" "println"\n}\n\nif javascript {\n  external fn do_println(String) -> Nil =\n    "../gleam_stdlib.mjs" "log"\n}\n\n/// Prints a value to standard output using Erlang syntax.\n///\n/// The value is returned after being printed so it can be used in pipelines.\n///\n/// ## Example\n///\n///    > io.debug("Hi mum")\n///    // -> <<"Hi mum">>\n///    "Hi mum"\n///\n///    > io.debug(Ok(1))\n///    // -> {ok, 1}\n///    Ok(1)\n///\n///    > import list\n///    > [1, 2]\n///    > |> list.map(fn(x) { x + 1 })\n///    > |> io.debug\n///    > |> list.map(fn(x) { x * 2 })\n///    // -> [2, 3]\n///    [4, 6]\n///\npub fn debug(term: anything) -> anything {\n  debug_print(term)\n  term\n}\n\nif erlang {\n  fn debug_print(term: anything) -> DoNotLeak {\n    erlang_fwrite("~tp\\n", [term])\n  }\n}\n\nif javascript {\n  external fn debug_print(anything) -> Nil =\n    "../gleam_stdlib.mjs" "debug"\n}\n\nif erlang {\n  external type DoNotLeak\n\n  external fn erlang_fwrite(String, List(a)) -> DoNotLeak =\n    "io" "fwrite"\n}\n'},981:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});const i='import gleam/list\nimport gleam/option.{None, Option, Some}\nimport gleam/map.{Map}\n\n// Internal private representation of an Iterator\ntype Action(element) {\n  Stop\n  Continue(element, fn() -> Action(element))\n}\n\n/// An iterator is a lazily evaluated sequence of element.\n///\n/// Iterators are useful when working with collections that are too large to\n/// fit in memory (or those that are infinite in size) as they only require the\n/// elements currently being processed to be in memory.\n///\n/// As a lazy data structure no work is done when an iterator is filters,\n/// mapped, etc, instead a new iterator is returned with these transformations\n/// applied to the stream. Once the stream has all the required transformations\n/// applied it can be evaluated using functions such as `fold` and `to_list`.\n///\npub opaque type Iterator(element) {\n  Iterator(continuation: fn() -> Action(element))\n}\n\n// Public API for iteration\npub type Step(element, accumulator) {\n  Next(element: element, accumulator: accumulator)\n  Done\n}\n\n// Shortcut for an empty iterator.\nfn stop() -> Action(element) {\n  Stop\n}\n\n// Creating Iterators\nfn do_unfold(\n  initial: acc,\n  f: fn(acc) -> Step(element, acc),\n) -> fn() -> Action(element) {\n  fn() {\n    case f(initial) {\n      Next(x, acc) -> Continue(x, do_unfold(acc, f))\n      Done -> Stop\n    }\n  }\n}\n\n/// Creates an iterator from a given function and accumulator.\n///\n/// The function is called on the accumulator and returns either `Done`,\n/// indicating the iterator has no more elements, or `Next` which contains a\n/// new element and accumulator. The element is yielded by the iterator and the\n/// new accumulator is used with the function to compute the next element in\n/// the sequence.\n///\n/// ## Examples\n///\n///    > unfold(from: 5, with: fn(n) {\n///    >  case n {\n///    >    0 -> Done\n///    >    n -> Next(element: n, accumulator: n - 1)\n///    >  }\n///    > })\n///    > |> to_list\n///    [5, 4, 3, 2, 1]\n///\npub fn unfold(\n  from initial: acc,\n  with f: fn(acc) -> Step(element, acc),\n) -> Iterator(element) {\n  initial\n  |> do_unfold(f)\n  |> Iterator\n}\n\n// TODO: test\n/// Creates an iterator that yields values created by calling a given function\n/// repeatedly.\n///\npub fn repeatedly(f: fn() -> element) -> Iterator(element) {\n  unfold(Nil, fn(_) { Next(f(), Nil) })\n}\n\n/// Creates an iterator that returns the same value infinitely.\n///\n/// ## Examples\n///\n///    > repeat(10)\n///    > |> take(4)\n///    > |> to_list\n///    [10, 10, 10, 10]\n///\npub fn repeat(x: element) -> Iterator(element) {\n  repeatedly(fn() { x })\n}\n\n/// Creates an iterator that yields each element from the given list.\n///\n/// ## Examples\n///\n///    > from_list([1, 2, 3, 4]) |> to_list\n///    [1, 2, 3, 4]\n///\npub fn from_list(list: List(element)) -> Iterator(element) {\n  let yield = fn(acc) {\n    case acc {\n      [] -> Done\n      [head, ..tail] -> Next(head, tail)\n    }\n  }\n  unfold(list, yield)\n}\n\n// Consuming Iterators\nfn do_fold(\n  continuation: fn() -> Action(e),\n  f: fn(acc, e) -> acc,\n  accumulator: acc,\n) -> acc {\n  case continuation() {\n    Continue(elem, next) -> do_fold(next, f, f(accumulator, elem))\n    Stop -> accumulator\n  }\n}\n\n/// Reduces an iterator of elements into a single value by calling a given\n/// function on each element in turn.\n///\n/// If called on an iterator of infinite length then this function will never\n/// return.\n///\n/// If you do not care about the end value and only wish to evaluate the\n/// iterator for side effects consider using the `run` function instead.\n///\n/// ## Examples\n///\n///    > [1, 2, 3, 4]\n///    > |> from_list\n///    > |> fold(from: 0, with: fn(acc, element) { element + acc })\n///    10\n///\npub fn fold(\n  over iterator: Iterator(e),\n  from initial: acc,\n  with f: fn(acc, e) -> acc,\n) -> acc {\n  iterator.continuation\n  |> do_fold(f, initial)\n}\n\n// TODO: test\n/// Evaluates all elements emitted by the given iterator. This function is useful for when\n/// you wish to trigger any side effects that would occur when evaluating\n/// the iterator.\n///\npub fn run(iterator: Iterator(e)) -> Nil {\n  fold(iterator, Nil, fn(_, _) { Nil })\n}\n\n/// Evaluates an iterator and returns all the elements as a list.\n///\n/// If called on an iterator of infinite length then this function will never\n/// return.\n///\n/// ## Examples\n///\n/// ```\n/// > [1, 2, 3] |> from_list |> map(fn(x) { x * 2 }) |> to_list\n/// [2, 4, 6]\n/// ```\n///\npub fn to_list(iterator: Iterator(element)) -> List(element) {\n  iterator\n  |> fold([], fn(acc, e) { [e, ..acc] })\n  |> list.reverse\n}\n\n/// Eagerly accesses the first value of an interator, returning a `Next`\n/// that contains the first value and the rest of the iterator.\n///\n/// If called on an empty iterator, `Done` is returned.\n///\n/// ## Examples\n///\n///    > assert Next(head, tail) =\n///    >   [1, 2, 3, 4]\n///    >   |> from_list\n///    >   |> step\n///    > head\n///    1\n///\n///    > tail |> to_list\n///    [2, 3, 4]\n///\n///    > empty() |> step\n///    Done\n///\npub fn step(iterator: Iterator(e)) -> Step(e, Iterator(e)) {\n  case iterator.continuation() {\n    Stop -> Done\n    Continue(e, a) -> Next(e, Iterator(a))\n  }\n}\n\nfn do_take(continuation: fn() -> Action(e), desired: Int) -> fn() -> Action(e) {\n  fn() {\n    case desired > 0 {\n      False -> Stop\n      True ->\n        case continuation() {\n          Stop -> Stop\n          Continue(e, next) -> Continue(e, do_take(next, desired - 1))\n        }\n    }\n  }\n}\n\n/// Creates an iterator that only yields the first `desired` elements.\n///\n/// If the iterator does not have enough elements all of them are yielded.\n///\n/// ## Examples\n///\n///    > [1, 2, 3, 4, 5] |> from_list |> take(up_to: 3) |> to_list\n///    [1, 2, 3]\n///\n///    > [1, 2] |> from_list |> take(up_to: 3) |> to_list\n///    [1, 2]\n///\npub fn take(from iterator: Iterator(e), up_to desired: Int) -> Iterator(e) {\n  iterator.continuation\n  |> do_take(desired)\n  |> Iterator\n}\n\nfn do_drop(continuation: fn() -> Action(e), desired: Int) -> Action(e) {\n  case continuation() {\n    Stop -> Stop\n    Continue(e, next) ->\n      case desired > 0 {\n        True -> do_drop(next, desired - 1)\n        False -> Continue(e, next)\n      }\n  }\n}\n\n/// Evaluates and discards the first N elements in an iterator, returning a new\n/// iterator.\n///\n/// If the iterator does not have enough elements an empty iterator is\n/// returned.\n///\n/// This function does not evaluate the elements of the iterator, the\n/// computation is performed when the iterator is later run.\n///\n/// ## Examples\n///\n///    > [1, 2, 3, 4, 5] |> from_list |> drop(up_to: 3) |> to_list\n///    [4, 5]\n///\n///    > [1, 2] |> from_list |> drop(up_to: 3) |> to_list\n///    []\n///\npub fn drop(from iterator: Iterator(e), up_to desired: Int) -> Iterator(e) {\n  fn() { do_drop(iterator.continuation, desired) }\n  |> Iterator\n}\n\nfn do_map(continuation: fn() -> Action(a), f: fn(a) -> b) -> fn() -> Action(b) {\n  fn() {\n    case continuation() {\n      Stop -> Stop\n      Continue(e, continuation) -> Continue(f(e), do_map(continuation, f))\n    }\n  }\n}\n\n/// Creates an iterator from an existing iterator and a transformation function.\n///\n/// Each element in the new iterator will be the result of calling the given\n/// function on the elements in the given iterator.\n///\n/// This function does not evaluate the elements of the iterator, the\n/// computation is performed when the iterator is later run.\n///\n/// ## Examples\n///\n///    > [1, 2, 3] |> from_list |> map(fn(x) { x * 2 }) |> to_list\n///    [2, 4, 6]\n///\npub fn map(over iterator: Iterator(a), with f: fn(a) -> b) -> Iterator(b) {\n  iterator.continuation\n  |> do_map(f)\n  |> Iterator\n}\n\nfn do_append(first: fn() -> Action(a), second: fn() -> Action(a)) -> Action(a) {\n  case first() {\n    Continue(e, first) -> Continue(e, fn() { do_append(first, second) })\n    Stop -> second()\n  }\n}\n\n/// Appends two iterators, producing a new iterator.\n///\n/// This function does not evaluate the elements of the iterators, the\n/// computation is performed when the resulting iterator is later run.\n///\n/// ## Examples\n///\n///    > [1, 2] |> from_list |> append([3, 4] |> from_list) |> to_list\n///    [1, 2, 3, 4]\n///\npub fn append(to first: Iterator(a), suffix second: Iterator(a)) -> Iterator(a) {\n  fn() { do_append(first.continuation, second.continuation) }\n  |> Iterator\n}\n\nfn do_flatten(flattened: fn() -> Action(Iterator(a))) -> Action(a) {\n  case flattened() {\n    Stop -> Stop\n    Continue(it, next_iterator) ->\n      do_append(it.continuation, fn() { do_flatten(next_iterator) })\n  }\n}\n\n/// Flattens an iterator of iterators, creating a new iterator.\n///\n/// This function does not evaluate the elements of the iterator, the\n/// computation is performed when the iterator is later run.\n///\n/// ## Examples\n///\n///    > from_list([[1, 2], [3, 4]]) |> map(from_list) |> flatten |> to_list\n///    [1, 2, 3, 4]\n///\npub fn flatten(iterator: Iterator(Iterator(a))) -> Iterator(a) {\n  fn() { do_flatten(iterator.continuation) }\n  |> Iterator\n}\n\n/// Creates an iterator from an existing iterator and a transformation function.\n///\n/// Each element in the new iterator will be the result of calling the given\n/// function on the elements in the given iterator and then flattening the\n/// results.\n///\n/// This function does not evaluate the elements of the iterator, the\n/// computation is performed when the iterator is later run.\n///\n/// ## Examples\n///\n///    > [1, 2] |> from_list |> flat_map(fn(x) { from_list([x, x + 1]) }) |> to_list\n///    [1, 2, 2, 3]\n///\npub fn flat_map(\n  over iterator: Iterator(a),\n  with f: fn(a) -> Iterator(b),\n) -> Iterator(b) {\n  iterator\n  |> map(f)\n  |> flatten\n}\n\nfn do_filter(\n  continuation: fn() -> Action(e),\n  predicate: fn(e) -> Bool,\n) -> Action(e) {\n  case continuation() {\n    Stop -> Stop\n    Continue(e, iterator) ->\n      case predicate(e) {\n        True -> Continue(e, fn() { do_filter(iterator, predicate) })\n        False -> do_filter(iterator, predicate)\n      }\n  }\n}\n\n/// Creates an iterator from an existing iterator and a predicate function.\n///\n/// The new iterator will contain elements from the first iterator for which\n/// the given function returns `True`.\n///\n/// This function does not evaluate the elements of the iterator, the\n/// computation is performed when the iterator is later run.\n///\n/// ## Examples\n///\n///    > import gleam/int\n///    > [1, 2, 3, 4] |> from_list |> filter(int.is_even) |> to_list\n///    [2, 4]\n///\npub fn filter(\n  iterator: Iterator(a),\n  for predicate: fn(a) -> Bool,\n) -> Iterator(a) {\n  fn() { do_filter(iterator.continuation, predicate) }\n  |> Iterator\n}\n\n/// Creates an iterator that repeats a given iterator infinitely.\n///\n/// ## Examples\n///\n///    > [1, 2] |> from_list |> cycle |> take(6) |> to_list\n///    [1, 2, 1, 2, 1, 2]\n///\npub fn cycle(iterator: Iterator(a)) -> Iterator(a) {\n  repeat(iterator)\n  |> flatten\n}\n\n/// Creates an iterator of ints, starting at a given start int and stepping by\n/// one to a given end int.\n///\n/// ## Examples\n///\n///    > range(from: 1, to: 5) |> to_list\n///    [1, 2, 3, 4]\n///\n///    > range(from: 1, to: -2) |> to_list\n///    [1, 0, -1]\n///\n///    > range(from: 0, to: 0) |> to_list\n///    []\n///\npub fn range(from start: Int, to stop: Int) -> Iterator(Int) {\n  let increment = case start < stop {\n    True -> 1\n    False -> -1\n  }\n\n  let next_step = fn(current) {\n    case current == stop {\n      True -> Done\n      False -> Next(current, current + increment)\n    }\n  }\n\n  unfold(start, next_step)\n}\n\nfn do_find(continuation: fn() -> Action(a), f: fn(a) -> Bool) -> Result(a, Nil) {\n  case continuation() {\n    Stop -> Error(Nil)\n    Continue(e, next) ->\n      case f(e) {\n        True -> Ok(e)\n        False -> do_find(next, f)\n      }\n  }\n}\n\n/// Finds the first element in a given iterator for which the given function returns\n/// `True`.\n///\n/// Returns `Error(Nil)` if the function does not return `True` for any of the\n/// elements.\n///\n/// ## Examples\n///\n///    > find(from_list([1, 2, 3]), fn(x) { x > 2 })\n///    Ok(3)\n///\n///    > find(from_list([1, 2, 3]), fn(x) { x > 4 })\n///    Error(Nil)\n///\n///    > find(empty(), fn(_) { True })\n///    Error(Nil)\n///\npub fn find(\n  in haystack: Iterator(a),\n  one_that is_desired: fn(a) -> Bool,\n) -> Result(a, Nil) {\n  haystack.continuation\n  |> do_find(is_desired)\n}\n\nfn do_index(\n  continuation: fn() -> Action(element),\n  next: Int,\n) -> fn() -> Action(#(Int, element)) {\n  fn() {\n    case continuation() {\n      Stop -> Stop\n      Continue(e, continuation) ->\n        Continue(#(next, e), do_index(continuation, next + 1))\n    }\n  }\n}\n\n/// Wraps values yielded from an iterator with indices, starting from 0.\n///\n/// ## Examples\n///\n///    > from_list(["a", "b", "c"]) |> index |> to_list\n///    [#(0, "a"), #(1, "b"), #(2, "c")]\n///\npub fn index(over iterator: Iterator(element)) -> Iterator(#(Int, element)) {\n  iterator.continuation\n  |> do_index(0)\n  |> Iterator\n}\n\n/// Creates an iterator that inifinitely applies a function to a value.\n///\n/// ## Examples\n///\n///    > iterate(1, fn(n) { n * 3 }) |> take(5) |> to_list\n///    [1, 3, 9, 27, 81]\n///\npub fn iterate(\n  from initial: element,\n  with f: fn(element) -> element,\n) -> Iterator(element) {\n  unfold(initial, fn(element) { Next(element, f(element)) })\n}\n\nfn do_take_while(\n  continuation: fn() -> Action(element),\n  predicate: fn(element) -> Bool,\n) -> fn() -> Action(element) {\n  fn() {\n    case continuation() {\n      Stop -> Stop\n      Continue(e, next) ->\n        case predicate(e) {\n          False -> Stop\n          True -> Continue(e, do_take_while(next, predicate))\n        }\n    }\n  }\n}\n\n/// Creates an iterator that yields elements while the predicate returns `True`.\n///\n/// ## Examples\n///\n///    > from_list([1, 2, 3, 2, 4]) |> take_while(satisfying: fn(x) { x < 3 }) |> to_list\n///    [1, 2]\n///\npub fn take_while(\n  in iterator: Iterator(element),\n  satisfying predicate: fn(element) -> Bool,\n) -> Iterator(element) {\n  iterator.continuation\n  |> do_take_while(predicate)\n  |> Iterator\n}\n\nfn do_drop_while(\n  continuation: fn() -> Action(element),\n  predicate: fn(element) -> Bool,\n) -> Action(element) {\n  case continuation() {\n    Stop -> Stop\n    Continue(e, next) ->\n      case predicate(e) {\n        False -> Continue(e, next)\n        True -> do_drop_while(next, predicate)\n      }\n  }\n}\n\n/// Creates an iterator that drops elements while the predicate returns `True`,\n/// and then yields the remaining elements.\n///\n/// ## Examples\n///\n///    > from_list([1, 2, 3, 4, 2, 5]) |> drop_while(satisfying: fn(x) { x < 4 }) |> to_list\n///    [4, 2, 5]\n///\npub fn drop_while(\n  in iterator: Iterator(element),\n  satisfying predicate: fn(element) -> Bool,\n) -> Iterator(element) {\n  fn() { do_drop_while(iterator.continuation, predicate) }\n  |> Iterator\n}\n\nfn do_scan(\n  continuation: fn() -> Action(element),\n  f: fn(acc, element) -> acc,\n  accumulator: acc,\n) -> fn() -> Action(acc) {\n  fn() {\n    case continuation() {\n      Stop -> Stop\n      Continue(el, next) -> {\n        let accumulated = f(accumulator, el)\n        Continue(accumulated, do_scan(next, f, accumulated))\n      }\n    }\n  }\n}\n\n/// Creates an iterator from an existing iterator and a stateful function.\n///\n/// Specifically, this behaves like `fold`, but yields intermediate results.\n///\n/// ## Examples\n///\n///    Generate a sequence of partial sums:\n///    > from_list([1, 2, 3, 4, 5]) |> scan(from: 0, with: fn(acc, el) { acc + el }) |> to_list\n///    [1, 3, 6, 10, 15]\n///\npub fn scan(\n  over iterator: Iterator(element),\n  from initial: acc,\n  with f: fn(acc, element) -> acc,\n) -> Iterator(acc) {\n  iterator.continuation\n  |> do_scan(f, initial)\n  |> Iterator\n}\n\nfn do_zip(\n  left: fn() -> Action(a),\n  right: fn() -> Action(b),\n) -> fn() -> Action(#(a, b)) {\n  fn() {\n    case left() {\n      Stop -> Stop\n      Continue(el_left, next_left) ->\n        case right() {\n          Stop -> Stop\n          Continue(el_right, next_right) ->\n            Continue(#(el_left, el_right), do_zip(next_left, next_right))\n        }\n    }\n  }\n}\n\n/// Zips two iterators together, emitting values from both\n/// until the shorter one runs out.\n///\n/// ## Examples\n///\n///    > from_list(["a", "b", "c"]) |> zip(range(20, 30)) |> to_list\n///    [#("a", 20), #("b", 21), #("c", 22)]\n///\npub fn zip(left: Iterator(a), right: Iterator(b)) -> Iterator(#(a, b)) {\n  do_zip(left.continuation, right.continuation)\n  |> Iterator\n}\n\n// Result of collecting a single chunk by key\ntype Chunk(element, key) {\n  AnotherBy(List(element), key, element, fn() -> Action(element))\n  LastBy(List(element))\n}\n\nfn next_chunk(\n  continuation: fn() -> Action(element),\n  f: fn(element) -> key,\n  previous_key: key,\n  current_chunk: List(element),\n) -> Chunk(element, key) {\n  case continuation() {\n    Stop -> LastBy(list.reverse(current_chunk))\n    Continue(e, next) -> {\n      let key = f(e)\n      case key == previous_key {\n        True -> next_chunk(next, f, key, [e, ..current_chunk])\n        False -> AnotherBy(list.reverse(current_chunk), key, e, next)\n      }\n    }\n  }\n}\n\nfn do_chunk(\n  continuation: fn() -> Action(element),\n  f: fn(element) -> key,\n  previous_key: key,\n  previous_element: element,\n) -> Action(List(element)) {\n  case next_chunk(continuation, f, previous_key, [previous_element]) {\n    LastBy(chunk) -> Continue(chunk, stop)\n    AnotherBy(chunk, key, el, next) ->\n      Continue(chunk, fn() { do_chunk(next, f, key, el) })\n  }\n}\n\n/// Creates an iterator that emits chunks of elements\n/// for which `f` returns the same value.\n///\n/// ## Examples\n///\n///    > from_list([1, 2, 2, 3, 4, 4, 6, 7, 7]) |> chunk(by: fn(n) { n % 2 }) |> to_list\n///    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n///\npub fn chunk(\n  over iterator: Iterator(element),\n  by f: fn(element) -> key,\n) -> Iterator(List(element)) {\n  fn() {\n    case iterator.continuation() {\n      Stop -> Stop\n      Continue(e, next) -> do_chunk(next, f, f(e), e)\n    }\n  }\n  |> Iterator\n}\n\n// Result of collecting a single sized chunk\ntype SizedChunk(element) {\n  Another(List(element), fn() -> Action(element))\n  Last(List(element))\n  NoMore\n}\n\nfn next_sized_chunk(\n  continuation: fn() -> Action(element),\n  left: Int,\n  current_chunk: List(element),\n) -> SizedChunk(element) {\n  case continuation() {\n    Stop ->\n      case current_chunk {\n        [] -> NoMore\n        remaining -> Last(list.reverse(remaining))\n      }\n    Continue(e, next) -> {\n      let chunk = [e, ..current_chunk]\n      case left > 1 {\n        False -> Another(list.reverse(chunk), next)\n        True -> next_sized_chunk(next, left - 1, chunk)\n      }\n    }\n  }\n}\n\nfn do_sized_chunk(\n  continuation: fn() -> Action(element),\n  count: Int,\n) -> fn() -> Action(List(element)) {\n  fn() {\n    case next_sized_chunk(continuation, count, []) {\n      NoMore -> Stop\n      Last(chunk) -> Continue(chunk, stop)\n      Another(chunk, next_element) ->\n        Continue(chunk, do_sized_chunk(next_element, count))\n    }\n  }\n}\n\n/// Creates an iterator that emits chunks of given size.\n///\n/// If the last chunk does not have `count` elements, it is yielded\n/// as a partial chunk, with less than `count` elements.\n///\n/// For any `count` less than 1 this function behaves as if it was set to 1.\n///\n/// ## Examples\n///\n///    > from_list([1, 2, 3, 4, 5, 6]) |> sized_chunk(into: 2) |> to_list\n///    [[1, 2], [3, 4], [5, 6]]\n///\n///    > from_list([1, 2, 3, 4, 5, 6, 7, 8]) |> sized_chunk(into: 3) |> to_list\n///    [[1, 2, 3], [4, 5, 6], [7, 8]]\n///\npub fn sized_chunk(\n  over iterator: Iterator(element),\n  into count: Int,\n) -> Iterator(List(element)) {\n  iterator.continuation\n  |> do_sized_chunk(count)\n  |> Iterator\n}\n\nfn do_intersperse(\n  continuation: fn() -> Action(element),\n  separator: element,\n) -> Action(element) {\n  case continuation() {\n    Stop -> Stop\n    Continue(e, next) -> {\n      let next_interspersed = fn() { do_intersperse(next, separator) }\n      Continue(separator, fn() { Continue(e, next_interspersed) })\n    }\n  }\n}\n\n/// Creates an iterator that yields the given `elem` element\n/// between elements emitted by the underlying iterator.\n///\n/// ## Examples\n///\n///    > empty() |> intersperse(with: 0) |> to_list\n///    []\n///\n///    > from_list([1]) |> intersperse(with: 0) |> to_list\n///    [1]\n///\n///    > from_list([1, 2, 3, 4, 5]) |> intersperse(with: 0) |> to_list\n///    [1, 0, 2, 0, 3, 0, 4, 0, 5]\n///\npub fn intersperse(\n  over iterator: Iterator(element),\n  with elem: element,\n) -> Iterator(element) {\n  fn() {\n    case iterator.continuation() {\n      Stop -> Stop\n      Continue(e, next) -> Continue(e, fn() { do_intersperse(next, elem) })\n    }\n  }\n  |> Iterator\n}\n\nfn do_any(\n  continuation: fn() -> Action(element),\n  predicate: fn(element) -> Bool,\n) -> Bool {\n  case continuation() {\n    Stop -> False\n    Continue(e, next) -> predicate(e) || do_any(next, predicate)\n  }\n}\n\n/// Returns `True` if any element emitted by the iterator satisfies the given predicate,\n/// `False` otherwise.\n///\n/// This function short-circuits once it finds a satisfying element.\n///\n/// An empty iterator results in `False`.\n///\n/// ## Examples\n///\n///    > empty() |> any(fn(n) { n % 2 == 0 })\n///    False\n///\n///    > from_list([1, 2, 5, 7, 9]) |> any(fn(n) { n % 2 == 0 })\n///    True\n///\n///    > from_list([1, 3, 5, 7, 9]) |> any(fn(n) { n % 2 == 0 })\n///    False\n///\npub fn any(\n  in iterator: Iterator(element),\n  satisfying predicate: fn(element) -> Bool,\n) -> Bool {\n  iterator.continuation\n  |> do_any(predicate)\n}\n\nfn do_all(\n  continuation: fn() -> Action(element),\n  predicate: fn(element) -> Bool,\n) -> Bool {\n  case continuation() {\n    Stop -> True\n    Continue(e, next) -> predicate(e) && do_all(next, predicate)\n  }\n}\n\n/// Returns `True` if all elements emitted by the iterator satisfy the given predicate,\n/// `False` otherwise.\n///\n/// This function short-circuits once it finds a non-satisfying element.\n///\n/// An empty iterator results in `True`.\n///\n/// ## Examples\n///\n///    > empty() |> all(fn(n) { n % 2 == 0 })\n///    True\n///\n///    > from_list([2, 4, 6, 8]) |> all(fn(n) { n % 2 == 0 })\n///    True\n///\n///    > from_list([2, 4, 5, 8]) |> all(fn(n) { n % 2 == 0 })\n///    False\n///\npub fn all(\n  in iterator: Iterator(element),\n  satisfying predicate: fn(element) -> Bool,\n) -> Bool {\n  iterator.continuation\n  |> do_all(predicate)\n}\n\nfn update_group_with(el: element) -> fn(Option(List(element))) -> List(element) {\n  fn(maybe_group) {\n    case maybe_group {\n      Some(group) -> [el, ..group]\n      None -> [el]\n    }\n  }\n}\n\nfn group_updater(\n  f: fn(element) -> key,\n) -> fn(Map(key, List(element)), element) -> Map(key, List(element)) {\n  fn(groups, elem) {\n    groups\n    |> map.update(f(elem), update_group_with(elem))\n  }\n}\n\n/// Returns a `Map(k, List(element))` of elements from the given iterator\n/// grouped with the given key function.\n///\n/// The order within each group is preserved from the iterator.\n///\n/// ## Examples\n///\n///    > from_list([1, 2, 3, 4, 5, 6]) |> group(by: fn(n) { n % 3 })\n///    map.from_list([#(0, [3, 6]), #(1, [1, 4]), #(2, [2, 5])])\n///\npub fn group(\n  in iterator: Iterator(element),\n  by key: fn(element) -> key,\n) -> Map(key, List(element)) {\n  iterator\n  |> fold(map.new(), group_updater(key))\n  |> map.map_values(fn(_, group) { list.reverse(group) })\n}\n\n/// This function acts similar to fold, but does not take an initial state.\n/// Instead, it starts from the first yielded element\n/// and combines it with each subsequent element in turn using the given function.\n/// The function is called as `f(accumulator, current_element)`.\n///\n/// Returns `Ok` to indicate a successful run, and `Error` if called on an empty iterator.\n///\n/// ## Examples\n///\n///    > from_list([]) |> reduce(fn(acc, x) { acc + x })\n///    Error(Nil)\n///\n///    > from_list([1, 2, 3, 4, 5]) |> reduce(fn(acc, x) { acc + x })\n///    Ok(15)\n///\npub fn reduce(\n  over iterator: Iterator(e),\n  with f: fn(e, e) -> e,\n) -> Result(e, Nil) {\n  case iterator.continuation() {\n    Stop -> Error(Nil)\n    Continue(e, next) ->\n      do_fold(next, f, e)\n      |> Ok\n  }\n}\n\n/// Returns the last element in the given iterator.\n///\n/// Returns `Error(Nil)` if the iterator is empty.\n///\n/// This function runs in linear time.\n///\n/// ## Examples\n///\n///    > empty() |> last\n///    Error(Nil)\n///\n///    > range(1, 10) |> last\n///    Ok(9)\n///\npub fn last(iterator: Iterator(element)) -> Result(element, Nil) {\n  iterator\n  |> reduce(fn(_, elem) { elem })\n}\n\n/// Creates an iterator that yields no elements.\n///\n/// ## Examples\n///\n///    > empty() |> to_list\n///    []\n///\npub fn empty() -> Iterator(element) {\n  Iterator(stop)\n}\n\n/// Creates an iterator that yields exactly one element provided by calling the given function.\n///\n/// ## Examples\n///\n///    > once(fn() { 1 }) |> to_list\n///    [1]\n///\npub fn once(f: fn() -> element) -> Iterator(element) {\n  fn() { Continue(f(), stop) }\n  |> Iterator\n}\n\n/// Creates an iterator that yields the given element exactly once.\n///\n/// ## Examples\n///\n///    > single(1) |> to_list\n///    [1]\n///\npub fn single(elem: element) -> Iterator(element) {\n  once(fn() { elem })\n}\n\nfn do_interleave(\n  current: fn() -> Action(element),\n  next: fn() -> Action(element),\n) -> Action(element) {\n  case current() {\n    Stop -> next()\n    Continue(e, next_other) ->\n      Continue(e, fn() { do_interleave(next, next_other) })\n  }\n}\n\n/// Creates an iterator that alternates between the two given iterators\n/// until both have run out.\n///\n/// ## Examples\n///\n///    > from_list([1, 2, 3, 4]) |> interleave(from_list([11, 12, 13, 14])) |> to_list\n///    [1, 11, 2, 12, 3, 13, 4, 14]\n///\n///    > from_list([1, 2, 3, 4]) |> interleave(from_list([100])) |> to_list\n///    [1, 100, 2, 3, 4]\n///\npub fn interleave(\n  left: Iterator(element),\n  with right: Iterator(element),\n) -> Iterator(element) {\n  fn() { do_interleave(left.continuation, right.continuation) }\n  |> Iterator\n}\n\nfn do_fold_until(\n  continuation: fn() -> Action(e),\n  f: fn(acc, e) -> list.ContinueOrStop(acc),\n  accumulator: acc,\n) -> acc {\n  case continuation() {\n    Stop -> accumulator\n    Continue(elem, next) ->\n      case f(accumulator, elem) {\n        list.Continue(accumulator) -> do_fold_until(next, f, accumulator)\n        list.Stop(accumulator) -> accumulator\n      }\n  }\n}\n\n/// Like `fold`, `fold_until` reduces an iterator of elements into a single value by calling a given\n/// function on each element in turn, but uses `list.ContinueOrStop` to determine\n/// whether or not to keep iterating.\n///\n/// If called on an iterator of infinite length then this function will only ever\n/// return if the function returns `list.Stop`.\n///\n///\n/// ## Examples\n///    > let f = fn(acc, e) {\n///    >   case e {\n///    >     _ if e < 4 -> list.Continue(e + acc)\n///    >     _ -> list.Stop(acc)\n///    >   }\n///    > }\n///    >\n///    > [1, 2, 3, 4]\n///    > |> from_list\n///    > |> iterator.fold_until(from: acc, with: f) \n///    6\n///\npub fn fold_until(\n  over iterator: Iterator(e),\n  from initial: acc,\n  with f: fn(acc, e) -> list.ContinueOrStop(acc),\n) -> acc {\n  iterator.continuation\n  |> do_fold_until(f, initial)\n}\n\nfn do_try_fold(\n  over continuation: fn() -> Action(a),\n  with f: fn(acc, a) -> Result(acc, err),\n  from accumulator: acc,\n) -> Result(acc, err) {\n  case continuation() {\n    Stop -> Ok(accumulator)\n    Continue(elem, next) -> {\n      try accumulator = f(accumulator, elem)\n      do_try_fold(next, f, accumulator)\n    }\n  }\n}\n\n/// A variant of fold that might fail.\n/// \n///\n/// The folding function should return `Result(accumulator, error)`.\n/// If the returned value is `Ok(accumulator)` try_fold will try the next value in the iterator.\n/// If the returned value is `Error(error)` try_fold will stop and return that error.\n///\n/// ## Examples\n/// \n///    > [1, 2, 3, 4]\n///    > |> iterator.from_list()\n///    > |> try_fold(0, fn(acc, i) {\n///    >   case i < 3 {\n///    >     True -> Ok(acc + i)\n///    >     False -> Error(Nil)\n///    >   }\n///    > })\n///    Error(Nil)\n///\npub fn try_fold(\n  over iterator: Iterator(e),\n  from initial: acc,\n  with f: fn(acc, e) -> Result(acc, err),\n) -> Result(acc, err) {\n  iterator.continuation\n  |> do_try_fold(f, initial)\n}\n\n/// Returns the first element yielded by the given iterator, if it exists,\n/// or `Error(Nil)` otherwise.\n///\n/// ## Examples\n///\n/// ```\n/// > from_list([1, 2, 3]) |> first\n/// Ok(1)\n///\n/// > empty() |> first\n/// Error(Nil)\n/// ```\npub fn first(from iterator: Iterator(e)) -> Result(e, Nil) {\n  case iterator.continuation() {\n    Stop -> Error(Nil)\n    Continue(e, _) -> Ok(e)\n  }\n}\n\n/// Returns nth element yielded by the given iterator, where 0 means the first element.\n///\n/// If there are not enough elements in the iterator, `Error(Nil)` is returned.\n///\n/// For any `index` less than 0 this function behaves as if it was set to 0.\n///\n/// ## Examples\n///\n/// ```\n/// > from_list([1, 2, 3, 4]) |> at(2)\n/// Ok(3)\n///\n/// > from_list([1, 2, 3, 4]) |> at(4)\n/// Error(Nil)\n///\n/// > empty() |> at(0)\n/// Error(Nil)\n/// ```\n///\npub fn at(in iterator: Iterator(e), get index: Int) -> Result(e, Nil) {\n  iterator\n  |> drop(index)\n  |> first\n}\n'},3722:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});const i="import gleam/list\n\n/// A queue is an ordered collection of elements. It is similar to a list, but\n/// unlike a list elements can be added to or removed from either the front or\n/// the back in a performant fashion.\n///\n/// The internal representation may be different for two queues with the same\n/// elements in the same order if the queues were constructed in different\n/// ways. This is the price paid for a queue's fast access at both the front\n/// and the back.\n///\n/// Because of unpredictable internal representation the equality operator `==`\n/// may return surprising results, and the `is_equal` and `is_logically_equal`\n/// functions are the recommended way to test queues for equality.\n///\npub opaque type Queue(element) {\n  Queue(in: List(element), out: List(element))\n}\n\n/// Creates a fresh queue that contains no values.\n///\npub fn new() -> Queue(a) {\n  Queue(in: [], out: [])\n}\n\n/// Converts a list of elements into a queue of the same elements in the same\n/// order. The head element in the list becomes the front element in the queue.\n///\n/// This function runs in constant time.\n///\n/// # Examples\n///\n///    > [1, 2, 3] |> from_list |> length\n///    3\n///\npub fn from_list(list: List(a)) -> Queue(a) {\n  Queue(in: [], out: list)\n}\n\n/// Converts a queue of elements into a list of the same elements in the same\n/// order. The front element in the queue becomes the head element in the list.\n///\n/// This function runs in linear time.\n///\n/// # Examples\n///\n///    > new() |> push_back(1) |> push_back(2) |> to_list\n///    [1, 2]\n///\npub fn to_list(queue: Queue(a)) -> List(a) {\n  queue.out\n  |> list.append(list.reverse(queue.in))\n}\n\n/// Determines whether or not the queue is empty.\n///\n/// This function runs in constant time.\n///\n/// ## Examples\n///\n///    > [] |> from_list |> is_empty\n///    True\n///\n///    > [1] |> from_list |> is_empty\n///    False\n///\n///    > [1, 2] |> from_list |> is_empty\n///    False\n///\npub fn is_empty(queue: Queue(a)) -> Bool {\n  queue.in == [] && queue.out == []\n}\n\n/// Counts the number of elements in a given queue.\n///\n/// This function has to traverse the queue to determine the number of elements,\n/// so it runs in linear time.\n///\n/// ## Examples\n///\n///    > length(from_list([]))\n///    0\n///\n///    > length(from_list([1]))\n///    1\n///\n///    > length(from_list([1, 2]))\n///    2\n///\npub fn length(queue: Queue(a)) -> Int {\n  list.length(queue.in) + list.length(queue.out)\n}\n\n/// Pushes an element onto the back of the queue.\n///\n/// # Examples\n///\n///    > [1, 2] |> from_list |> push_back(3) |> to_list\n///    [1, 2, 3]\n///\npub fn push_back(onto queue: Queue(a), this item: a) -> Queue(a) {\n  Queue(in: [item, ..queue.in], out: queue.out)\n}\n\n/// Pushes an element onto the front of the queue.\n///\n/// # Examples\n///\n///    > [0, 0] |> from_list |> push_front(1) |> to_list\n///    [1, 0, 0]\n///\npub fn push_front(onto queue: Queue(a), this item: a) -> Queue(a) {\n  Queue(in: queue.in, out: [item, ..queue.out])\n}\n\n/// Gets the last element from the queue, returning the\n/// element and a new queue without that element.\n///\n/// This function typically runs in constant time, but will occasionally run in\n/// linear time.\n///\n/// # Examples\n///\n///    > queue.new()\n///    > |> queue.push_back(0)\n///    > |> queue.push_back(1)\n///    > |> queue.pop_back()\n///    Ok(#(1, queue.push_front(queue.new(), 0)))\n///\n///    > queue.new()\n///    > |> queue.push_front(0)\n///    > |> queue.pop_back()\n///    Ok(#(0, queue.new()))\n///\n///    > queue.new()\n///    > |> queue.pop_back()\n///    Error(Nil)\n///\npub fn pop_back(from queue: Queue(a)) -> Result(#(a, Queue(a)), Nil) {\n  case queue {\n    Queue(in: [], out: []) -> Error(Nil)\n    Queue(in: [], out: out) -> pop_back(Queue(in: list.reverse(out), out: []))\n    Queue(in: [first, ..rest], out: out) -> {\n      let queue = Queue(in: rest, out: out)\n      Ok(#(first, queue))\n    }\n  }\n}\n\n/// Gets the first element from the queue, returning the\n/// element and a new queue without that element.\n///\n/// This function typically runs in constant time, but will occasionally run in\n/// linear time.\n///\n/// # Examples\n///\n///    > queue.new()\n///    > |> queue.push_front(1)\n///    > |> queue.push_front(0)\n///    > |> queue.pop_front()\n///    Ok(#(0, queue.push_back(queue.new(), 1)))\n///\n///    > queue.new()\n///    > |> queue.push_back(0)\n///    > |> queue.pop_front()\n///    Ok(#(0, queue.new()))\n///\n///    > queue.new()\n///    > |> queue.pop_back()\n///    Error(Nil)\n///\npub fn pop_front(from queue: Queue(a)) -> Result(#(a, Queue(a)), Nil) {\n  case queue {\n    Queue(in: [], out: []) -> Error(Nil)\n    Queue(in: in, out: []) -> pop_front(Queue(in: [], out: list.reverse(in)))\n    Queue(in: in, out: [first, ..rest]) -> {\n      let queue = Queue(in: in, out: rest)\n      Ok(#(first, queue))\n    }\n  }\n}\n\n/// Creates a new queue from a given queue containing the same elements, but in\n/// the opposite order.\n///\n/// This function runs in constant time.\n///\n/// ## Examples\n///\n///    > [] |> from_list |> reverse |> to_list\n///    []\n///\n///    > [1] |> from_list |> reverse |> to_list\n///    [1]\n///\n///    > [1, 2] |> from_list |> reverse |> to_list\n///    [2, 1]\n///\npub fn reverse(queue: Queue(a)) -> Queue(a) {\n  Queue(in: queue.out, out: queue.in)\n}\n\nfn check_equal(\n  xs: List(t),\n  x_tail: List(t),\n  ys: List(t),\n  y_tail: List(t),\n  eq: fn(t, t) -> Bool,\n) -> Bool {\n  case xs, x_tail, ys, y_tail {\n    [], [], [], [] -> True\n    [x, ..xs], _, [y, ..ys], _ ->\n      case eq(x, y) {\n        False -> False\n        True -> check_equal(xs, x_tail, ys, y_tail, eq)\n      }\n    [], [_, ..], _, _ -> check_equal(list.reverse(x_tail), [], ys, y_tail, eq)\n    _, _, [], [_, ..] -> check_equal(xs, x_tail, list.reverse(y_tail), [], eq)\n    _, _, _, _ -> False\n  }\n}\n\n/// Checks whether two queues have equal elements in the same order, where the\n/// equality of elements is determined by a given equality checking function.\n///\n/// This function is useful as the internal representation may be different for\n/// two queues with the same elements in the same order depending on how they\n/// were constructed, so the equality operator `==` may return surprising\n/// results.\n///\n/// This function runs in linear time multiplied by the time taken by the\n/// element equality checking function.\n///\npub fn is_logically_equal(\n  a: Queue(t),\n  to b: Queue(t),\n  checking element_is_equal: fn(t, t) -> Bool,\n) -> Bool {\n  check_equal(a.out, a.in, b.out, b.in, element_is_equal)\n}\n\n/// Checks whether two queues have the same elements in the same order.\n///\n/// This function is useful as the internal representation may be different for\n/// two queues with the same elements in the same order depending on how they\n/// were constructed, so the equality operator `==` may return surprising\n/// results.\n///\n/// This function runs in linear time.\n///\npub fn is_equal(a: Queue(t), to b: Queue(t)) -> Bool {\n  check_equal(a.out, a.in, b.out, b.in, fn(a, b) { a == b })\n}\n"},6500:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});const i='import {\n  BitString,\n  Error,\n  List,\n  Ok,\n  Result,\n  UtfCodepoint,\n  inspect,\n  stringBits,\n  toBitString,\n} from "./gleam.mjs";\nimport {\n  CompileError as RegexCompileError,\n  Match as RegexMatch,\n} from "./gleam/regex.mjs";\nimport { DecodeError } from "./gleam/dynamic.mjs";\nimport { Some, None } from "./gleam/option.mjs";\n\nconst HASHCODE_CACHE = new WeakMap();\n\nconst Nil = undefined;\n\nexport function identity(x) {\n  return x;\n}\n\nexport function parse_int(value) {\n  if (/^[-+]?(\\d+)$/.test(value)) {\n    return new Ok(parseInt(value));\n  } else {\n    return new Error(Nil);\n  }\n}\n\nexport function parse_float(value) {\n  if (/^[-+]?(\\d+)\\.(\\d+)$/.test(value)) {\n    return new Ok(parseFloat(value));\n  } else {\n    return new Error(Nil);\n  }\n}\n\nexport function to_string(term) {\n  return term.toString();\n}\n\nexport function float_to_string(float) {\n  let string = float.toString();\n  if (string.indexOf(".") >= 0) {\n    return string;\n  } else {\n    return string + ".0";\n  }\n}\n\nexport function int_to_base_string(int, base) {\n  return int.toString(base).toUpperCase();\n}\n\nexport function string_replace(string, target, substitute) {\n  return string.replaceAll(target, substitute);\n}\n\nexport function string_reverse(string) {\n  return [...string].reverse().join("");\n}\n\nexport function string_length(string) {\n  let iterator = graphemes_iterator(string);\n  if (iterator) {\n    let i = 0;\n    for (let _ of iterator) {\n      i++;\n    }\n    return i;\n  } else {\n    return string.match(/./gu).length;\n  }\n}\n\nfunction graphemes_iterator(string) {\n  if (Intl && Intl.Segmenter) {\n    return new Intl.Segmenter("en-gb").segment(string)[Symbol.iterator]();\n  }\n}\n\nexport function pop_grapheme(string) {\n  let first;\n  let iterator = graphemes_iterator(string);\n  if (iterator) {\n    first = iterator.next().value?.segment;\n  } else {\n    first = string.match(/./u)?.[0];\n  }\n  if (first) {\n    return new Ok([first, string.slice(first.length)]);\n  } else {\n    return new Error(Nil);\n  }\n}\n\nexport function lowercase(string) {\n  return string.toLowerCase();\n}\n\nexport function uppercase(string) {\n  return string.toUpperCase();\n}\n\nexport function less_than(a, b) {\n  return a < b;\n}\n\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function equal(a, b) {\n  return a === b;\n}\n\nexport function split(xs, pattern) {\n  return List.fromArray(xs.split(pattern));\n}\n\nexport function join(xs) {\n  return xs.toArray().join("");\n}\n\nexport function length(data) {\n  return data.length;\n}\n\nexport function slice_string(string, from, length) {\n  return string.slice(from, from + length);\n}\n\nexport function crop_string(string, substring) {\n  return string.substring(string.indexOf(substring));\n}\n\nexport function index_of(haystack, needle) {\n  return haystack.indexOf(needle) | 0;\n}\n\nexport function starts_with(haystack, needle) {\n  return haystack.startsWith(needle);\n}\n\nexport function ends_with(haystack, needle) {\n  return haystack.endsWith(needle);\n}\n\nexport function split_once(haystack, needle) {\n  let index = haystack.indexOf(needle);\n  if (index >= 0) {\n    let before = haystack.slice(0, index);\n    let after = haystack.slice(index + needle.length);\n    return new Ok([before, after]);\n  } else {\n    return new Error(Nil);\n  }\n}\n\nexport function trim(string) {\n  return string.trim();\n}\n\nexport function trim_left(string) {\n  return string.trimLeft();\n}\n\nexport function trim_right(string) {\n  return string.trimRight();\n}\n\nexport function bit_string_from_string(string) {\n  return new toBitString([stringBits(string)]);\n}\n\nexport function bit_string_concat(bit_strings) {\n  return toBitString(bit_strings.toArray().map((b) => b.buffer));\n}\n\nexport function log(term) {\n  console.log(term);\n}\n\nexport function debug(term) {\n  console.log(inspect(term));\n}\n\nexport function crash(message) {\n  throw new globalThis.Error(message);\n}\n\nexport function bit_string_to_string(bit_string) {\n  try {\n    let decoder = new TextDecoder("utf-8", { fatal: true });\n    return new Ok(decoder.decode(bit_string.buffer));\n  } catch (_error) {\n    return new Error(undefined);\n  }\n}\n\nexport function print(string) {\n  if (typeof process === "object") {\n    process.stdout.write(string); // We can write without a trailing newline\n  } else {\n    console.log(string); // We\'re in a browser. Newlines are mandated\n  }\n}\n\nexport function ceiling(float) {\n  return Math.ceil(float);\n}\n\nexport function floor(float) {\n  return Math.floor(float);\n}\n\nexport function round(float) {\n  return Math.round(float);\n}\n\nexport function truncate(float) {\n  return Math.trunc(float);\n}\n\nexport function power(base, exponent) {\n  return Math.pow(base, exponent);\n}\n\nexport function bit_string_slice(bits, position, length) {\n  let start = Math.min(position, position + length);\n  let end = Math.max(position, position + length);\n  if (start < 0 || end > bits.length) return new Error(Nil);\n  let buffer = new Uint8Array(bits.buffer.buffer, start, Math.abs(length));\n  return new Ok(new BitString(buffer));\n}\n\nexport function codepoint(int) {\n  return new UtfCodepoint(int);\n}\n\nexport function regex_check(regex, string) {\n  return regex.test(string);\n}\n\nexport function compile_regex(pattern, options) {\n  try {\n    let flags = "gu";\n    if (options.case_insensitive) flags += "i";\n    if (options.multi_line) flags += "m";\n    return new Ok(new RegExp(pattern, flags));\n  } catch (error) {\n    let number = (error.columnNumber || 0) | 0;\n    return new Error(new RegexCompileError(error.message, number));\n  }\n}\n\nexport function regex_scan(regex, string) {\n  let matches = Array.from(string.matchAll(regex)).map((match) => {\n    let content = match.shift();\n    let submatches = match.map((x) => (x ? new Some(x) : new None()));\n    return new RegexMatch(content, List.fromArray(submatches));\n  });\n  return List.fromArray(matches);\n}\n\nclass Map {\n  static #hashcode_cache = new WeakMap();\n\n  static hash(value) {\n    let existing = this.#hashcode_cache.get(value);\n    if (existing) {\n      return existing;\n    } else if (value instanceof Object) {\n      let hashcode = JSON.stringify(value);\n      HASHCODE_CACHE.set(value, hashcode);\n      return hashcode;\n    } else {\n      return value.toString();\n    }\n  }\n\n  constructor() {\n    this.entries = new globalThis.Map();\n  }\n\n  get size() {\n    return this.entries.size;\n  }\n\n  inspect() {\n    let entries = [...this.entries.values()]\n      .map((pair) => inspect(pair))\n      .join(", ");\n    return `map.from_list([${entries}])`;\n  }\n\n  copy() {\n    let map = new Map();\n    map.entries = new globalThis.Map(this.entries);\n    return map;\n  }\n\n  toList() {\n    return List.fromArray([...this.entries.values()]);\n  }\n\n  insert(k, v) {\n    let map = this.copy();\n    map.entries.set(Map.hash(k), [k, v]);\n    return map;\n  }\n\n  delete(k) {\n    let map = this.copy();\n    map.entries.delete(Map.hash(k));\n    return map;\n  }\n\n  get(key) {\n    let code = Map.hash(key);\n    if (this.entries.has(code)) {\n      return new Ok(this.entries.get(code)[1]);\n    } else {\n      return new Error(Nil);\n    }\n  }\n}\n\nexport function new_map() {\n  return new Map();\n}\n\nexport function map_size(map) {\n  return map.size;\n}\n\nexport function map_to_list(map) {\n  return map.toList();\n}\n\nexport function map_remove(k, map) {\n  return map.delete(k);\n}\n\nexport function map_get(map, key) {\n  return map.get(key);\n}\n\nexport function map_insert(key, value, map) {\n  return map.insert(key, value);\n}\n\nfunction unsafe_percent_decode(string) {\n  return decodeURIComponent((string || "").replace("+", " "));\n}\n\nexport function percent_decode(string) {\n  try {\n    return new Ok(unsafe_percent_decode(string));\n  } catch (error) {\n    return new Error(Nil);\n  }\n}\n\nexport function percent_encode(string) {\n  return encodeURIComponent(string);\n}\n\nexport function parse_query(query) {\n  try {\n    let pairs = [];\n    for (let section of query.split("&")) {\n      let [key, value] = section.split("=");\n      if (!key) continue;\n      pairs.push([unsafe_percent_decode(key), unsafe_percent_decode(value)]);\n    }\n    return new Ok(List.fromArray(pairs));\n  } catch (error) {\n    return new Error(Nil);\n  }\n}\n\n// From https://developer.mozilla.org/en-US/docs/Glossary/Base64#Solution_2_%E2%80%93_rewrite_the_DOMs_atob()_and_btoa()_using_JavaScript\'s_TypedArrays_and_UTF-8\nexport function encode64(bit_string) {\n  let aBytes = bit_string.buffer;\n  let nMod3 = 2,\n    sB64Enc = "";\n\n  for (let nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {\n    nMod3 = nIdx % 3;\n    if (nIdx > 0 && ((nIdx * 4) / 3) % 76 === 0) {\n      sB64Enc += "\\r\\n";\n    }\n    nUint24 |= aBytes[nIdx] << ((16 >>> nMod3) & 24);\n    if (nMod3 === 2 || aBytes.length - nIdx === 1) {\n      sB64Enc += String.fromCharCode(\n        uint6ToB64((nUint24 >>> 18) & 63),\n        uint6ToB64((nUint24 >>> 12) & 63),\n        uint6ToB64((nUint24 >>> 6) & 63),\n        uint6ToB64(nUint24 & 63)\n      );\n      nUint24 = 0;\n    }\n  }\n\n  return (\n    sB64Enc.substr(0, sB64Enc.length - 2 + nMod3) +\n    (nMod3 === 2 ? "" : nMod3 === 1 ? "=" : "==")\n  );\n}\n\n// From https://developer.mozilla.org/en-US/docs/Glossary/Base64#Solution_2_%E2%80%93_rewrite_the_DOMs_atob()_and_btoa()_using_JavaScript\'s_TypedArrays_and_UTF-8\nfunction uint6ToB64(nUint6) {\n  return nUint6 < 26\n    ? nUint6 + 65\n    : nUint6 < 52\n    ? nUint6 + 71\n    : nUint6 < 62\n    ? nUint6 - 4\n    : nUint6 === 62\n    ? 43\n    : nUint6 === 63\n    ? 47\n    : 65;\n}\n\n// From https://developer.mozilla.org/en-US/docs/Glossary/Base64#Solution_2_%E2%80%93_rewrite_the_DOMs_atob()_and_btoa()_using_JavaScript\'s_TypedArrays_and_UTF-8\nfunction b64ToUint6(nChr) {\n  return nChr > 64 && nChr < 91\n    ? nChr - 65\n    : nChr > 96 && nChr < 123\n    ? nChr - 71\n    : nChr > 47 && nChr < 58\n    ? nChr + 4\n    : nChr === 43\n    ? 62\n    : nChr === 47\n    ? 63\n    : 0;\n}\n\n// From https://developer.mozilla.org/en-US/docs/Glossary/Base64#Solution_2_%E2%80%93_rewrite_the_DOMs_atob()_and_btoa()_using_JavaScript\'s_TypedArrays_and_UTF-8\nexport function decode64(sBase64) {\n  if (sBase64.match(/[^A-Za-z0-9\\+\\/=]/g)) return new Error(Nil);\n  let sB64Enc = sBase64.replace(/=/g, "");\n  let nInLen = sB64Enc.length;\n  let nOutLen = (nInLen * 3 + 1) >> 2;\n  let taBytes = new Uint8Array(nOutLen);\n\n  for (\n    let nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0;\n    nInIdx < nInLen;\n    nInIdx++\n  ) {\n    nMod4 = nInIdx & 3;\n    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << (6 * (3 - nMod4));\n    if (nMod4 === 3 || nInLen - nInIdx === 1) {\n      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n        taBytes[nOutIdx] = (nUint24 >>> ((16 >>> nMod3) & 24)) & 255;\n      }\n      nUint24 = 0;\n    }\n  }\n\n  return new Ok(new BitString(taBytes));\n}\n\nexport function classify_dynamic(data) {\n  if (typeof data === "string") {\n    return "String";\n  } else if (Result.isResult(data)) {\n    return "Result";\n  } else if (List.isList(data)) {\n    return "List";\n  } else if (Number.isInteger(data)) {\n    return "Int";\n  } else if (Array.isArray(data)) {\n    return `Tuple of ${data.length} elements`;\n  } else if (BitString.isBitString(data)) {\n    return "BitString";\n  } else if (data instanceof Map) {\n    return "Map";\n  } else if (typeof data === "number") {\n    return "Float";\n  } else {\n    let type = typeof data;\n    return type.charAt(0).toUpperCase() + type.slice(1);\n  }\n}\n\nfunction decoder_error(expected, got) {\n  return decoder_error_no_classify(expected, classify_dynamic(got));\n}\n\nfunction decoder_error_no_classify(expected, got) {\n  return new Error(\n    List.fromArray([new DecodeError(expected, got, List.fromArray([]))])\n  );\n}\n\nexport function decode_string(data) {\n  return typeof data === "string"\n    ? new Ok(data)\n    : decoder_error("String", data);\n}\n\nexport function decode_int(data) {\n  return Number.isInteger(data) ? new Ok(data) : decoder_error("Int", data);\n}\n\nexport function decode_float(data) {\n  return typeof data === "number" ? new Ok(data) : decoder_error("Float", data);\n}\n\nexport function decode_bool(data) {\n  return typeof data === "boolean" ? new Ok(data) : decoder_error("Bool", data);\n}\n\nexport function decode_bit_string(data) {\n  return BitString.isBitString(data)\n    ? new Ok(data)\n    : decoder_error("BitString", data);\n}\n\nexport function decode_tuple(data) {\n  return Array.isArray(data) ? new Ok(data) : decoder_error("Tuple", data);\n}\n\nexport function tuple_get(data, index) {\n  return index >= 0 && data.length > index\n    ? new Ok(data[index])\n    : new Error(Nil);\n}\n\nexport function decode_list(data) {\n  return List.isList(data) ? new Ok(data) : decoder_error("List", data);\n}\n\nexport function decode_result(data) {\n  return Result.isResult(data) ? new Ok(data) : decoder_error("Result", data);\n}\n\nexport function decode_map(data) {\n  return data instanceof Map ? new Ok(data) : decoder_error("Map", data);\n}\n\nexport function decode_option(data, decoder) {\n  if (data === null || data === undefined || data instanceof None)\n    return new Ok(new None());\n  if (data instanceof Some) data = data[0];\n  let result = decoder(data);\n  if (result.isOk()) {\n    return new Ok(new Some(result[0]));\n  } else {\n    return result;\n  }\n}\n\nexport function decode_field(value, name) {\n  let error = () => decoder_error_no_classify("field", "nothing");\n  if (value instanceof Map) {\n    let entry = value.get(name);\n    return entry.isOk() ? entry : error();\n  }\n  try {\n    return name in value ? new Ok(value[name]) : error();\n  } catch {\n    return error();\n  }\n}\n'}}]);